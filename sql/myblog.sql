CREATE DATABASE  IF NOT EXISTS `myblog` /*!40100 DEFAULT CHARACTER SET utf8 */;
USE `myblog`;
-- MySQL dump 10.13  Distrib 5.7.17, for Win64 (x86_64)
--
-- Host: 123.206.28.24    Database: myblog
-- ------------------------------------------------------
-- Server version	5.6.35

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `admin`
--

DROP TABLE IF EXISTS `admin`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `admin` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `adminname` varchar(45) DEFAULT NULL,
  `adminpasswd` varchar(45) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `admin`
--

LOCK TABLES `admin` WRITE;
/*!40000 ALTER TABLE `admin` DISABLE KEYS */;
INSERT INTO `admin` VALUES (1,'aaa','2f831d241385632c36126942f42e3d0b');
/*!40000 ALTER TABLE `admin` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `blog`
--

DROP TABLE IF EXISTS `blog`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `blog` (
  `blogid` int(11) NOT NULL AUTO_INCREMENT,
  `title` varchar(45) DEFAULT NULL,
  `summary` varchar(1000) DEFAULT NULL,
  `content` longtext,
  `create_at` varchar(100) DEFAULT NULL,
  `categoryid` int(11) DEFAULT NULL,
  `hits` int(11) DEFAULT NULL,
  `imageurl` varchar(1000) DEFAULT NULL,
  PRIMARY KEY (`blogid`)
) ENGINE=InnoDB AUTO_INCREMENT=575 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `blog`
--

LOCK TABLES `blog` WRITE;
/*!40000 ALTER TABLE `blog` DISABLE KEYS */;
INSERT INTO `blog` VALUES (3,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,7,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(5,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,20,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(6,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,28,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(7,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,29,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(8,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,27,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(9,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,34,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(10,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,31,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(11,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,31,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(12,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,14,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(14,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,22,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(15,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,33,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(16,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,22,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(21,'BSbsbsbs','heloo 哦i已被肉','<h1 id=\"h1-heloo-i-\"><a name=\"heloo 哦i已被肉\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>heloo 哦i已被肉</h1>','2017-01-23',3,9,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(25,'2017-02-28学习笔记','','<p><img src=\"http://ohlrxdl4p.bkt.clouddn.com/images/826546_1482322555369_C5DABB18734059E89A45A0E9170722B0.png\" alt=\"\"></p>','2017-02-28',1,11,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(26,'2017-03-01学习笔记','知识点 1.java中只有值传递，没有引用传递http://guhanjie.iteye.com/blog/1683637 2.final关键字 final修饰变量，则等同于常量. final修饰方法中的参数，称为最终参数. final修饰类，则类不能被继承. final修饰方法，则方法不能被','<h1 id=\"h1-u77E5u8BC6u70B9\"><a name=\"知识点\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>知识点</h1><h4 id=\"h4-1-java-http-guhanjie-iteye-com-blog-1683637\"><a name=\"1.java中只有值传递，没有引用传递  http://guhanjie.iteye.com/blog/1683637\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.java中只有值传递，没有引用传递<a href=\"http://guhanjie.iteye.com/blog/1683637\">http://guhanjie.iteye.com/blog/1683637</a></h4><h4 id=\"h4-2-final-\"><a name=\"2.final关键字\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.final关键字</h4><ul>\r\n<li>final修饰变量，则等同于常量.</li><li>final修饰方法中的参数，称为最终参数.</li><li>final修饰类，则类不能被继承.</li><li>final修饰方法，则方法不能被重写.</li></ul>\r\n<h4 id=\"h4-3-integer-img-src-https-uploadfiles-nowcoder-com-images-20160717-6316247_1468761643205_9f7b85ab04292cf73778d98998a20ed1-alt-\"><a name=\"3.Integer<img src=\"https://uploadfiles.nowcoder.com/images/20160717/6316247_1468761643205_9F7B85AB04292CF73778D98998A20ED1\" alt=\"图片\">\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.Integer<img src=\"https://uploadfiles.nowcoder.com/images/20160717/6316247_1468761643205_9F7B85AB04292CF73778D98998A20ED1\" alt=\"图片\"></h4><h4 id=\"h4-4-java-\"><a name=\"4.java内存模型   点击原文\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.java内存模型 <a href=\"http://blog.csdn.net/ns_code/article/details/17565503\">点击原文</a></h4><p><img src=\"https://uploadfiles.nowcoder.com/images/20161223/415611_1482452184396_6FB53C51539B47559CF0D122A832CF63\" alt=\"\"></p>\r\n<h4 id=\"h4-5-java-reference\"><a name=\"5.java中是没有指针的，有reference\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.java中是没有指针的，有reference</h4><p>第一：指针变量是在栈内存中，它也是有值的，这个值存储的就是地址单元，这个地址就是来自于赋值操作。<br>第二：指针变量有类型，这个类型（如Person）的含义是指针指向的变量在栈内存（不是很确定）中的范围（大小），我理解为是占用的堆内存空间。<br>第三：声明一个对象时，是对“指针变量”的定义。<br>第四：用new关键字在堆内存创建了对象，在赋值时，是把这个对象的首地址传给了这个“指针变量”（即引用型变量）。</p>\r\n<h4 id=\"h4-6-string-\"><a name=\"6.String生成常量\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6.String生成常量</h4><pre><code class=\"lang-java\">String s1=&quot;abc&quot;+&quot;def&quot;;//生成的是一个常量，放在堆内存中\r\nString s2=new String（s1);//s2是一个变量\r\nif(s1.equals(s2))//比较的是字符串的内容\r\n    System.out.println(&quot;.equals succeeded&quot;);//输出\r\nif(s1==s2)//比较的是内存地址，但s1是常量，所以不相等\r\n    System.out.println(&quot;==succeeded&quot;);\r\n</code></pre>\r\n<h4 id=\"h4-7-jsp-\"><a name=\"7.jsp内置对象和属性\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>7.jsp内置对象和属性</h4><p>（１）request对象<br>客户端的请求信息被封装在request对象中，通过它才能了解到客户的需求，然后做出响应。它是HttpServletRequest类的实例。<br>（２）response对象<br>response对象包含了响应客户请求的有关信息，但在JSP中很少直接用到它。它是HttpServletResponse类的实例。<br>（３）session对象<br>session对象指的是客户端与服务器的一次会话，从客户连到服务器的一个WebApplication开始，直到客户端与服务器断开连接为止。它是HttpSession类的实例.<br>（４）out对象<br>out对象是JspWriter类的实例,是向客户端输出内容常用的对象<br>（５）page对象<br>page对象就是指向当前JSP页面本身，有点象类中的this指针，它是java.lang.Object类的实例<br>（６）application对象<br>application对象实现了用户间数据的共享，可存放全局变量。它开始于服务器的启动，直到服务器的关闭，在此期间，此对象将一直存在；这样在用户的前后连接或不同用户之间的连接中，可以对此对象的同一属性进行操作；在任何地方对此对象属性的操作，都将影响到其他用户对此的访问。服务器的启动和关闭决定了application对象的生命。它是ServletContext类的实例。<br>（７）exception对象<br>exception对象是一个例外对象，当一个页面在运行过程中发生了例外，就产生这个对象。如果一个JSP页面要应用此对象，就必须把isErrorPage设为true，否则无法编译。他实际上是java.lang.Throwable的对象<br>（８）pageContext对象<br>pageContext对象提供了对JSP页面内所有的对象及名字空间的访问，也就是说他可以访问到本页所在的SESSION，也可以取本页面所在的application的某一属性值，他相当于页面中所有功能的集大成者，它的本 类名也叫pageContext。<br>（９）config对象<br>config对象是在一个Servlet初始化时，JSP引擎向它传递信息用的，此信息包括Servlet初始化时所要用到的参数（通过属性名和属性值构成）以及服务器的有关信息（通过传递一个ServletContext对象）</p>','2017-03-01',1,15,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(27,'2017-03-02学习笔记','知识点 一、static public class Spike\r\n{\r\n    public static void main(String[] args)\r\n    {\r\n        Counter a = new Counter();\r\n        System.out.println(a.increment());\r\n        System.out.println(a.anot','<h1 id=\"h1-u77E5u8BC6u70B9\"><a name=\"知识点\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>知识点</h1><h4 id=\"h4--static\"><a name=\"一、static\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、static</h4><pre><code class=\"lang-java\">public class Spike\r\n{\r\n    public static void main(String[] args)\r\n    {\r\n        Counter a = new Counter();\r\n        System.out.println(a.increment());\r\n        System.out.println(a.anotherIncrement());\r\n        Counter b = new Counter();\r\n        System.out.println(b.increment());\r\n    }\r\n}\r\nclass Counter\r\n{\r\n    private static int count = 0;\r\n    public int increment()\r\n    {\r\n        return count++;\r\n    }\r\n    public int anotherIncrement()\r\n    {\r\n        return ++count;\r\n    }\r\n}\r\n</code></pre>\r\n<p>count是静态变量，为所有对象所共享，因此不管a.increment()还是b.increment()都会使count持续增加。<br>increment()方法返回当前count值，然后count增加1<br>antoherIncrement()方法让count增加1，然后返回count值<br>第一次a.increment()返回值为0，此时count值为1<br>第二次a.anotherIncrement()先让count+1再返回，返回值为2<br>第三次b.increment()先返回count当前值2，然后count+1</p>\r\n<h4 id=\"h4--aop-\"><a name=\"二、AOP面向切面\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、AOP面向切面</h4><p>AOP的概念是Aspected Oriented Programming 面向方面编程。<br>  好处：AOP将程序分解成各个方面或者说关注点。这使得可以模块化，相当横向上分切了。它可以解决OOP和过程化方法不能够很好解决的横切（crosscut）问题，如：事务、安全、日志等横切关注。<br>  实现AOP有几种方式:<br>  1.Spring 1.2版本中通过ProxyFactoryBean来实现aop,即通过动态代理来实现的,Aspect必须继承MethodBeforeAdvice,MethodAfterAdvice等<br>  2.Spring 2.0 AOP需要改的是FBI 这个类，而且它也不需要再实现某些接口<br>  3.三使用标注（<a href=\"https://github.com/AspectJ\" title=\"&#64;AspectJ\" class=\"at-link\">@AspectJ</a>）实现AOP<br>    AOP 和 OOP的区别：</p>\r\n<pre><code>```html\r\n 1. 面向方面编程 AOP 偏重业务处理过程的某个步骤或阶段，强调降低模块之间的耦合度，使代码拥有更好的移植性。  \r\n 2. 面向对象编程 (oop) 则是对业务分析中抽取的实体进行方法和属性的封装。\r\n ```\r\n</code></pre><p>也可以说 AOP 是面向业务中的动词领域， OOP 面向名词领域。<br>AOP 的一个很重要的特点是源代码无关性，也就是说如果我们的系统中引用了 AOP 组件，即使我们把该组件去掉，系统代码也应该能够编译通过。要实现这一点，可以使用动态 proxy 模式。</p>\r\n<h4 id=\"h4--jdbc-\"><a name=\"三、jdbc桥接模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、jdbc桥接模式</h4><p>桥接模式：<br>定义 ：将抽象部分与它的实现部分分离，使它们都可以独立地变化。<br>意图 ：将抽象与实现解耦。<br>桥接模式所涉及的角色</p>\r\n<ol>\r\n<li>Abstraction ：定义抽象接口，拥有一个Implementor类型的对象引用</li><li>RefinedAbstraction ：扩展Abstraction中的接口定义</li><li>Implementor ：是具体实现的接口，Implementor和RefinedAbstraction接口并不一定完全一致，实际上这两个接口可以完全不一样Implementor提供具体操作方法，而Abstraction提供更高层次的调用</li><li>ConcreteImplementor ：实现Implementor接口，给出具体实现<br>Jdk中的桥接模式：JDBC<br>JDBC连接 数据库 的时候，在各个数据库之间进行切换，基本不需要动太多的代码，甚至丝毫不动，原因就是JDBC提供了统一接口，每个数据库提供各自的实现，用一个叫做数据库驱动的程序来桥接就行了<h4 id=\"h4--\"><a name=\"四、抽象类\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>四、抽象类</h4>抽象类和普通类有三点区别：<br>1）抽象方法必须为public和protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public。<br>2）抽象类不能用来创建对象，但是它可以有构造方法，用来帮助子类实例化。<br>3）如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为abstract类。<h4 id=\"h4--\"><a name=\"五、接口\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>五、接口</h4>接口的主要特点<br>1）接口中的成员变量默认都是public、static、final类型的，必须被显示初始化。<br>2）接口中的方法默认都是public、abstract类型的。<br>3）接口中只能包含public、static、final类型的成员变量和public、abstract类型的成员方法。<br>4）接口没有构造方法，不能被实例化。<br>5）一个接口不能实现另一个接口，但它可以继承多个其他接口。<br>6）接口必须通过类来实现它的抽象方法。<br>7）与子类继承抽象父类相似，当类实现了某个接口时，它必须实现接口中所有的抽象方法，否则这个类必须被定义为抽象类。<br>8）一个类只能继承一个直接的父类，但能实现多个接口。<h4 id=\"h4--\"><a name=\"六、抽象类和接口的区别\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>六、抽象类和接口的区别</h4>1）抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract方法；<br>2）抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；<br>3）接口中不能含有静态代码块以及静态方法，而抽象类尅有静态代码块和静态方法；<br>4）一个类只能继承一个抽象类，而一个类却可以实现多个接口。<br>5）抽象类中的方法子类必须全部实现，不然子类也是抽象类，而接口中的抽象方法子类必须全部实现，是可选择实现的。<br>6）抽象类是一种模板设计模式，而接口时一种行为规范。</li></ol>','2017-03-02',1,14,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(28,'2017-03-03学习笔记','一、String StringBuffer.toString()源码： @Override\r\npublic synchronized String toString() {\r\n    if (toStringCache == null) {\r\n        toStringCache = Arrays.copyOfRange(value, 0, count);\r\n    }\r\n    retur','<h4 id=\"h4--string\"><a name=\"一、String\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、String</h4><p>StringBuffer.toString()源码：</p>\r\n<pre><code class=\"lang-java\">@Override\r\npublic synchronized String toString() {\r\n    if (toStringCache == null) {\r\n        toStringCache = Arrays.copyOfRange(value, 0, count);\r\n    }\r\n    return new String(toStringCache, true);\r\n}\r\n</code></pre>\r\n<p>Arrays.copyOfRange用的是System.arraycopy</p>\r\n<pre><code class=\"lang-java\">public static char[] copyOfRange(char[] original, int from, int to) {\r\n        int newLength = to - from;\r\n        if (newLength &lt; 0)\r\n            throw new IllegalArgumentException(from + &quot; &gt; &quot; + to);\r\n        char[] copy = new char[newLength];\r\n        System.arraycopy(original, from, copy, 0,\r\n                         Math.min(original.length - from, newLength));\r\n        return copy;\r\n    }\r\n</code></pre>\r\n<p>1.String是值传入，不是引用传入。<br>2.String对String  类型进行改变的时候其实都等同于生成了一个新的  String  对象，然后将指针指向新的  String  对象，而不是StringBuffer；StringBuffer每次结果都会对  StringBuffer  对象本身进行操作，而不是生成新的对象，再改变对象引用。<br>3.效率比较String&lt;StringBuffer&lt;StringBuilder，但是在 String S1 = “This is only a” + “ simple” + “ test”时，String效率最高。</p>\r\n<h4 id=\"h4--jvm-\"><a name=\"二、jvm知识图谱\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、jvm知识图谱</h4><p><a href=\"https://zhuanlan.zhihu.com/p/25511795\">引用自知乎</a><br><img src=\"https://pic2.zhimg.com/v2-701563ac1fe745fc8e1234c96e82ac99_r.jpg\" alt=\"\"></p>\r\n<h4 id=\"h4--treemap-linkhashmap\"><a name=\"三、Treemap、LinkHashMap\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、Treemap、LinkHashMap</h4><p>1.TreeMap取出来的是排序后的键值对。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。<br>2.LinkedHashMap 是HashMap的一个子类，如果需要输出的顺序和输入的相同,那么用LinkedHashMap可以实现,它还可以按读取顺序来排列。</p>\r\n<h4 id=\"h4--sql-\"><a name=\"四、sql模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>四、sql模式</h4><p>MySQL数据库中，变量分为 系统变量（以”@@”开头）和用户自定义变量。系统变量分为全局系统变量(global)和会话系统变量(session)。<br>@<a href=\"https://github.com/global\" title=\"&#64;global\" class=\"at-link\">@global</a>     仅用于访问全局系统变量的值；<br>@<a href=\"https://github.com/session\" title=\"&#64;session\" class=\"at-link\">@session</a>  仅用于访问会话系统变量的值；<br>@@              先访问会话系统变量的值，若不存在则去访问全局系统变量的值；<br>sql_mode 为系统变量，既是全局系统变量，又是会话系统变量。</p>\r\n<h4 id=\"h4--\"><a name=\"五、代码的执行顺序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>五、代码的执行顺序</h4><p>父类Ｂ静态代码块-&gt;子类Ａ静态代码块-&gt;父类Ｂ非静态代码块-&gt;父类Ｂ构造函数-&gt;子类Ａ非静态代码块-&gt;子类Ａ构造函数<br><img src=\"http://ohlrxdl4p.bkt.clouddn.com/images/QQ截图20170303165728.jpg\" alt=\"\"></p>','2017-03-03',1,13,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(29,'ifhifhajfe','hello','<h1 id=\"h1-hello\"><a name=\"hello\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>hello</h1>','2017-03-05',1,13,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(30,'2017-03-05学习笔记','java的堆，栈，静态代码区（常量区） 详解','<p><a href=\"http://blog.csdn.net/u012031380/article/details/54981472\"> java的堆，栈，静态代码区（常量区） 详解</a></p>','2017-03-05',1,16,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(31,'java归并排序','package datastruct;\r\n\r\n/**\r\n * Created by Zephery on 2017/3/3.\r\n */\r\npublic class Solution {\r\n    public static void printArray(int[] arr, int i, int j) {\r\n        System.out.print(\"[\");\r\n        for','<pre><code class=\"lang-java\">package datastruct;\r\n\r\n/**\r\n * Created by Zephery on 2017/3/3.\r\n */\r\npublic class Solution {\r\n    public static void printArray(int[] arr, int i, int j) {\r\n        System.out.print(&quot;[&quot;);\r\n        for (int k = i; k &lt; j; k++) {\r\n            System.out.print(arr[k] + &quot;,&quot;);\r\n        }\r\n        System.out.print(arr[j] + &quot;]&quot;);\r\n    }\r\n\r\n    private static void mergesort(int[] arr, int i, int j) {\r\n        int mid = 0;\r\n        if (i &lt; j) {\r\n            mid = (i + j) / 2;\r\n            mergesort(arr, i, mid);\r\n            mergesort(arr, mid + 1, j);\r\n            merge(arr, i, mid, j);\r\n        }\r\n    }\r\n\r\n    private static void merge(int[] arr, int i, int mid, int j) {\r\n        System.out.print(&quot;Left:&quot;);\r\n        printArray(arr, i, mid);\r\n        System.out.println(&quot;Right:&quot;);\r\n        printArray(arr, mid + 1, j);\r\n        System.out.println();\r\n        int temp[] = new int[arr.length];\r\n        int l = i;\r\n        int r = j;\r\n        int m = mid + 1;\r\n        int k = l;\r\n        while (l &lt;= mid &amp;&amp; m &lt;= r) {\r\n            if (arr[l] &lt;= arr[m]) {\r\n                temp[k++] = arr[l++];\r\n            } else {\r\n                temp[k++] = arr[m++];\r\n            }\r\n        }\r\n        while (l &lt;= mid) {\r\n            temp[k++] = arr[l++];\r\n        }\r\n        while (m &lt;= r) {\r\n            temp[k++] = arr[m++];\r\n        }\r\n        for (int i1 = i; i1 &lt;= j; i1++) {\r\n            arr[i1] = temp[i1];\r\n        }\r\n        System.out.print(&quot;After Merge:&quot;);\r\n        printArray(arr, i, j);\r\n        System.out.println();\r\n    }\r\n\r\n    public static void main(String args[]) {\r\n        int[] arr = {9, 4, 8, 3, 1, 2, 5};\r\n        System.out.print(&quot;Initial Array:&quot;);\r\n        printArray(arr, 0, arr.length - 1);\r\n        System.out.println();\r\n        mergesort(arr, 0, arr.length - 1);\r\n    }\r\n}\r\n</code></pre>\r\n<pre><code class=\"lang-js\">Initial Array:[9,4,8,3,1,2,5]\r\nLeft:[9]Right:\r\n[4]\r\nAfter Merge:[4,9]\r\nLeft:[8]Right:\r\n[3]\r\nAfter Merge:[3,8]\r\nLeft:[4,9]Right:\r\n[3,8]\r\nAfter Merge:[3,4,8,9]\r\nLeft:[1]Right:\r\n[2]\r\nAfter Merge:[1,2]\r\nLeft:[1,2]Right:\r\n[5]\r\nAfter Merge:[1,2,5]\r\nLeft:[3,4,8,9]Right:\r\n[1,2,5]\r\nAfter Merge:[1,2,3,4,5,8,9]\r\n</code></pre>','2017-03-06',1,21,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(32,'2017-03-10学习笔记','1.Integer和int，装箱拆箱 1、基本型和基本型封装型进行“==”运算符的比较，基本型封装型将会自动拆箱变为基本型后再进行比较，因此Integer(0)会自动拆箱为int类型再进行比较，显然返回true； 2、两个Integer类型进行“==”比较，如果其值在-128至127，那么返回true，否则返回false, 这跟Integer.valueOf()的缓冲对象有关，这里不进行赘述。 3','<h1 id=\"h1-1-integer-int-\"><a name=\"1.Integer和int，装箱拆箱\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.Integer和int，装箱拆箱</h1><p>1、基本型和基本型封装型进行“==”运算符的比较，基本型封装型将会自动拆箱变为基本型后再进行比较，因此Integer(0)会自动拆箱为int类型再进行比较，显然返回true；<br>2、两个Integer类型进行“==”比较，如果其值在-128至127，那么返回true，否则返回false, 这跟Integer.valueOf()的缓冲对象有关，这里不进行赘述。<br>3、两个基本型的封装型进行equals()比较，首先equals()会比较类型，如果类型相同，则继续比较值，如果值也相同，返回true<br>4、基本型封装类型调用equals(),但是参数是基本类型，这时候，先会进行自动装箱，基本型转换为其封装类型，再进行3中的比较。</p>\r\n<pre><code class=\"lang-java\">int a=257;\r\nInteger b=257;\r\nInteger c=257;\r\nInteger b2=57;\r\nInteger c2=57;\r\nSystem.out.println(a==b);\r\n//System.out.println(a.equals(b));  编译出错，基本型不能调用equals()\r\nSystem.out.println(b.equals(257.0));\r\nSystem.out.println(b==c);\r\nSystem.out.println(b2==c2);\r\n</code></pre>\r\n<p>因此上面的代码的结果因此为 true, false, false, true</p>\r\n<h1 id=\"h1-2-\"><a name=\"2.线程调度\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.线程调度</h1><p>分为协同式调度和抢占式调度，Java使用的是抢占式调度，也就是每个线程将由操作系统来分配执行时间，线程的切换不由线程本身来决定（协同式调度）。这就是平台独立的原因。</p>\r\n<h1 id=\"h1-3-\"><a name=\"3.重载，重写\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.重载，重写</h1><p>重写：<br>两同，两小，一大<br>两同：方法名，方法参数列表相同。<br>两小：抛出的异常类型要小于等于父类，返回值类型要小于等于父类<br>一大：访问权限大于等于父类。<br>重载：<br>在同一个类中，方法名和方法参数列表不同，其他的（访问权限、返回值）随意。</p>\r\n<h1 id=\"h1-4-jvm-\"><a name=\"4.  JVM面试题\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.<a href=\"http://blog.csdn.net/hsk256/article/details/49104955\">JVM面试题</a></h1>','2017-03-10',1,19,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(33,'2017-03-12学习笔记','1.继承的加载顺序 执行顺序大体上可以说是先父类后子类，父类static域 ==》子类static域 ==》父类数据成员域 ==》父类构造器 ==》子类数据成员域 ==》子类构造器 2.优化Hibernate所鼓励的7大措施： 1.尽量使用many-to-one，避免使用单项one-to-many 2.灵活使用单向one-to-many 3.不用一对一，使用多对一代替一对一 4.配置对象缓存，不使','<h4 id=\"h4-1-\"><a name=\"1.  继承的加载顺序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.<a href=\"http://www.cnblogs.com/SirSmith/p/5536288.html\">继承的加载顺序</a></h4><p><img src=\"http://images2015.cnblogs.com/blog/452847/201605/452847-20160527221410288-2119099273.png\" alt=\"\"></p>\r\n<p>执行顺序大体上可以说是先父类后子类，父类static域 ==》子类static域 ==》父类数据成员域 ==》父类构造器 ==》子类数据成员域 ==》子类构造器</p>\r\n<h4 id=\"h4-2-hibernate-7-\"><a name=\"2.优化Hibernate所鼓励的7大措施：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.优化Hibernate所鼓励的7大措施：</h4><p>1.尽量使用many-to-one，避免使用单项one-to-many<br>2.灵活使用单向one-to-many<br>3.不用一对一，使用多对一代替一对一<br>4.配置对象缓存，不使用集合缓存<br>5.一对多使用Bag 多对一使用Set<br>6.继承使用显示多态 HQL:from object polymorphism=”exlicit” 避免查处所有对象<br>7.消除大表，使用二级缓存</p>\r\n<h4 id=\"h4-3-java-\"><a name=\"3.java中的数据类型分类：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.java中的数据类型分类：</h4><p>基本数据类型（或叫做原生类、内置类型）8种：<br>    整数：byte，short，int，long（默认是int类型）<br>    浮点类型： float，double（默认是double类型）<br>    字符类型：char<br>    布尔类型：boolean<br>引用数据类型3种：数组，类，接口</p>\r\n<h4 id=\"h4-4-\"><a name=\"4.触发器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.触发器</h4><p>drop trigger 删除触发器<br>Drop用于删除数据表或数据库，或删除数据表字段。<br>remove：删除数据库文件<br>Truncate：删除数据表中的数据（仅数据表中的数据，不删除表）。</p>','2017-03-12',1,16,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(34,'2017-03-14学习笔记','1.Servlet的生命周期分为5个阶段：加载、创建、初始化、处理客户请求、卸载。 (1)加载：容器通过类加载器使用servlet类对应的文件加载servlet (2)创建：通过调用servlet构造函数创建一个servlet对象 (3)初始化：调用init方法初始化 (4)处理客户请求：每当有一个客户请求，容器会创建一个线程来处理客户请求 (5)卸载：调用destroy方法让servlet自己释','<h4 id=\"h4-1-servlet-5-\"><a name=\"1.Servlet的生命周期分为5个阶段：加载、创建、初始化、处理客户请求、卸载。\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.Servlet的生命周期分为5个阶段：加载、创建、初始化、处理客户请求、卸载。</h4><p>(1)加载：容器通过类加载器使用servlet类对应的文件加载servlet<br>(2)创建：通过调用servlet构造函数创建一个servlet对象<br>(3)初始化：调用init方法初始化<br>(4)处理客户请求：每当有一个客户请求，容器会创建一个线程来处理客户请求<br>(5)卸载：调用destroy方法让servlet自己释放其占用的资源</p>\r\n<h4 id=\"h4-2-jsp\"><a name=\"2.JSP\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.JSP</h4><p><img src=\"http://uploadfiles.nowcoder.com/images/20160308/595432_1457414324036_C3D4EB7F2D61708D0C0BE2921A45B74D\" alt=\"\"></p>','2017-03-14',1,8,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(36,'2017-03-17学习笔记','1.GC线程是否和守护线程 2.java堆排序','<h4 id=\"h4-1-gc-\"><a name=\"1.GC线程是否和守护线程\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.GC线程是否和守护线程</h4><h4 id=\"h4-2-java-\"><a name=\"2.java堆排序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.java堆排序</h4>','2017-03-17',1,12,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(37,'春招~好失落啊','自己的情况：广东人，大学跑到天津一所二本学校，网络工程专业，大一大二学ccna、ccnp，发现没有创造性，按着别人的死规定敲命令好无聊，大三彻底转向编程，c++看着不爽，调研一番后选择java，自学java和java web，对jsp、servlet略过，直接上手框架（Struts，hibernate，spring），看书，找视频，敲项目，非专业课（操作系统，数据库等）不听，捣鼓一番觉得还行，继续','<p>自己的情况：广东人，大学跑到天津一所二本学校，网络工程专业，大一大二学ccna、ccnp，发现没有创造性，按着别人的死规定敲命令好无聊，大三彻底转向编程，c++看着不爽，调研一番后选择java，自学java和java web，对jsp、servlet略过，直接上手框架（Struts，hibernate，spring），看书，找视频，敲项目，非专业课（操作系统，数据库等）不听，捣鼓一番觉得还行，继续学习spring mvc，mybatis，开始了解hadoop、spark，同时搭了自己的网站，跟了软件工程的同学比了比，还能算上前列吧，当然，基础和算法跟前列的人还没得比~~~</p>\r\n<p>去年秋招，腾讯、阿里等笔试全挂，京东的没怎么做却过了，不敢去面试（真心没怎么做题），最后去了北京一家创业公司实习了三个月多，感觉真心好，12月几乎整整一个月雾霾，受不了，还是回广东吧。在家过了春节，2月10号跟同学一起来深圳，就这样，开始了春招之旅~~~~</p>\r\n<p>第一家，面试的问的差不多全答对，手写了几个sql也对了，不过居然没有问hashmap，给的工资6000到9000，想了想，还是不去的好，太郊区，后来一查，是个培训兼外包的企业，还好没去。。。。</p>\r\n<p>第二家，某ERP公司，额，笔试，全是sql，做了，感觉还可以，面试直接说我们公司不用java，用的一个小众语言，薪资应届生只有3500，直接走人。。。。</p>\r\n<p>第三家，找工作，对广东真是彻底失望了，投的简历除了培训机构理你，其他的都不理人的，无奈之下投了北京的一家创业公司（A轮），薪资1万，电话面试，过了。。。。。后来想想，还是不去北京了，虽然工资高，但是没有朋友，过得像个死人一样。</p>\r\n<p>第四家，深圳一家创业公司，做东南亚社交软件的，可惜薪资没谈成，4K-6K，这可是深圳啊。。。。</p>\r\n<p>第五家，广州凡科，那天一早就从深圳跑过去，没吃饭，下午到就做笔试题，头晕，手抖，然后一面就是跟你讲笔试题，讲了两道，就叫我走了。。。仅仅半个小时，广深来回6个小时。。。</p>\r\n<p>第六家，广州某搞运维的公司，笔试差不多答对，面试问的问题也答对，但是没给offer。。。不理解</p>\r\n<p>第七家，然后晚上跑去了广工的久邦数码宣讲，试卷发到我这的时候，HR说我这方向的试卷没带够。。。。无奈向他要了大数据的题，全是数据库的题，过几天后得知居然过了，然后一面，问的问题没啥印象，除了left join的原理没答对。。。今天得知挂了。。。。</p>\r\n<p><img src=\"http://images2015.cnblogs.com/blog/755525/201703/755525-20170318000537838-305991370.png\" alt=\"\"></p>\r\n<p>第八家，极天信息（A轮），笔试的题目没看懂它问的啥，一面没啥印象了，然后是经理面，说广州没那么高的工资（7000），等消息，估计也没谈成。。。。</p>\r\n<p>第九家，中国移动，最气的了，一面就是HR面，问了两个问题，为什么不在北京留着，你觉得相比其他人你有什么优势。我只能说我真不会说话更不知怎么回答，就强调勤奋，然后直接被HR叫走人了，3分钟=w=</p>\r\n<p>第十家，珍爱网，找别人内推的，三个问题没答上来，就不跟你们说了，亲爱的竞争对手们=w=，谈了四十分钟吧，出来后感觉很不好，估计也是挂了。。。</p>\r\n<p>今天晚上，收到了久邦数码的拒绝信，瞬间觉得好无奈好迷茫，有时候就那么一个简简单单的问题，答不好就直接拒绝的，改怎么心平气和的面对下一个面试。有时候真不理解公司是怎么招人的，是不是真的“把部分简历扔进垃圾桶，不招那些运气不好的人”？也只能这么安慰自己。可是，事实呢？</p>\r\n<p><img src=\"http://images2015.cnblogs.com/blog/755525/201703/755525-20170318001336463-1583022291.jpg\" alt=\"\"></p>\r\n<p>这些天，有时间都是往深圳图书馆跑，看书，刷牛客网，补算法，看源码，做了这么多，该怎么告诉自己不要放弃。。。。。开始有点想念北京的雾霾</p>','2017-03-18',5,13,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(50,'数据库','1.SQL执行的顺序 2.NULL “空值” 和”NULL”的概念： 1：空值(‘’)是不占用空间的,判断空字符用 = ‘’ 或者 <> ‘’ 来进行处理; 2: NULL值是未知的，且占用空间，不走索引;判断 NULL 用 IS NULL 或者 is not null , SQL 语句函数中可以使用 ifnull ()函数来进行处理. 注：在进行 count ()统计某列的记录数的时候，如果采用','<h4 id=\"h4-1-sql-\"><a name=\"1.SQL执行的顺序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.SQL执行的顺序</h4><p><img src=\"http://uploadfiles.nowcoder.com/images/20150828/415611_1440751995009_3B3E1329A400F0022B20C4F32AEFC9EF\" alt=\"\"></p>\r\n<h4 id=\"h4-2-null\"><a name=\"2.NULL\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.NULL</h4><p>“空值” 和”NULL”的概念：<br>  1：空值(‘’)是不占用空间的,判断空字符用 = ‘’ 或者 &lt;&gt; ‘’ 来进行处理;<br> 2: NULL值是未知的，且占用空间，不走索引;判断 NULL 用 IS NULL 或者 is not null , SQL 语句函数中可以使用 ifnull ()函数来进行处理.<br>注：在进行 count ()统计某列的记录数的时候，如果采用的 NULL 值，会别系统自动忽略掉，但是空值是统计到其中</p>\r\n<h4 id=\"h4-3-\"><a name=\"3.\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.</h4><p>在MySQL数据库中，NULL对于一些特殊类型的列来说，其代表了一种特殊的含义，而不仅仅是一个空值。<br>IS NULL: 此运算符返回true，当列的值是NULL。<br>IS NOT NULL: 运算符返回true，当列的值不是NULL。<br>&lt;=&gt; 操作符比较值（不同于=运算符）为ture，即使两个NULL值<br>涉及NULL条件是特殊的。不能使用 =NULL 或 !=NULL 寻找NULL值的列</p>\r\n<h4 id=\"h4-4-nf\"><a name=\"4.NF\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.NF</h4><p>第一范式（   1NF   ）：   字段具有   原子性   ,   不可再分   。所有关系型数据库系统都满足第一范式）数据库表中的字段都是单一属性的，不可再分。例如，姓名字段，其中的姓和名必须作为一个整体，无法区分哪部分是姓，哪部分是名，如果要区分出姓和名，必须设计成两个独立的字段。<br>第二范式（   2NF   ）：   第二范式（   2NF   ）是在   第一范式（   1NF   ）的基础上   建立起来的，即满足第二范式（   2NF   ）必须先满足第一范式（   1NF   ）。要求   数据库表中的每个实例或行必须可以被惟一地区分   。通常需要为表加上一个列，以存储各个实例的惟一标识。这个惟一属性列被称为   主关键字或主键   。<br>        第二范式（   2NF   ）要求   实体的属性完全依赖于主关键字   。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。简而言之，第二范式就是非主属性非部分依赖于主关键字。<br>第三范式 （  3NF  ） ：   满足第三范式（   3NF   ）   必须先满足第二范式（   2NF   ）   。简而言之，第三范式（   3NF   ）要求一个数据库表中   不包含   已在其它表中   已包含的非主关键字信息   。所以第三范式具有如下特征：<br>1   ，每一列只有一个值<br>2   ，每一行都能区分。<br>3   ，每一个表都   不包含其他表已经包含   的非主关键字信息。<br>例如，帖子表中只能出现发帖人的   id   ，而不能出现发帖人的   id   ，还同时出现发帖人姓名，否则，只要出现同一发帖人   id   的所有记录，它们中的姓名部分都必须严格保持一致，这就是   数据冗余   。</p>','2017-03-18',3,7,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(53,'重载与重写','目前的问题：父类的功能无法满足子类的需求。 方法重写的前提： 必须要存在继承的关系。 方法的重写: 子父类出了同名的函数，这个我们就称作为方法的重写。 什么是时候要使用方法的重写：父类的功能无法满足子类的需求时。 方法重写要注意的事项： 1.方法重写时， 方法名与形参列表必须一致。 2.方法重写时，子类的权限修饰符必须要大于或者等于父类的权限修饰符。 3.方法重写时，子类的返回值类型必须要小于或者','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><p>目前的问题：父类的功能无法满足子类的需求。</p>\n<p>方法重写的前提： 必须要存在继承的关系。</p>\n<p>方法的重写: 子父类出了同名的函数，这个我们就称作为方法的重写。</p>\n<p>什么是时候要使用方法的重写：父类的功能无法满足子类的需求时。</p>\n<p>方法重写要注意的事项：<br>    1.方法重写时， 方法名与形参列表必须一致。<br>    2.方法重写时，子类的权限修饰符必须要大于或者等于父类的权限修饰符。<br>    3.方法重写时，子类的返回值类型必须要小于或者 等于父类的返回值类型。<br>    4.方法重写时， 子类抛出的异常类型要小于或者等于父类抛出的异常类型。<br>            Exception(最坏)<br>            RuntimeException(小坏)</p>\n<p>方法的重载：在一个类中 存在两个或者两个 以上的同名函数,称作为方法重载。</p>\n<p>方法重载的要求</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"lit\">1.</span><span class=\"pln\"> </span><span class=\"pun\">函数名要一致。</span></code></li><li class=\"L1\"><code><span class=\"lit\">2.</span><span class=\"pln\"> </span><span class=\"pun\">形参列表不一致（形参的个数或形参</span><span class=\"pln\"> </span><span class=\"pun\">的类型不一致）</span></code></li><li class=\"L2\"><code><span class=\"lit\">3.</span><span class=\"pln\"> </span><span class=\"pun\">与返回值类型无关。</span></code></li></ol></pre></div>','2017-03-21',1,4,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(59,'垃圾回收算法','垃圾回收算法 1、标记-清除算法 2、复制算法 3、标记-整理算法 一、标记-清除算法 标记-清除算法采用从根集合进行扫描，对存活的对象对象标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收，如上图所示。 标记-清除算法不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效，但由于标记-清除算法直接回收不存活的对象，因此会造成内存碎片！ 二、复制算法 复制算法','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h2 id=\"h2-u5783u573Eu56DEu6536u7B97u6CD5\"><a name=\"垃圾回收算法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>垃圾回收算法</h2><p>1、标记-清除算法<br>2、复制算法<br>3、标记-整理算法</p>\n<h4 id=\"h4--\"><a name=\"一、标记-清除算法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、标记-清除算法</h4><p><img src=\"http://dl2.iteye.com/upload/attachment/0075/0386/29ae17ad-f8af-38b4-9e25-28ef3550858f.jpg\" alt=\"\">标记-清除算法采用从根集合进行扫描，对存活的对象对象标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收，如上图所示。<br>标记-清除算法不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效，但由于标记-清除算法直接回收不存活的对象，因此会造成内存碎片！</p>\n<h4 id=\"h4--\"><a name=\"二、复制算法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、复制算法</h4><p><img src=\"http://dl2.iteye.com/upload/attachment/0075/0388/91a656d4-f08a-377b-8eea-5785c2932533.jpg\" alt=\"\"><br>复制算法采用从根集合扫描，并将存活对象复制到一块新的，没有使用过的空间中，这种算法当控件存活的对象比较少时，极为高效，但是带来的成本是需要一块内存交换空间用于进行对象的移动。也就是我们前面提到的s0 s1等空间。</p>\n<h4 id=\"h4--\"><a name=\"三、标记-整理算法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、标记-整理算法</h4><p><img src=\"http://dl2.iteye.com/upload/attachment/0075/0390/6ba95f80-c7bc-3d09-b927-ac09297e9920.jpg\" alt=\"\"><br> 标记-整理算法采用标记-清除算法一样的方式进行对象的标记，但在清除时不同，在回收不存活的对象占用的空间后，会将所有的存活对象往左端空闲空间移动，并更新对应的指针。标记-整理算法是在标记-清除算法的基础上，又进行了对象的移动，因此成本更高，但是却解决了内存碎片的问题。</p>\n</div>','2017-04-09',1,19,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(60,'java分代回收','一、新生代内存的回收（minor GC）主要采用复制算法，下图展示了minor GC的执行过程。 二、对于新生代和旧生代，JVM可使用很多种垃圾回收器进行垃圾回收，下图展示了不同生代不通垃圾回收器，其中两个回收器之间有连线表示这两个回收器可以同时使用。 而这些垃圾回收器又分为串行回收方式、并行回收方式合并发回收方式执行，分别运用于不同的场景。如下图所示 三、收集器 1.Serial收集器 看名字我','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h2 id=\"h2--minor-gc-minor-gc-\"><a name=\"一、新生代内存的回收（minor GC）主要采用复制算法，下图展示了minor GC的执行过程。\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、新生代内存的回收（minor GC）主要采用复制算法，下图展示了minor GC的执行过程。</h2><p><img src=\"http://dl2.iteye.com/upload/attachment/0075/0392/732c7557-aa9a-3551-b14d-f543c5b0c94b.jpg\" alt=\"\"></p>\n<h2 id=\"h2--jvm-\"><a name=\"二、对于新生代和旧生代，JVM可使用很多种垃圾回收器进行垃圾回收，下图展示了不同生代不通垃圾回收器，其中两个回收器之间有连线表示这两个回收器可以同时使用。\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、对于新生代和旧生代，JVM可使用很多种垃圾回收器进行垃圾回收，下图展示了不同生代不通垃圾回收器，其中两个回收器之间有连线表示这两个回收器可以同时使用。</h2><p><img src=\"http://dl2.iteye.com/upload/attachment/0075/0394/0172f624-9018-3642-bf26-05a2c3071639.jpg\" alt=\"\"><br>而这些垃圾回收器又分为串行回收方式、并行回收方式合并发回收方式执行，分别运用于不同的场景。如下图所示<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0396/c962c2ad-273f-3de4-b2e3-a4dd8b946215.jpg\" alt=\"\"></p>\n<h2 id=\"h2--\"><a name=\"三、收集器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、收集器</h2><h4 id=\"h4-1-serial-\"><a name=\"1.Serial收集器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.Serial收集器</h4><p>看名字我们都可以看的出来，这个属于串行收集器。其运行示意图如下<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0398/681da5ca-5eff-3984-bece-3d80dfe905be.jpg\" alt=\"\"><br>    收集器是历史最悠久的一个回收器，JDK1.3之前广泛使用这个收集器，目前也是ClientVM下 ServerVM 4核4GB以下机器的默认垃圾回收器。串行收集器并不是只能使用一个CPU进行收集，而是当JVM需要进行垃圾回收的时候，需要中断所有的用户线程，知道它回收结束为止，因此又号称“Stop The World” 的垃圾回收器。注意，JVM中文名称为java虚拟机，因此它就像一台虚拟的电脑一样在工作，而其中的每一个线程就被认为是JVM的一个处理器，因此大家看到图中的CPU0、CPU1实际为用户的线程，而不是真正机器的CPU，大家不要误解哦。<br>    串行回收方式适合低端机器，是Client模式下的默认收集器，对CPU和内存的消耗不高，适合用户交互比较少，后台任务较多的系统。<br>    Serial收集器默认新旧生代的回收器搭配为Serial+ SerialOld</p>\n<h4 id=\"h4-2-parnew-\"><a name=\"2.ParNew收集器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.ParNew收集器</h4><p>ParNew收集器其实就是多线程版本的Serial收集器，其运行示意图如下<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0400/6443b39c-ed33-3d93-a690-87e646439561.jpg\" alt=\"\"><br>同样有Stop The World的问题，他是多CPU模式下的首选回收器（该回收器在单CPU的环境下回收效率远远低于Serial收集器，所以一定要注意场景哦），也是Server模式下的默认收集器。</p>\n<h4 id=\"h4-3-parallelscavenge\"><a name=\"3.ParallelScavenge\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.ParallelScavenge</h4><p>ParallelScavenge又被称为是吞吐量优先的收集器，器运行示意图如下<br><img src=\"http://dl.iteye.com/upload/attachment/0075/0402/5007beba-0b0e-3cf4-b146-c28b6c0dd696.jpg\" alt=\"\"><br> ParallelScavenge<br>所提到的吞吐量=程序运行时间/(JVM执行回收的时间+程序运行时间),假设程序运行了100分钟，JVM的垃圾回收占用1分钟，那么吞吐量就是99%。在当今网络告诉发达的今天，良好的响应速度是提升用户体验的一个重要指标，多核并行云计算的发展要求程序尽可能的使用CPU和内存资源，尽快的计算出最终结果，因此在交互不多的云端，比较适合使用该回收器。</p>\n<h4 id=\"h4-4-parallelold\"><a name=\"4.ParallelOld\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.ParallelOld</h4><p>ParallelOld是老生代并行收集器的一种，使用标记整理算法、是老生代吞吐量优先的一个收集器。这个收集器是JDK1.6之后刚引入的一款收集器，我们看之前那个图之间的关联关系可以看到，早期没有ParallelOld之前，吞吐量优先的收集器老生代只能使用串行回收收集器，大大的拖累了吞吐量优先的性能，自从JDK1.6之后，才能真正做到较高效率的吞吐量优先。其运行示意图如下<br><img src=\"http://dl.iteye.com/upload/attachment/0075/0406/9a14da85-f943-3408-ba88-c6bb3842a792.jpg\" alt=\"\"></p>\n<h4 id=\"h4-5-serialold\"><a name=\"5.SerialOld\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.SerialOld</h4><p>SerialOld是旧生代Client模式下的默认收集器，单线程执行；在JDK1.6之前也是ParallelScvenge回收新生代模式下旧生代的默认收集器，同时也是并发收集器CMS回收失败后的备用收集器。其运行示意图如下<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0404/ce7aabd5-b0e0-3cda-9b6c-607cf6ebf689.jpg\" alt=\"\"></p>\n<h4 id=\"h4-5-cms\"><a name=\"5.CMS\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.CMS</h4><p>CMS又称响应时间优先(最短回收停顿)的回收器，使用并发模式回收垃圾，使用标记-清除算法，CMS对CPU是非常敏感的，它的回收线程数=（CPU+3）/4，因此当CPU是2核的实惠，回收线程将占用的CPU资源的50%，而当CPU核心数为4时仅占用25%。他的运行示意图如下<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0408/4239228b-879f-382f-81c6-5c32799886d6.jpg\" alt=\"\"><br>模式主要分为四个过程：<br>1.初始标记<br>2.并发标记<br>3.重新标记<br>4.并发清除<br>在初始标记的时候，需要中断所有用户线程，在并发标记阶段，用户线程和标记线程<br>并发执行，而在这个过程中，随着内存引用关系的变化，可能会发生原来标记的对象被释放，进而引发新的垃圾，因此可能会产生一系列的浮动垃圾，不能被回收。</p>\n<p>CMS 为了确保能够扫描到所有的对象，避免在Initial Marking 中还有未标识到的对象，采用的方法为找到标记了的对象，并将这些对象放入Stack 中，扫描时寻找此对象依赖的对象，如果依赖的对象的地址在其之前，则将此对象进行标记，并同时放入Stack 中，如依赖的对象地址在其之后，则仅标记该对象。<br>在进行Concurrent Marking 时minor GC 也可能会同时进行，这个时候很容易造成旧生代对象引用关系改变，CMS 为了应对这样的并发现象，提供了一个Mod Union Table 来进行记录，在这个Mod Union Table中记录每次minor GC 后修改了的Card 的信息。这也是ParallelScavenge不能和CMS一起使用的原因。<br>CMS产生浮动垃圾的情况请见如下示意图<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0410/60e7c659-790a-3405-af70-9ca4cfd9258d.jpg\" alt=\"\"><br>在运行回收过后，c就变成了浮动垃圾。<br>由于CMS会产生浮动垃圾，当回收过后，浮动垃圾如果产生过多，同时因为使用标记-清除算法会产生碎片，可能会导致回收过后的连续空间仍然不能容纳新生代移动过来或者新创建的大资源，因此会导致CMS回收失败，进而触发另外一次FULL GC，而这时候则采用SerialOld进行二次回收。<br>同时CMS因为可能产生浮动垃圾，而CMS在执行回收的同时新生代也有可能在进行回收操作，为了保证旧生代能够存放新生代转移过来的数据，CMS在旧生代内存到达全部容量的68%就触发了CMS的回收！</p>\n<h4 id=\"h4-7-garbagefirst-g1-\"><a name=\"7.GarbageFirst(G1)\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>7.GarbageFirst(G1)</h4><p>我们再来看垃圾回收器的总图，刚才我们可以看到，我在图上标记了一个？，其实这是一个新的垃圾回收器，既可以回收新生代也可以回收旧生代，SunHotSpot 1.6u14以上EarlyAccess版本加入了这个回收器，sun公司预期SunHotSpot1.7发布正式版，他是商用高性能垃圾回收器，通过重新划分内存区域，整合优化CMS，同时注重吞吐量和响应时间，但是杯具的是被Oracle收购之后这个收集器属于商用收费收集器，因此目前基本上没有人使用，我们在这里也就不多介绍，更多信息可以参考oracle新版本JDK说明。</p>\n</div>','2017-04-09',1,19,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(62,'java汇编','java 汇编 http://download.csdn.net/download/jiangfuqiang/8403497','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><p>java 汇编<br><a href=\"http://download.csdn.net/download/jiangfuqiang/8403497\">http://download.csdn.net/download/jiangfuqiang/8403497</a></p>\n</div>','2017-04-10',1,16,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(63,'jvm','-XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><p>-XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly</p>\n</div>','2017-04-10',1,22,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(64,'Adaboost','NaiveBayesSpamFilter 利用朴素贝叶斯算法实现垃圾邮件的过滤，并结合Adaboost改进该算法。 1 Naive Bayes spam filtering   假设邮件的内容中包含的词汇为Wi，垃圾邮件Spam，正常邮件ham。 判断一份邮件，内容包含的词汇为Wi，判断该邮件是否是垃圾邮件，即计算P（S|Wi）这个条件概率。根据Bayes’ theorem：   Bayes’ t','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h1 id=\"h1-naivebayesspamfilter\"><a name=\"NaiveBayesSpamFilter\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>NaiveBayesSpamFilter</h1><p>利用朴素贝叶斯算法实现垃圾邮件的过滤，并结合Adaboost改进该算法。</p>\n<h3 id=\"h3-1-naive-bayes-spam-filtering\"><a name=\"1 Naive Bayes spam filtering\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1 Naive Bayes spam filtering</h3><p>  假设邮件的内容中包含的词汇为Wi，垃圾邮件Spam，正常邮件ham。 判断一份邮件，内容包含的词汇为Wi，判断该邮件是否是垃圾邮件，即计算P（S|Wi）这个条件概率。根据Bayes’ theorem：</p>\n<p>  Bayes’ theorem</p>\n<p>  其中：</p>\n<p>Pr(S|Wi) 出现词汇Wi的邮件是垃圾邮件的条件概率（即后验概率）；<br>Pr(S) 训练阶段邮件数据集中垃圾邮件的概率，或实际调查的垃圾邮件的概率（即先验概率）；<br>Pr(Wi|S) 垃圾邮件中词汇Wi出现的概率；<br>Pr(H) 训练阶段邮件数据集中正常邮件的概率，或实际调查的正常邮件的概率；<br>Pr(Wi|H) 正常邮件中词汇Wi出现的概率；<br>  对于邮件中出现的所有词汇，考虑每个词汇出现事件的独立性，计算Pr(S|Wi)的联合概率Pr(S|W)，W={W1，W2，…Wn}：</p>\n<p>  Bayes’ theorem</p>\n<p>  其中：</p>\n<p>P 即Pr(S|W)，出现词汇W={W1，W2……Wn}的邮件是垃圾邮件的条件概率；<br>Pi 即Pr(S|Wi)，出现词汇Wi的邮件是垃圾邮件的条件概率；<br>  注： 程序中，通过计算出Pr(S|W)和Pr(H|W)，比较Pr(S|W)和Pr(H|W)的大小，判断是垃圾邮件还是正常邮件。我们发现Pr(S|W)和Pr(H|W)计算的分母相同，所以我们只需要比较分子即可。</p>\n<p>  但存在两个问题：</p>\n<p>当词汇不存在时，即ni=0，此时Pr(S|Wi) = 0，会造成P=0，无法比较<br>当Pr(S|Wi)较小时，连乘操作会造成下溢出问题<br>  解决方案：</p>\n<p>计算P(Wi|S)和P(Wi|H)时，将所有词汇初始化出现的次数为1，并将分母初始化为2（或根据样本/实际调查结果调整分母的值）。</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"com\"># 统计语料库中词汇在S和H中出现的次数</span></code></li><li class=\"L1\"><code><span class=\"pln\">wordsInSpamNum </span><span class=\"pun\">=</span><span class=\"pln\"> np</span><span class=\"pun\">.</span><span class=\"pln\">ones</span><span class=\"pun\">(</span><span class=\"pln\">numWords</span><span class=\"pun\">)</span></code></li><li class=\"L2\"><code><span class=\"pln\">wordsInHealthNum </span><span class=\"pun\">=</span><span class=\"pln\"> np</span><span class=\"pun\">.</span><span class=\"pln\">ones</span><span class=\"pun\">(</span><span class=\"pln\">numWords</span><span class=\"pun\">)</span></code></li><li class=\"L3\"><code><span class=\"pln\">spamWordsNum </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">2.0</span></code></li><li class=\"L4\"><code><span class=\"pln\">healthWordsNum </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">2.0</span></code></li></ol></pre><p>计算P(Wi|S)和P(Wi|H)时，对概率取对数<br>    pWordsSpamicity = np.log(wordsInSpamNum / spamWordsNum)<br>    pWordsHealthy = np.log(wordsInHealthNum / healthWordsNum)<br>  所以最终比较的是，P(W1|S)P(W2|S)….P(Wn|S)P(S)和P(W1|H)P(W2|H)….P(Wn|H)P(H)的大小。</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"pln\">ps </span><span class=\"pun\">=</span><span class=\"pln\"> sum</span><span class=\"pun\">(</span><span class=\"pln\">testWordsMarkedArray </span><span class=\"pun\">*</span><span class=\"pln\"> pWordsSpamicity</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">+</span><span class=\"pln\"> np</span><span class=\"pun\">.</span><span class=\"pln\">log</span><span class=\"pun\">(</span><span class=\"pln\">pSpam</span><span class=\"pun\">)</span></code></li><li class=\"L1\"><code><span class=\"pln\">ph </span><span class=\"pun\">=</span><span class=\"pln\"> sum</span><span class=\"pun\">(</span><span class=\"pln\">testWordsMarkedArray </span><span class=\"pun\">*</span><span class=\"pln\"> pWordsHealthy</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">+</span><span class=\"pln\"> np</span><span class=\"pun\">.</span><span class=\"pln\">log</span><span class=\"pun\">(</span><span class=\"lit\">1</span><span class=\"pln\"> </span><span class=\"pun\">-</span><span class=\"pln\"> pSpam</span><span class=\"pun\">)</span></code></li></ol></pre><p>  测试效果： 5574个样本，采用交叉验证，随机选取4574个作为训练样本，产生词汇列表（语料库），对1000个测试样本，分类的平均错误率约为：2.5%。</p>\n<h3 id=\"h3-2-running-adaboost-on-naive-bayes\"><a name=\"2 Running Adaboost on Naive Bayes\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2 Running Adaboost on Naive Bayes</h3><p>  我们在计算ps和ph联合后验概率时，可引入一个调整因子DS，其作用是调整词汇表中某一词汇的“垃圾程度”(spamicity)，</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"pln\">ps </span><span class=\"pun\">=</span><span class=\"pln\"> sum</span><span class=\"pun\">(</span><span class=\"pln\">testWordsMarkedArray </span><span class=\"pun\">*</span><span class=\"pln\"> pWordsSpamicity </span><span class=\"pun\">*</span><span class=\"pln\"> DS</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">+</span><span class=\"pln\"> np</span><span class=\"pun\">.</span><span class=\"pln\">log</span><span class=\"pun\">(</span><span class=\"pln\">pSpam</span><span class=\"pun\">)</span></code></li></ol></pre><p>  其中DS通过Adaboost算法迭代获取最佳值。原理如下：</p>\n<p>设定adaboost循环的次数count<br>交叉验证随机选择1000个样本<br>DS初始化为和词汇列表大小相等的全一向量<br>迭代循环count次：<br>    设定最小分类错误率为inf<br>    对于每一个样本：<br>        在当前DS下对样本分类<br>        如果分类出错：<br>            计算出错的程度，即比较ps和ph的相差alpha<br>            如果样本原本是spam，错分成ham：<br>                DS[样本包含的词汇] = np.abs(DS[样本包含的词汇] - np.exp(alpha) / DS[样本包含的词汇])<br>            如果样本原本是ham，错分成spam：<br>                DS[样本包含的词汇] = DS[样本包含的词汇] + np.exp(alpha) / DS[样本包含的词汇]<br>    计算错误率<br>    保存最小的错误率和此时的词汇列表、P(Wi|S)和P(Wi|H)、DS等信息，即保存训练好的最佳模型的信息<br>  测试效果： 5574个样本，获取Adaboost算法训练的最佳模型信息（包括词汇列表、P(Wi|S)和P(Wi|H)、DS等），对1000个测试样本，分类的平均错误率约为：0.5%。</p>\n</div>','2017-04-17',4,22,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(65,'Java堆.栈和常量池 笔记','Java堆.栈和常量池 笔记','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><p><a href=\"http://www.iteye.com/topic/634530\">Java堆.栈和常量池 笔记</a></p>\n</div>','2017-04-23',1,23,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(66,'redis','redis的数据结构 数据结构类型 结构存储的值 结构的读写能力 STRING 可以是字符串、整数、或者浮点数 对整个字符串或者字符串的其中一部分执行操作；对整数和浮点数执行自增或者自减 LIST 一个链表，链表上的每个节点都包含了一个字符串 从链表的两端推入或者弹出元素；根据偏移量对链表进行修剪；根据值查找或者移除元素 SET 包含字符串的无序收集器，并且被包含的每个字符串都是独一无二、各不相同','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h1 id=\"h1-redis-\"><a name=\"redis的数据结构\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>redis的数据结构</h1><table>\n<thead>\n<tr>\n<th>数据结构类型</th>\n<th>结构存储的值</th>\n<th>结构的读写能力</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>STRING</td>\n<td>可以是字符串、整数、或者浮点数</td>\n<td>对整个字符串或者字符串的其中一部分执行操作；对整数和浮点数执行自增或者自减</td>\n</tr>\n<tr>\n<td>LIST</td>\n<td>一个链表，链表上的每个节点都包含了一个字符串</td>\n<td>从链表的两端推入或者弹出元素；根据偏移量对链表进行修剪；根据值查找或者移除元素</td>\n</tr>\n<tr>\n<td>SET</td>\n<td>包含字符串的无序收集器，并且被包含的每个字符串都是独一无二、各不相同的</td>\n<td>添加、获取、移除单个元素；检查一个元素是否存在于集合中；计算交集、并集、差集；从集合里面随机获取元素</td>\n</tr>\n<tr>\n<td>HASH</td>\n<td>包含键值对的无语散列表</td>\n<td>添加、获取、移除单个键值对；获取所有键值对</td>\n</tr>\n<tr>\n<td>ZSET(有序集合)</td>\n<td>字符串成员与浮点数分值之间的有序映射，元素的排列顺序由分值的大小决定</td>\n<td>添加、获取、单个元素；根据分值范围或者成员来获取元素</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"h3--string-\"><a name=\"一、STRING基本操作\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、STRING基本操作</h3><p>（1）SET 设置存储在给定键中的值<br>（2）GET 获取存储在给定键中的值<br>（3）DEL 删除存储在给定键中的值</p>\n<h3 id=\"h3--list-\"><a name=\"二、LIST（列表）基本操作\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、LIST（列表）基本操作</h3><p>（1）RPUSH 将给定值推入列表的右端<br>（2）LRANGE 获取列表在给定范围上的所有值<br>（3）LINDEX 获取列表在给定位置上的单个元素<br>（4）LPOP 从列表的左端弹出一个值，并返回被弹出的值</p>\n<h3 id=\"h3--set-\"><a name=\"三、SET（集合）基本操作\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>　三、SET（集合）基本操作</h3><p>（1）SADD 将给定元素添加到集合<br>（2）SMEMBERS 返回集合包含的所有元素<br>（3）SISMEMBER 检查给定元素是否存在于集合中<br>（4）SREM 如果给定的元素存在于集合中，那么移除这个元素</p>\n<h3 id=\"h3--hash-\"><a name=\"四、HASH（散列）基本操作\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>四、HASH（散列）基本操作</h3><p>（1）HSET 在散列里面关联起给定的键值对<br>（2）HGET 获取指定散列键的值<br>（3）HGETALL 获取散列包含的所有键值对<br>（4）HDEL 如果给定键存在于散列里面，那么移除这个键</p>\n<h3 id=\"h3--zset-\"><a name=\"五、ZSET（有序集合）基本操作\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>五、ZSET（有序集合）基本操作</h3><p>（1）ZADD 将一个带有给定分值的成员添加到有序集合里面<br>（2）ZRANGE 根据元素在有序排列中所处的位置，从有序集合里面获取多个元素<br>（3）ZRANGEBYSCORE 获取有序集合在给定分值范围的所有元素<br>（4）ZREM 如果给定成员存在于有序集合，那么移除这个成员</p>\n</div>','2017-05-04',6,18,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(77,'工厂模式','工厂模式 目录 何为工厂模式 工厂方法与抽象工厂 如何在Java EE中通过@Producers与@Inject注解实现工厂模式 如何创建自定义注解以及通过@Qualifier消除具体实现之间的歧义 工厂模式有两种模式：工厂方法和抽象方法。它们的意图是一样的：提供一个接口，在不指定具体类的情况下创建相关或依赖的一系列对象。 一.何为工厂模式 工厂的目的在于创建对象。创建的逻辑被封装在工厂中，要么提','<h1 id=\"h1-u5DE5u5382u6A21u5F0F\"><a name=\"工厂模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>工厂模式</h1><p>目录</p>\r\n<ul>\r\n<li>何为工厂模式</li><li>工厂方法与抽象工厂</li><li>如何在Java EE中通过<a href=\"https://github.com/Producers\" title=\"&#64;Producers\" class=\"at-link\">@Producers</a>与<a href=\"https://github.com/Inject\" title=\"&#64;Inject\" class=\"at-link\">@Inject</a>注解实现工厂模式</li><li>如何创建自定义注解以及通过<a href=\"https://github.com/Qualifier\" title=\"&#64;Qualifier\" class=\"at-link\">@Qualifier</a>消除具体实现之间的歧义<br>工厂模式有两种模式：工厂方法和抽象方法。它们的意图是一样的：提供一个接口，在不指定具体类的情况下创建相关或依赖的一系列对象。</li></ul>\r\n<h3 id=\"h3--\"><a name=\"一.何为工厂模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一.何为工厂模式</h3><p>工厂的目的在于创建对象。创建的逻辑被封装在工厂中，要么提供一个方法来返回新创建的对象（工厂方法模式），要么将对象的创建委托给子类（抽象工厂模式）。<br>客户端不必考虑接口或类的不同实现，它只需通过工厂（工厂）获取接口实现的一个实例的即可，这样客户端与对象的创建就实现了解耦<br>解耦是应用依赖反转原则的结果，这带来了很多好处，其中最重要的好处就是实现了高层类与底层类之间的解耦。通过解耦，具体类实现的变化不会影响到客户端，这降低了类与类之间的耦合，并提升了灵活性。</p>\r\n<h3 id=\"h3--\"><a name=\"二.工厂方法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二.工厂方法</h3><p>GoF一书是这样描述工程方法模式的：“定义一个用于创建对象的接口，不过让子类决定实例化那个类”<br>工厂极大降低了new关键字的使用次数，并且将初始化过程与不同的具体实现封装起来。将这些需求中心化可以极大减少向系统中添加或删除具体类的影响以及具体的类依赖的影响。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src=\"http://ohlrxdl4p.bkt.clouddn.com/images/QQ截图20170506134421.jpg\" alt=\"\"><br><strong>1.使用普通代码实现工厂方法</strong><br>被具体实现继承的DrinksMachine抽象类</p>\r\n<pre><code class=\"lang-java\">public abstract class DrinksMachine {\r\n    public abstract Drink dispenseDrink();\r\n    public String displayMessage(){\r\n        return &quot;Thank for your custom.&quot;;\r\n    }\r\n}\r\n</code></pre>\r\n<p>DrinksMachine抽象类的CoffeeMachine实现</p>\r\n<pre><code class=\"lang-java\">public class CoffeeMachine extends DrinksMachine {\r\n    public Drink dispenseDrink() {\r\n        return new Coffee();\r\n    }\r\n}\r\n</code></pre>\r\n<p>DrinksMachine抽象类的SoftDrinksMachine实现</p>\r\n<pre><code class=\"lang-java\">public class SoftDrinksMachine extends DrinksMachine {\r\n    public Drink dispenseDrink() {\r\n        return new SoftDrink();\r\n    }\r\n}\r\n</code></pre>\r\n<p>Drink接口</p>\r\n<pre><code class=\"lang-java\">public interface Drink {}\r\n</code></pre>\r\n<p>Drink接口的SoftDrink实现</p>\r\n<pre><code class=\"lang-java\">public class SoftDrink implements Drink {\r\n    SoftDrink() {\r\n        System.out.println(&quot;Soft drink&quot;);\r\n    }\r\n}\r\n</code></pre>\r\n<p>Drink接口的Coffee实现</p>\r\n<pre><code class=\"lang-java\">public class Coffee implements Drink {\r\n    Coffee() {\r\n        System.out.println(&quot;Coffee&quot;);\r\n    }\r\n}\r\n</code></pre>\r\n<p>CoffeeType枚举<br>```java<br>public enum CoffeeType {EXPRESSO, LATTE}</p>\r\n<p>public Drink dispenseDrink(CoffeeType type) {<br>    Drink coffee = null;<br>    switch (type) {<br>        case EXPRESSO: coffee = new Expresso();<br>        case LATTE: coffee = new Latte();<br>    }<br>    return coffee;<br>}<br>```&lt;!--前面不能有空格--&gt;</p>','2017-05-06',1,11,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(79,'代理模式','代理模式(Proxy Pattern) GoF中给出的代理模式的定义为： 代理模式给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。 代理模式的英文叫做Proxy或Surrogate，它是一种对象结构型模式。 代理模式根据其目的和实现可分为很多种类，常用的代理模式包括如下几种： （1）远程代理（Remote Proxy）————为一个位于不同的地址空间的对象提供一个本地的代理对象','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h1 id=\"h1--proxy-pattern-\"><a name=\"代理模式(Proxy Pattern)\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代理模式(Proxy Pattern)</h1><p>GoF中给出的代理模式的定义为：<br>代理模式给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。<br>代理模式的英文叫做Proxy或Surrogate，它是一种对象结构型模式。<br>代理模式根据其目的和实现可分为很多种类，常用的代理模式包括如下几种：<br>（1）远程代理（Remote Proxy）————为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以是在同一台主机中，也可以是在另一台主机中，远程代理又称为大使（Ambassador）<br>（2）虚拟代理（Virtual Proxy）————如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。<br>（3）保护代理（Protect Proxy）————控制一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。<br>（4）缓冲代理（Cache Proxy）————为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。<br>（5）只能引用代理（Smart Reference Proxy）————当一个对象被引用时，提供一些额外的操作，例如将对象被调用的次数记录下来。<br><img src=\"http://ohlrxdl4p.bkt.clouddn.com/images/QQ截图20170507103646.jpg\" alt=\"\"></p>\n<p>代码实现：<br>1.抽象主题类——BuyTicket.java</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code class=\"lang-java\"><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">interface</span><span class=\"pln\"> </span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> showticket</span><span class=\"pun\">();</span></code></li><li class=\"L2\"><code class=\"lang-java\"><span class=\"pun\">}</span></code></li></ol></pre>\n<p>2.具体主题类——Train.java</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code class=\"lang-java\"><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Train</span><span class=\"pln\"> </span><span class=\"kwd\">implements</span><span class=\"pln\"> </span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"lit\">@Override</span></code></li><li class=\"L2\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> showticket</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L3\"><code class=\"lang-java\"><span class=\"pln\">        </span><span class=\"typ\">System</span><span class=\"pun\">.</span><span class=\"pln\">out</span><span class=\"pun\">.</span><span class=\"pln\">println</span><span class=\"pun\">(</span><span class=\"str\">\"one ticket\"</span><span class=\"pun\">);</span></code></li><li class=\"L4\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L5\"><code class=\"lang-java\"><span class=\"pun\">}</span></code></li></ol></pre>\n<p>3.代理角色类——TicketCenter.java</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code class=\"lang-java\"><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">TicketCenter</span><span class=\"pln\"> </span><span class=\"kwd\">implements</span><span class=\"pln\"> </span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> ticket</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code class=\"lang-java\"></code></li><li class=\"L3\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"typ\">TicketCenter</span><span class=\"pun\">(</span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> ticket</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code class=\"lang-java\"><span class=\"pln\">        </span><span class=\"kwd\">this</span><span class=\"pun\">.</span><span class=\"pln\">ticket </span><span class=\"pun\">=</span><span class=\"pln\"> ticket</span><span class=\"pun\">;</span></code></li><li class=\"L5\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code class=\"lang-java\"></code></li><li class=\"L7\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"lit\">@Override</span></code></li><li class=\"L8\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> showticket</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L9\"><code class=\"lang-java\"><span class=\"pln\">        ticket</span><span class=\"pun\">.</span><span class=\"pln\">showticket</span><span class=\"pun\">();</span></code></li><li class=\"L0\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code class=\"lang-java\"></code></li><li class=\"L2\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> buy</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L3\"><code class=\"lang-java\"><span class=\"pln\">        </span><span class=\"typ\">System</span><span class=\"pun\">.</span><span class=\"pln\">out</span><span class=\"pun\">.</span><span class=\"pln\">println</span><span class=\"pun\">(</span><span class=\"str\">\"by proxy\"</span><span class=\"pun\">);</span></code></li><li class=\"L4\"><code class=\"lang-java\"><span class=\"pln\">        showticket</span><span class=\"pun\">();</span></code></li><li class=\"L5\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code class=\"lang-java\"><span class=\"pun\">}</span></code></li></ol></pre>\n<p>4.客户端测试类</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code class=\"lang-java\"><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">ProxyPattern</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> main</span><span class=\"pun\">(</span><span class=\"typ\">String</span><span class=\"pln\"> args</span><span class=\"pun\">[])</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L2\"><code class=\"lang-java\"><span class=\"pln\">        </span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> x </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Train</span><span class=\"pun\">();</span></code></li><li class=\"L3\"><code class=\"lang-java\"><span class=\"pln\">        </span><span class=\"typ\">TicketCenter</span><span class=\"pln\"> y </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">TicketCenter</span><span class=\"pun\">(</span><span class=\"pln\">x</span><span class=\"pun\">);</span></code></li><li class=\"L4\"><code class=\"lang-java\"><span class=\"pln\">        y</span><span class=\"pun\">.</span><span class=\"pln\">buy</span><span class=\"pun\">();</span></code></li><li class=\"L5\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code class=\"lang-java\"><span class=\"pun\">}</span></code></li></ol></pre>\n<p>运行结果：</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code class=\"lang-html\"><span class=\"pln\">by proxy</span></code></li><li class=\"L1\"><code class=\"lang-html\"><span class=\"pln\">one ticket</span></code></li></ol></pre>\n</div>','2017-05-07',1,21,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(80,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,26,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(81,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,19,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(82,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,17,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(83,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,19,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(84,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,19,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(85,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,21,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(86,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,20,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(87,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,20,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(88,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,17,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(89,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,18,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(90,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,19,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(91,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,20,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(92,'BSbsbsbs','heloo 哦i已被肉','<h1 id=\"h1-heloo-i-\"><a name=\"heloo 哦i已被肉\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>heloo 哦i已被肉</h1>','2017-01-23',3,22,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(93,'2017-02-28学习笔记','','<p><img src=\"http://ohlrxdl4p.bkt.clouddn.com/images/826546_1482322555369_C5DABB18734059E89A45A0E9170722B0.png\" alt=\"\"></p>','2017-02-28',1,26,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(94,'2017-03-01学习笔记','知识点 1.java中只有值传递，没有引用传递http://guhanjie.iteye.com/blog/1683637 2.final关键字 final修饰变量，则等同于常量. final修饰方法中的参数，称为最终参数. final修饰类，则类不能被继承. final修饰方法，则方法不能被','<h1 id=\"h1-u77E5u8BC6u70B9\"><a name=\"知识点\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>知识点</h1><h4 id=\"h4-1-java-http-guhanjie-iteye-com-blog-1683637\"><a name=\"1.java中只有值传递，没有引用传递  http://guhanjie.iteye.com/blog/1683637\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.java中只有值传递，没有引用传递<a href=\"http://guhanjie.iteye.com/blog/1683637\">http://guhanjie.iteye.com/blog/1683637</a></h4><h4 id=\"h4-2-final-\"><a name=\"2.final关键字\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.final关键字</h4><ul>\r\n<li>final修饰变量，则等同于常量.</li><li>final修饰方法中的参数，称为最终参数.</li><li>final修饰类，则类不能被继承.</li><li>final修饰方法，则方法不能被重写.</li></ul>\r\n<h4 id=\"h4-3-integer-img-src-https-uploadfiles-nowcoder-com-images-20160717-6316247_1468761643205_9f7b85ab04292cf73778d98998a20ed1-alt-\"><a name=\"3.Integer<img src=\"https://uploadfiles.nowcoder.com/images/20160717/6316247_1468761643205_9F7B85AB04292CF73778D98998A20ED1\" alt=\"图片\">\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.Integer<img src=\"https://uploadfiles.nowcoder.com/images/20160717/6316247_1468761643205_9F7B85AB04292CF73778D98998A20ED1\" alt=\"图片\"></h4><h4 id=\"h4-4-java-\"><a name=\"4.java内存模型   点击原文\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.java内存模型 <a href=\"http://blog.csdn.net/ns_code/article/details/17565503\">点击原文</a></h4><p><img src=\"https://uploadfiles.nowcoder.com/images/20161223/415611_1482452184396_6FB53C51539B47559CF0D122A832CF63\" alt=\"\"></p>\r\n<h4 id=\"h4-5-java-reference\"><a name=\"5.java中是没有指针的，有reference\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.java中是没有指针的，有reference</h4><p>第一：指针变量是在栈内存中，它也是有值的，这个值存储的就是地址单元，这个地址就是来自于赋值操作。<br>第二：指针变量有类型，这个类型（如Person）的含义是指针指向的变量在栈内存（不是很确定）中的范围（大小），我理解为是占用的堆内存空间。<br>第三：声明一个对象时，是对“指针变量”的定义。<br>第四：用new关键字在堆内存创建了对象，在赋值时，是把这个对象的首地址传给了这个“指针变量”（即引用型变量）。</p>\r\n<h4 id=\"h4-6-string-\"><a name=\"6.String生成常量\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6.String生成常量</h4><pre><code class=\"lang-java\">String s1=&quot;abc&quot;+&quot;def&quot;;//生成的是一个常量，放在堆内存中\r\nString s2=new String（s1);//s2是一个变量\r\nif(s1.equals(s2))//比较的是字符串的内容\r\n    System.out.println(&quot;.equals succeeded&quot;);//输出\r\nif(s1==s2)//比较的是内存地址，但s1是常量，所以不相等\r\n    System.out.println(&quot;==succeeded&quot;);\r\n</code></pre>\r\n<h4 id=\"h4-7-jsp-\"><a name=\"7.jsp内置对象和属性\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>7.jsp内置对象和属性</h4><p>（１）request对象<br>客户端的请求信息被封装在request对象中，通过它才能了解到客户的需求，然后做出响应。它是HttpServletRequest类的实例。<br>（２）response对象<br>response对象包含了响应客户请求的有关信息，但在JSP中很少直接用到它。它是HttpServletResponse类的实例。<br>（３）session对象<br>session对象指的是客户端与服务器的一次会话，从客户连到服务器的一个WebApplication开始，直到客户端与服务器断开连接为止。它是HttpSession类的实例.<br>（４）out对象<br>out对象是JspWriter类的实例,是向客户端输出内容常用的对象<br>（５）page对象<br>page对象就是指向当前JSP页面本身，有点象类中的this指针，它是java.lang.Object类的实例<br>（６）application对象<br>application对象实现了用户间数据的共享，可存放全局变量。它开始于服务器的启动，直到服务器的关闭，在此期间，此对象将一直存在；这样在用户的前后连接或不同用户之间的连接中，可以对此对象的同一属性进行操作；在任何地方对此对象属性的操作，都将影响到其他用户对此的访问。服务器的启动和关闭决定了application对象的生命。它是ServletContext类的实例。<br>（７）exception对象<br>exception对象是一个例外对象，当一个页面在运行过程中发生了例外，就产生这个对象。如果一个JSP页面要应用此对象，就必须把isErrorPage设为true，否则无法编译。他实际上是java.lang.Throwable的对象<br>（８）pageContext对象<br>pageContext对象提供了对JSP页面内所有的对象及名字空间的访问，也就是说他可以访问到本页所在的SESSION，也可以取本页面所在的application的某一属性值，他相当于页面中所有功能的集大成者，它的本 类名也叫pageContext。<br>（９）config对象<br>config对象是在一个Servlet初始化时，JSP引擎向它传递信息用的，此信息包括Servlet初始化时所要用到的参数（通过属性名和属性值构成）以及服务器的有关信息（通过传递一个ServletContext对象）</p>','2017-03-01',1,29,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(95,'2017-03-02学习笔记','知识点 一、static public class Spike\r\n{\r\n    public static void main(String[] args)\r\n    {\r\n        Counter a = new Counter();\r\n        System.out.println(a.increment());\r\n        System.out.println(a.anot','<h1 id=\"h1-u77E5u8BC6u70B9\"><a name=\"知识点\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>知识点</h1><h4 id=\"h4--static\"><a name=\"一、static\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、static</h4><pre><code class=\"lang-java\">public class Spike\r\n{\r\n    public static void main(String[] args)\r\n    {\r\n        Counter a = new Counter();\r\n        System.out.println(a.increment());\r\n        System.out.println(a.anotherIncrement());\r\n        Counter b = new Counter();\r\n        System.out.println(b.increment());\r\n    }\r\n}\r\nclass Counter\r\n{\r\n    private static int count = 0;\r\n    public int increment()\r\n    {\r\n        return count++;\r\n    }\r\n    public int anotherIncrement()\r\n    {\r\n        return ++count;\r\n    }\r\n}\r\n</code></pre>\r\n<p>count是静态变量，为所有对象所共享，因此不管a.increment()还是b.increment()都会使count持续增加。<br>increment()方法返回当前count值，然后count增加1<br>antoherIncrement()方法让count增加1，然后返回count值<br>第一次a.increment()返回值为0，此时count值为1<br>第二次a.anotherIncrement()先让count+1再返回，返回值为2<br>第三次b.increment()先返回count当前值2，然后count+1</p>\r\n<h4 id=\"h4--aop-\"><a name=\"二、AOP面向切面\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、AOP面向切面</h4><p>AOP的概念是Aspected Oriented Programming 面向方面编程。<br>  好处：AOP将程序分解成各个方面或者说关注点。这使得可以模块化，相当横向上分切了。它可以解决OOP和过程化方法不能够很好解决的横切（crosscut）问题，如：事务、安全、日志等横切关注。<br>  实现AOP有几种方式:<br>  1.Spring 1.2版本中通过ProxyFactoryBean来实现aop,即通过动态代理来实现的,Aspect必须继承MethodBeforeAdvice,MethodAfterAdvice等<br>  2.Spring 2.0 AOP需要改的是FBI 这个类，而且它也不需要再实现某些接口<br>  3.三使用标注（<a href=\"https://github.com/AspectJ\" title=\"&#64;AspectJ\" class=\"at-link\">@AspectJ</a>）实现AOP<br>    AOP 和 OOP的区别：</p>\r\n<pre><code>```html\r\n 1. 面向方面编程 AOP 偏重业务处理过程的某个步骤或阶段，强调降低模块之间的耦合度，使代码拥有更好的移植性。  \r\n 2. 面向对象编程 (oop) 则是对业务分析中抽取的实体进行方法和属性的封装。\r\n ```\r\n</code></pre><p>也可以说 AOP 是面向业务中的动词领域， OOP 面向名词领域。<br>AOP 的一个很重要的特点是源代码无关性，也就是说如果我们的系统中引用了 AOP 组件，即使我们把该组件去掉，系统代码也应该能够编译通过。要实现这一点，可以使用动态 proxy 模式。</p>\r\n<h4 id=\"h4--jdbc-\"><a name=\"三、jdbc桥接模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、jdbc桥接模式</h4><p>桥接模式：<br>定义 ：将抽象部分与它的实现部分分离，使它们都可以独立地变化。<br>意图 ：将抽象与实现解耦。<br>桥接模式所涉及的角色</p>\r\n<ol>\r\n<li>Abstraction ：定义抽象接口，拥有一个Implementor类型的对象引用</li><li>RefinedAbstraction ：扩展Abstraction中的接口定义</li><li>Implementor ：是具体实现的接口，Implementor和RefinedAbstraction接口并不一定完全一致，实际上这两个接口可以完全不一样Implementor提供具体操作方法，而Abstraction提供更高层次的调用</li><li>ConcreteImplementor ：实现Implementor接口，给出具体实现<br>Jdk中的桥接模式：JDBC<br>JDBC连接 数据库 的时候，在各个数据库之间进行切换，基本不需要动太多的代码，甚至丝毫不动，原因就是JDBC提供了统一接口，每个数据库提供各自的实现，用一个叫做数据库驱动的程序来桥接就行了<h4 id=\"h4--\"><a name=\"四、抽象类\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>四、抽象类</h4>抽象类和普通类有三点区别：<br>1）抽象方法必须为public和protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public。<br>2）抽象类不能用来创建对象，但是它可以有构造方法，用来帮助子类实例化。<br>3）如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为abstract类。<h4 id=\"h4--\"><a name=\"五、接口\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>五、接口</h4>接口的主要特点<br>1）接口中的成员变量默认都是public、static、final类型的，必须被显示初始化。<br>2）接口中的方法默认都是public、abstract类型的。<br>3）接口中只能包含public、static、final类型的成员变量和public、abstract类型的成员方法。<br>4）接口没有构造方法，不能被实例化。<br>5）一个接口不能实现另一个接口，但它可以继承多个其他接口。<br>6）接口必须通过类来实现它的抽象方法。<br>7）与子类继承抽象父类相似，当类实现了某个接口时，它必须实现接口中所有的抽象方法，否则这个类必须被定义为抽象类。<br>8）一个类只能继承一个直接的父类，但能实现多个接口。<h4 id=\"h4--\"><a name=\"六、抽象类和接口的区别\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>六、抽象类和接口的区别</h4>1）抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract方法；<br>2）抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；<br>3）接口中不能含有静态代码块以及静态方法，而抽象类尅有静态代码块和静态方法；<br>4）一个类只能继承一个抽象类，而一个类却可以实现多个接口。<br>5）抽象类中的方法子类必须全部实现，不然子类也是抽象类，而接口中的抽象方法子类必须全部实现，是可选择实现的。<br>6）抽象类是一种模板设计模式，而接口时一种行为规范。</li></ol>','2017-03-02',1,31,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(96,'2017-03-03学习笔记','一、String StringBuffer.toString()源码： @Override\r\npublic synchronized String toString() {\r\n    if (toStringCache == null) {\r\n        toStringCache = Arrays.copyOfRange(value, 0, count);\r\n    }\r\n    retur','<h4 id=\"h4--string\"><a name=\"一、String\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、String</h4><p>StringBuffer.toString()源码：</p>\r\n<pre><code class=\"lang-java\">@Override\r\npublic synchronized String toString() {\r\n    if (toStringCache == null) {\r\n        toStringCache = Arrays.copyOfRange(value, 0, count);\r\n    }\r\n    return new String(toStringCache, true);\r\n}\r\n</code></pre>\r\n<p>Arrays.copyOfRange用的是System.arraycopy</p>\r\n<pre><code class=\"lang-java\">public static char[] copyOfRange(char[] original, int from, int to) {\r\n        int newLength = to - from;\r\n        if (newLength &lt; 0)\r\n            throw new IllegalArgumentException(from + &quot; &gt; &quot; + to);\r\n        char[] copy = new char[newLength];\r\n        System.arraycopy(original, from, copy, 0,\r\n                         Math.min(original.length - from, newLength));\r\n        return copy;\r\n    }\r\n</code></pre>\r\n<p>1.String是值传入，不是引用传入。<br>2.String对String  类型进行改变的时候其实都等同于生成了一个新的  String  对象，然后将指针指向新的  String  对象，而不是StringBuffer；StringBuffer每次结果都会对  StringBuffer  对象本身进行操作，而不是生成新的对象，再改变对象引用。<br>3.效率比较String&lt;StringBuffer&lt;StringBuilder，但是在 String S1 = “This is only a” + “ simple” + “ test”时，String效率最高。</p>\r\n<h4 id=\"h4--jvm-\"><a name=\"二、jvm知识图谱\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、jvm知识图谱</h4><p><a href=\"https://zhuanlan.zhihu.com/p/25511795\">引用自知乎</a><br><img src=\"https://pic2.zhimg.com/v2-701563ac1fe745fc8e1234c96e82ac99_r.jpg\" alt=\"\"></p>\r\n<h4 id=\"h4--treemap-linkhashmap\"><a name=\"三、Treemap、LinkHashMap\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、Treemap、LinkHashMap</h4><p>1.TreeMap取出来的是排序后的键值对。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。<br>2.LinkedHashMap 是HashMap的一个子类，如果需要输出的顺序和输入的相同,那么用LinkedHashMap可以实现,它还可以按读取顺序来排列。</p>\r\n<h4 id=\"h4--sql-\"><a name=\"四、sql模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>四、sql模式</h4><p>MySQL数据库中，变量分为 系统变量（以”@@”开头）和用户自定义变量。系统变量分为全局系统变量(global)和会话系统变量(session)。<br>@<a href=\"https://github.com/global\" title=\"&#64;global\" class=\"at-link\">@global</a>     仅用于访问全局系统变量的值；<br>@<a href=\"https://github.com/session\" title=\"&#64;session\" class=\"at-link\">@session</a>  仅用于访问会话系统变量的值；<br>@@              先访问会话系统变量的值，若不存在则去访问全局系统变量的值；<br>sql_mode 为系统变量，既是全局系统变量，又是会话系统变量。</p>\r\n<h4 id=\"h4--\"><a name=\"五、代码的执行顺序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>五、代码的执行顺序</h4><p>父类Ｂ静态代码块-&gt;子类Ａ静态代码块-&gt;父类Ｂ非静态代码块-&gt;父类Ｂ构造函数-&gt;子类Ａ非静态代码块-&gt;子类Ａ构造函数<br><img src=\"http://ohlrxdl4p.bkt.clouddn.com/images/QQ截图20170303165728.jpg\" alt=\"\"></p>','2017-03-03',1,32,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(97,'ifhifhajfe','hello','<h1 id=\"h1-hello\"><a name=\"hello\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>hello</h1>','2017-03-05',1,32,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(98,'2017-03-05学习笔记','java的堆，栈，静态代码区（常量区） 详解','<p><a href=\"http://blog.csdn.net/u012031380/article/details/54981472\"> java的堆，栈，静态代码区（常量区） 详解</a></p>','2017-03-05',1,33,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(99,'java归并排序','package datastruct;\r\n\r\n/**\r\n * Created by Zephery on 2017/3/3.\r\n */\r\npublic class Solution {\r\n    public static void printArray(int[] arr, int i, int j) {\r\n        System.out.print(\"[\");\r\n        for','<pre><code class=\"lang-java\">package datastruct;\r\n\r\n/**\r\n * Created by Zephery on 2017/3/3.\r\n */\r\npublic class Solution {\r\n    public static void printArray(int[] arr, int i, int j) {\r\n        System.out.print(&quot;[&quot;);\r\n        for (int k = i; k &lt; j; k++) {\r\n            System.out.print(arr[k] + &quot;,&quot;);\r\n        }\r\n        System.out.print(arr[j] + &quot;]&quot;);\r\n    }\r\n\r\n    private static void mergesort(int[] arr, int i, int j) {\r\n        int mid = 0;\r\n        if (i &lt; j) {\r\n            mid = (i + j) / 2;\r\n            mergesort(arr, i, mid);\r\n            mergesort(arr, mid + 1, j);\r\n            merge(arr, i, mid, j);\r\n        }\r\n    }\r\n\r\n    private static void merge(int[] arr, int i, int mid, int j) {\r\n        System.out.print(&quot;Left:&quot;);\r\n        printArray(arr, i, mid);\r\n        System.out.println(&quot;Right:&quot;);\r\n        printArray(arr, mid + 1, j);\r\n        System.out.println();\r\n        int temp[] = new int[arr.length];\r\n        int l = i;\r\n        int r = j;\r\n        int m = mid + 1;\r\n        int k = l;\r\n        while (l &lt;= mid &amp;&amp; m &lt;= r) {\r\n            if (arr[l] &lt;= arr[m]) {\r\n                temp[k++] = arr[l++];\r\n            } else {\r\n                temp[k++] = arr[m++];\r\n            }\r\n        }\r\n        while (l &lt;= mid) {\r\n            temp[k++] = arr[l++];\r\n        }\r\n        while (m &lt;= r) {\r\n            temp[k++] = arr[m++];\r\n        }\r\n        for (int i1 = i; i1 &lt;= j; i1++) {\r\n            arr[i1] = temp[i1];\r\n        }\r\n        System.out.print(&quot;After Merge:&quot;);\r\n        printArray(arr, i, j);\r\n        System.out.println();\r\n    }\r\n\r\n    public static void main(String args[]) {\r\n        int[] arr = {9, 4, 8, 3, 1, 2, 5};\r\n        System.out.print(&quot;Initial Array:&quot;);\r\n        printArray(arr, 0, arr.length - 1);\r\n        System.out.println();\r\n        mergesort(arr, 0, arr.length - 1);\r\n    }\r\n}\r\n</code></pre>\r\n<pre><code class=\"lang-js\">Initial Array:[9,4,8,3,1,2,5]\r\nLeft:[9]Right:\r\n[4]\r\nAfter Merge:[4,9]\r\nLeft:[8]Right:\r\n[3]\r\nAfter Merge:[3,8]\r\nLeft:[4,9]Right:\r\n[3,8]\r\nAfter Merge:[3,4,8,9]\r\nLeft:[1]Right:\r\n[2]\r\nAfter Merge:[1,2]\r\nLeft:[1,2]Right:\r\n[5]\r\nAfter Merge:[1,2,5]\r\nLeft:[3,4,8,9]Right:\r\n[1,2,5]\r\nAfter Merge:[1,2,3,4,5,8,9]\r\n</code></pre>','2017-03-06',1,35,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(100,'2017-03-10学习笔记','1.Integer和int，装箱拆箱 1、基本型和基本型封装型进行“==”运算符的比较，基本型封装型将会自动拆箱变为基本型后再进行比较，因此Integer(0)会自动拆箱为int类型再进行比较，显然返回true； 2、两个Integer类型进行“==”比较，如果其值在-128至127，那么返回true，否则返回false, 这跟Integer.valueOf()的缓冲对象有关，这里不进行赘述。 3','<h1 id=\"h1-1-integer-int-\"><a name=\"1.Integer和int，装箱拆箱\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.Integer和int，装箱拆箱</h1><p>1、基本型和基本型封装型进行“==”运算符的比较，基本型封装型将会自动拆箱变为基本型后再进行比较，因此Integer(0)会自动拆箱为int类型再进行比较，显然返回true；<br>2、两个Integer类型进行“==”比较，如果其值在-128至127，那么返回true，否则返回false, 这跟Integer.valueOf()的缓冲对象有关，这里不进行赘述。<br>3、两个基本型的封装型进行equals()比较，首先equals()会比较类型，如果类型相同，则继续比较值，如果值也相同，返回true<br>4、基本型封装类型调用equals(),但是参数是基本类型，这时候，先会进行自动装箱，基本型转换为其封装类型，再进行3中的比较。</p>\r\n<pre><code class=\"lang-java\">int a=257;\r\nInteger b=257;\r\nInteger c=257;\r\nInteger b2=57;\r\nInteger c2=57;\r\nSystem.out.println(a==b);\r\n//System.out.println(a.equals(b));  编译出错，基本型不能调用equals()\r\nSystem.out.println(b.equals(257.0));\r\nSystem.out.println(b==c);\r\nSystem.out.println(b2==c2);\r\n</code></pre>\r\n<p>因此上面的代码的结果因此为 true, false, false, true</p>\r\n<h1 id=\"h1-2-\"><a name=\"2.线程调度\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.线程调度</h1><p>分为协同式调度和抢占式调度，Java使用的是抢占式调度，也就是每个线程将由操作系统来分配执行时间，线程的切换不由线程本身来决定（协同式调度）。这就是平台独立的原因。</p>\r\n<h1 id=\"h1-3-\"><a name=\"3.重载，重写\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.重载，重写</h1><p>重写：<br>两同，两小，一大<br>两同：方法名，方法参数列表相同。<br>两小：抛出的异常类型要小于等于父类，返回值类型要小于等于父类<br>一大：访问权限大于等于父类。<br>重载：<br>在同一个类中，方法名和方法参数列表不同，其他的（访问权限、返回值）随意。</p>\r\n<h1 id=\"h1-4-jvm-\"><a name=\"4.  JVM面试题\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.<a href=\"http://blog.csdn.net/hsk256/article/details/49104955\">JVM面试题</a></h1>','2017-03-10',1,31,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(101,'2017-03-12学习笔记','1.继承的加载顺序 执行顺序大体上可以说是先父类后子类，父类static域 ==》子类static域 ==》父类数据成员域 ==》父类构造器 ==》子类数据成员域 ==》子类构造器 2.优化Hibernate所鼓励的7大措施： 1.尽量使用many-to-one，避免使用单项one-to-many 2.灵活使用单向one-to-many 3.不用一对一，使用多对一代替一对一 4.配置对象缓存，不使','<h4 id=\"h4-1-\"><a name=\"1.  继承的加载顺序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.<a href=\"http://www.cnblogs.com/SirSmith/p/5536288.html\">继承的加载顺序</a></h4><p><img src=\"http://images2015.cnblogs.com/blog/452847/201605/452847-20160527221410288-2119099273.png\" alt=\"\"></p>\r\n<p>执行顺序大体上可以说是先父类后子类，父类static域 ==》子类static域 ==》父类数据成员域 ==》父类构造器 ==》子类数据成员域 ==》子类构造器</p>\r\n<h4 id=\"h4-2-hibernate-7-\"><a name=\"2.优化Hibernate所鼓励的7大措施：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.优化Hibernate所鼓励的7大措施：</h4><p>1.尽量使用many-to-one，避免使用单项one-to-many<br>2.灵活使用单向one-to-many<br>3.不用一对一，使用多对一代替一对一<br>4.配置对象缓存，不使用集合缓存<br>5.一对多使用Bag 多对一使用Set<br>6.继承使用显示多态 HQL:from object polymorphism=”exlicit” 避免查处所有对象<br>7.消除大表，使用二级缓存</p>\r\n<h4 id=\"h4-3-java-\"><a name=\"3.java中的数据类型分类：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.java中的数据类型分类：</h4><p>基本数据类型（或叫做原生类、内置类型）8种：<br>    整数：byte，short，int，long（默认是int类型）<br>    浮点类型： float，double（默认是double类型）<br>    字符类型：char<br>    布尔类型：boolean<br>引用数据类型3种：数组，类，接口</p>\r\n<h4 id=\"h4-4-\"><a name=\"4.触发器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.触发器</h4><p>drop trigger 删除触发器<br>Drop用于删除数据表或数据库，或删除数据表字段。<br>remove：删除数据库文件<br>Truncate：删除数据表中的数据（仅数据表中的数据，不删除表）。</p>','2017-03-12',1,27,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(102,'2017-03-14学习笔记','1.Servlet的生命周期分为5个阶段：加载、创建、初始化、处理客户请求、卸载。 (1)加载：容器通过类加载器使用servlet类对应的文件加载servlet (2)创建：通过调用servlet构造函数创建一个servlet对象 (3)初始化：调用init方法初始化 (4)处理客户请求：每当有一个客户请求，容器会创建一个线程来处理客户请求 (5)卸载：调用destroy方法让servlet自己释','<h4 id=\"h4-1-servlet-5-\"><a name=\"1.Servlet的生命周期分为5个阶段：加载、创建、初始化、处理客户请求、卸载。\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.Servlet的生命周期分为5个阶段：加载、创建、初始化、处理客户请求、卸载。</h4><p>(1)加载：容器通过类加载器使用servlet类对应的文件加载servlet<br>(2)创建：通过调用servlet构造函数创建一个servlet对象<br>(3)初始化：调用init方法初始化<br>(4)处理客户请求：每当有一个客户请求，容器会创建一个线程来处理客户请求<br>(5)卸载：调用destroy方法让servlet自己释放其占用的资源</p>\r\n<h4 id=\"h4-2-jsp\"><a name=\"2.JSP\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.JSP</h4><p><img src=\"http://uploadfiles.nowcoder.com/images/20160308/595432_1457414324036_C3D4EB7F2D61708D0C0BE2921A45B74D\" alt=\"\"></p>','2017-03-14',1,23,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(103,'2017-03-17学习笔记','1.GC线程是否和守护线程 2.java堆排序','<h4 id=\"h4-1-gc-\"><a name=\"1.GC线程是否和守护线程\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.GC线程是否和守护线程</h4><h4 id=\"h4-2-java-\"><a name=\"2.java堆排序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.java堆排序</h4>','2017-03-17',1,21,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(104,'春招~好失落啊','自己的情况：广东人，大学跑到天津一所二本学校，网络工程专业，大一大二学ccna、ccnp，发现没有创造性，按着别人的死规定敲命令好无聊，大三彻底转向编程，c++看着不爽，调研一番后选择java，自学java和java web，对jsp、servlet略过，直接上手框架（Struts，hibernate，spring），看书，找视频，敲项目，非专业课（操作系统，数据库等）不听，捣鼓一番觉得还行，继续','<p>自己的情况：广东人，大学跑到天津一所二本学校，网络工程专业，大一大二学ccna、ccnp，发现没有创造性，按着别人的死规定敲命令好无聊，大三彻底转向编程，c++看着不爽，调研一番后选择java，自学java和java web，对jsp、servlet略过，直接上手框架（Struts，hibernate，spring），看书，找视频，敲项目，非专业课（操作系统，数据库等）不听，捣鼓一番觉得还行，继续学习spring mvc，mybatis，开始了解hadoop、spark，同时搭了自己的网站，跟了软件工程的同学比了比，还能算上前列吧，当然，基础和算法跟前列的人还没得比~~~</p>\r\n<p>去年秋招，腾讯、阿里等笔试全挂，京东的没怎么做却过了，不敢去面试（真心没怎么做题），最后去了北京一家创业公司实习了三个月多，感觉真心好，12月几乎整整一个月雾霾，受不了，还是回广东吧。在家过了春节，2月10号跟同学一起来深圳，就这样，开始了春招之旅~~~~</p>\r\n<p>第一家，面试的问的差不多全答对，手写了几个sql也对了，不过居然没有问hashmap，给的工资6000到9000，想了想，还是不去的好，太郊区，后来一查，是个培训兼外包的企业，还好没去。。。。</p>\r\n<p>第二家，某ERP公司，额，笔试，全是sql，做了，感觉还可以，面试直接说我们公司不用java，用的一个小众语言，薪资应届生只有3500，直接走人。。。。</p>\r\n<p>第三家，找工作，对广东真是彻底失望了，投的简历除了培训机构理你，其他的都不理人的，无奈之下投了北京的一家创业公司（A轮），薪资1万，电话面试，过了。。。。。后来想想，还是不去北京了，虽然工资高，但是没有朋友，过得像个死人一样。</p>\r\n<p>第四家，深圳一家创业公司，做东南亚社交软件的，可惜薪资没谈成，4K-6K，这可是深圳啊。。。。</p>\r\n<p>第五家，广州凡科，那天一早就从深圳跑过去，没吃饭，下午到就做笔试题，头晕，手抖，然后一面就是跟你讲笔试题，讲了两道，就叫我走了。。。仅仅半个小时，广深来回6个小时。。。</p>\r\n<p>第六家，广州某搞运维的公司，笔试差不多答对，面试问的问题也答对，但是没给offer。。。不理解</p>\r\n<p>第七家，然后晚上跑去了广工的久邦数码宣讲，试卷发到我这的时候，HR说我这方向的试卷没带够。。。。无奈向他要了大数据的题，全是数据库的题，过几天后得知居然过了，然后一面，问的问题没啥印象，除了left join的原理没答对。。。今天得知挂了。。。。</p>\r\n<p><img src=\"http://images2015.cnblogs.com/blog/755525/201703/755525-20170318000537838-305991370.png\" alt=\"\"></p>\r\n<p>第八家，极天信息（A轮），笔试的题目没看懂它问的啥，一面没啥印象了，然后是经理面，说广州没那么高的工资（7000），等消息，估计也没谈成。。。。</p>\r\n<p>第九家，中国移动，最气的了，一面就是HR面，问了两个问题，为什么不在北京留着，你觉得相比其他人你有什么优势。我只能说我真不会说话更不知怎么回答，就强调勤奋，然后直接被HR叫走人了，3分钟=w=</p>\r\n<p>第十家，珍爱网，找别人内推的，三个问题没答上来，就不跟你们说了，亲爱的竞争对手们=w=，谈了四十分钟吧，出来后感觉很不好，估计也是挂了。。。</p>\r\n<p>今天晚上，收到了久邦数码的拒绝信，瞬间觉得好无奈好迷茫，有时候就那么一个简简单单的问题，答不好就直接拒绝的，改怎么心平气和的面对下一个面试。有时候真不理解公司是怎么招人的，是不是真的“把部分简历扔进垃圾桶，不招那些运气不好的人”？也只能这么安慰自己。可是，事实呢？</p>\r\n<p><img src=\"http://images2015.cnblogs.com/blog/755525/201703/755525-20170318001336463-1583022291.jpg\" alt=\"\"></p>\r\n<p>这些天，有时间都是往深圳图书馆跑，看书，刷牛客网，补算法，看源码，做了这么多，该怎么告诉自己不要放弃。。。。。开始有点想念北京的雾霾</p>','2017-03-18',5,22,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(105,'数据库','1.SQL执行的顺序 2.NULL “空值” 和”NULL”的概念： 1：空值(‘’)是不占用空间的,判断空字符用 = ‘’ 或者 <> ‘’ 来进行处理; 2: NULL值是未知的，且占用空间，不走索引;判断 NULL 用 IS NULL 或者 is not null , SQL 语句函数中可以使用 ifnull ()函数来进行处理. 注：在进行 count ()统计某列的记录数的时候，如果采用','<h4 id=\"h4-1-sql-\"><a name=\"1.SQL执行的顺序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.SQL执行的顺序</h4><p><img src=\"http://uploadfiles.nowcoder.com/images/20150828/415611_1440751995009_3B3E1329A400F0022B20C4F32AEFC9EF\" alt=\"\"></p>\r\n<h4 id=\"h4-2-null\"><a name=\"2.NULL\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.NULL</h4><p>“空值” 和”NULL”的概念：<br>  1：空值(‘’)是不占用空间的,判断空字符用 = ‘’ 或者 &lt;&gt; ‘’ 来进行处理;<br> 2: NULL值是未知的，且占用空间，不走索引;判断 NULL 用 IS NULL 或者 is not null , SQL 语句函数中可以使用 ifnull ()函数来进行处理.<br>注：在进行 count ()统计某列的记录数的时候，如果采用的 NULL 值，会别系统自动忽略掉，但是空值是统计到其中</p>\r\n<h4 id=\"h4-3-\"><a name=\"3.\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.</h4><p>在MySQL数据库中，NULL对于一些特殊类型的列来说，其代表了一种特殊的含义，而不仅仅是一个空值。<br>IS NULL: 此运算符返回true，当列的值是NULL。<br>IS NOT NULL: 运算符返回true，当列的值不是NULL。<br>&lt;=&gt; 操作符比较值（不同于=运算符）为ture，即使两个NULL值<br>涉及NULL条件是特殊的。不能使用 =NULL 或 !=NULL 寻找NULL值的列</p>\r\n<h4 id=\"h4-4-nf\"><a name=\"4.NF\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.NF</h4><p>第一范式（   1NF   ）：   字段具有   原子性   ,   不可再分   。所有关系型数据库系统都满足第一范式）数据库表中的字段都是单一属性的，不可再分。例如，姓名字段，其中的姓和名必须作为一个整体，无法区分哪部分是姓，哪部分是名，如果要区分出姓和名，必须设计成两个独立的字段。<br>第二范式（   2NF   ）：   第二范式（   2NF   ）是在   第一范式（   1NF   ）的基础上   建立起来的，即满足第二范式（   2NF   ）必须先满足第一范式（   1NF   ）。要求   数据库表中的每个实例或行必须可以被惟一地区分   。通常需要为表加上一个列，以存储各个实例的惟一标识。这个惟一属性列被称为   主关键字或主键   。<br>        第二范式（   2NF   ）要求   实体的属性完全依赖于主关键字   。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。简而言之，第二范式就是非主属性非部分依赖于主关键字。<br>第三范式 （  3NF  ） ：   满足第三范式（   3NF   ）   必须先满足第二范式（   2NF   ）   。简而言之，第三范式（   3NF   ）要求一个数据库表中   不包含   已在其它表中   已包含的非主关键字信息   。所以第三范式具有如下特征：<br>1   ，每一列只有一个值<br>2   ，每一行都能区分。<br>3   ，每一个表都   不包含其他表已经包含   的非主关键字信息。<br>例如，帖子表中只能出现发帖人的   id   ，而不能出现发帖人的   id   ，还同时出现发帖人姓名，否则，只要出现同一发帖人   id   的所有记录，它们中的姓名部分都必须严格保持一致，这就是   数据冗余   。</p>','2017-03-18',3,19,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(106,'重载与重写','目前的问题：父类的功能无法满足子类的需求。 方法重写的前提： 必须要存在继承的关系。 方法的重写: 子父类出了同名的函数，这个我们就称作为方法的重写。 什么是时候要使用方法的重写：父类的功能无法满足子类的需求时。 方法重写要注意的事项： 1.方法重写时， 方法名与形参列表必须一致。 2.方法重写时，子类的权限修饰符必须要大于或者等于父类的权限修饰符。 3.方法重写时，子类的返回值类型必须要小于或者','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><p>目前的问题：父类的功能无法满足子类的需求。</p>\n<p>方法重写的前提： 必须要存在继承的关系。</p>\n<p>方法的重写: 子父类出了同名的函数，这个我们就称作为方法的重写。</p>\n<p>什么是时候要使用方法的重写：父类的功能无法满足子类的需求时。</p>\n<p>方法重写要注意的事项：<br>    1.方法重写时， 方法名与形参列表必须一致。<br>    2.方法重写时，子类的权限修饰符必须要大于或者等于父类的权限修饰符。<br>    3.方法重写时，子类的返回值类型必须要小于或者 等于父类的返回值类型。<br>    4.方法重写时， 子类抛出的异常类型要小于或者等于父类抛出的异常类型。<br>            Exception(最坏)<br>            RuntimeException(小坏)</p>\n<p>方法的重载：在一个类中 存在两个或者两个 以上的同名函数,称作为方法重载。</p>\n<p>方法重载的要求</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"lit\">1.</span><span class=\"pln\"> </span><span class=\"pun\">函数名要一致。</span></code></li><li class=\"L1\"><code><span class=\"lit\">2.</span><span class=\"pln\"> </span><span class=\"pun\">形参列表不一致（形参的个数或形参</span><span class=\"pln\"> </span><span class=\"pun\">的类型不一致）</span></code></li><li class=\"L2\"><code><span class=\"lit\">3.</span><span class=\"pln\"> </span><span class=\"pun\">与返回值类型无关。</span></code></li></ol></pre></div>','2017-03-21',1,19,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(107,'垃圾回收算法','垃圾回收算法 1、标记-清除算法 2、复制算法 3、标记-整理算法 一、标记-清除算法 标记-清除算法采用从根集合进行扫描，对存活的对象对象标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收，如上图所示。 标记-清除算法不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效，但由于标记-清除算法直接回收不存活的对象，因此会造成内存碎片！ 二、复制算法 复制算法','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h2 id=\"h2-u5783u573Eu56DEu6536u7B97u6CD5\"><a name=\"垃圾回收算法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>垃圾回收算法</h2><p>1、标记-清除算法<br>2、复制算法<br>3、标记-整理算法</p>\n<h4 id=\"h4--\"><a name=\"一、标记-清除算法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、标记-清除算法</h4><p><img src=\"http://dl2.iteye.com/upload/attachment/0075/0386/29ae17ad-f8af-38b4-9e25-28ef3550858f.jpg\" alt=\"\">标记-清除算法采用从根集合进行扫描，对存活的对象对象标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收，如上图所示。<br>标记-清除算法不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效，但由于标记-清除算法直接回收不存活的对象，因此会造成内存碎片！</p>\n<h4 id=\"h4--\"><a name=\"二、复制算法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、复制算法</h4><p><img src=\"http://dl2.iteye.com/upload/attachment/0075/0388/91a656d4-f08a-377b-8eea-5785c2932533.jpg\" alt=\"\"><br>复制算法采用从根集合扫描，并将存活对象复制到一块新的，没有使用过的空间中，这种算法当控件存活的对象比较少时，极为高效，但是带来的成本是需要一块内存交换空间用于进行对象的移动。也就是我们前面提到的s0 s1等空间。</p>\n<h4 id=\"h4--\"><a name=\"三、标记-整理算法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、标记-整理算法</h4><p><img src=\"http://dl2.iteye.com/upload/attachment/0075/0390/6ba95f80-c7bc-3d09-b927-ac09297e9920.jpg\" alt=\"\"><br> 标记-整理算法采用标记-清除算法一样的方式进行对象的标记，但在清除时不同，在回收不存活的对象占用的空间后，会将所有的存活对象往左端空闲空间移动，并更新对应的指针。标记-整理算法是在标记-清除算法的基础上，又进行了对象的移动，因此成本更高，但是却解决了内存碎片的问题。</p>\n</div>','2017-04-09',1,23,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(108,'java分代回收','一、新生代内存的回收（minor GC）主要采用复制算法，下图展示了minor GC的执行过程。 二、对于新生代和旧生代，JVM可使用很多种垃圾回收器进行垃圾回收，下图展示了不同生代不通垃圾回收器，其中两个回收器之间有连线表示这两个回收器可以同时使用。 而这些垃圾回收器又分为串行回收方式、并行回收方式合并发回收方式执行，分别运用于不同的场景。如下图所示 三、收集器 1.Serial收集器 看名字我','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h2 id=\"h2--minor-gc-minor-gc-\"><a name=\"一、新生代内存的回收（minor GC）主要采用复制算法，下图展示了minor GC的执行过程。\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、新生代内存的回收（minor GC）主要采用复制算法，下图展示了minor GC的执行过程。</h2><p><img src=\"http://dl2.iteye.com/upload/attachment/0075/0392/732c7557-aa9a-3551-b14d-f543c5b0c94b.jpg\" alt=\"\"></p>\n<h2 id=\"h2--jvm-\"><a name=\"二、对于新生代和旧生代，JVM可使用很多种垃圾回收器进行垃圾回收，下图展示了不同生代不通垃圾回收器，其中两个回收器之间有连线表示这两个回收器可以同时使用。\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、对于新生代和旧生代，JVM可使用很多种垃圾回收器进行垃圾回收，下图展示了不同生代不通垃圾回收器，其中两个回收器之间有连线表示这两个回收器可以同时使用。</h2><p><img src=\"http://dl2.iteye.com/upload/attachment/0075/0394/0172f624-9018-3642-bf26-05a2c3071639.jpg\" alt=\"\"><br>而这些垃圾回收器又分为串行回收方式、并行回收方式合并发回收方式执行，分别运用于不同的场景。如下图所示<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0396/c962c2ad-273f-3de4-b2e3-a4dd8b946215.jpg\" alt=\"\"></p>\n<h2 id=\"h2--\"><a name=\"三、收集器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、收集器</h2><h4 id=\"h4-1-serial-\"><a name=\"1.Serial收集器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.Serial收集器</h4><p>看名字我们都可以看的出来，这个属于串行收集器。其运行示意图如下<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0398/681da5ca-5eff-3984-bece-3d80dfe905be.jpg\" alt=\"\"><br>    收集器是历史最悠久的一个回收器，JDK1.3之前广泛使用这个收集器，目前也是ClientVM下 ServerVM 4核4GB以下机器的默认垃圾回收器。串行收集器并不是只能使用一个CPU进行收集，而是当JVM需要进行垃圾回收的时候，需要中断所有的用户线程，知道它回收结束为止，因此又号称“Stop The World” 的垃圾回收器。注意，JVM中文名称为java虚拟机，因此它就像一台虚拟的电脑一样在工作，而其中的每一个线程就被认为是JVM的一个处理器，因此大家看到图中的CPU0、CPU1实际为用户的线程，而不是真正机器的CPU，大家不要误解哦。<br>    串行回收方式适合低端机器，是Client模式下的默认收集器，对CPU和内存的消耗不高，适合用户交互比较少，后台任务较多的系统。<br>    Serial收集器默认新旧生代的回收器搭配为Serial+ SerialOld</p>\n<h4 id=\"h4-2-parnew-\"><a name=\"2.ParNew收集器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.ParNew收集器</h4><p>ParNew收集器其实就是多线程版本的Serial收集器，其运行示意图如下<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0400/6443b39c-ed33-3d93-a690-87e646439561.jpg\" alt=\"\"><br>同样有Stop The World的问题，他是多CPU模式下的首选回收器（该回收器在单CPU的环境下回收效率远远低于Serial收集器，所以一定要注意场景哦），也是Server模式下的默认收集器。</p>\n<h4 id=\"h4-3-parallelscavenge\"><a name=\"3.ParallelScavenge\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.ParallelScavenge</h4><p>ParallelScavenge又被称为是吞吐量优先的收集器，器运行示意图如下<br><img src=\"http://dl.iteye.com/upload/attachment/0075/0402/5007beba-0b0e-3cf4-b146-c28b6c0dd696.jpg\" alt=\"\"><br> ParallelScavenge<br>所提到的吞吐量=程序运行时间/(JVM执行回收的时间+程序运行时间),假设程序运行了100分钟，JVM的垃圾回收占用1分钟，那么吞吐量就是99%。在当今网络告诉发达的今天，良好的响应速度是提升用户体验的一个重要指标，多核并行云计算的发展要求程序尽可能的使用CPU和内存资源，尽快的计算出最终结果，因此在交互不多的云端，比较适合使用该回收器。</p>\n<h4 id=\"h4-4-parallelold\"><a name=\"4.ParallelOld\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.ParallelOld</h4><p>ParallelOld是老生代并行收集器的一种，使用标记整理算法、是老生代吞吐量优先的一个收集器。这个收集器是JDK1.6之后刚引入的一款收集器，我们看之前那个图之间的关联关系可以看到，早期没有ParallelOld之前，吞吐量优先的收集器老生代只能使用串行回收收集器，大大的拖累了吞吐量优先的性能，自从JDK1.6之后，才能真正做到较高效率的吞吐量优先。其运行示意图如下<br><img src=\"http://dl.iteye.com/upload/attachment/0075/0406/9a14da85-f943-3408-ba88-c6bb3842a792.jpg\" alt=\"\"></p>\n<h4 id=\"h4-5-serialold\"><a name=\"5.SerialOld\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.SerialOld</h4><p>SerialOld是旧生代Client模式下的默认收集器，单线程执行；在JDK1.6之前也是ParallelScvenge回收新生代模式下旧生代的默认收集器，同时也是并发收集器CMS回收失败后的备用收集器。其运行示意图如下<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0404/ce7aabd5-b0e0-3cda-9b6c-607cf6ebf689.jpg\" alt=\"\"></p>\n<h4 id=\"h4-5-cms\"><a name=\"5.CMS\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.CMS</h4><p>CMS又称响应时间优先(最短回收停顿)的回收器，使用并发模式回收垃圾，使用标记-清除算法，CMS对CPU是非常敏感的，它的回收线程数=（CPU+3）/4，因此当CPU是2核的实惠，回收线程将占用的CPU资源的50%，而当CPU核心数为4时仅占用25%。他的运行示意图如下<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0408/4239228b-879f-382f-81c6-5c32799886d6.jpg\" alt=\"\"><br>模式主要分为四个过程：<br>1.初始标记<br>2.并发标记<br>3.重新标记<br>4.并发清除<br>在初始标记的时候，需要中断所有用户线程，在并发标记阶段，用户线程和标记线程<br>并发执行，而在这个过程中，随着内存引用关系的变化，可能会发生原来标记的对象被释放，进而引发新的垃圾，因此可能会产生一系列的浮动垃圾，不能被回收。</p>\n<p>CMS 为了确保能够扫描到所有的对象，避免在Initial Marking 中还有未标识到的对象，采用的方法为找到标记了的对象，并将这些对象放入Stack 中，扫描时寻找此对象依赖的对象，如果依赖的对象的地址在其之前，则将此对象进行标记，并同时放入Stack 中，如依赖的对象地址在其之后，则仅标记该对象。<br>在进行Concurrent Marking 时minor GC 也可能会同时进行，这个时候很容易造成旧生代对象引用关系改变，CMS 为了应对这样的并发现象，提供了一个Mod Union Table 来进行记录，在这个Mod Union Table中记录每次minor GC 后修改了的Card 的信息。这也是ParallelScavenge不能和CMS一起使用的原因。<br>CMS产生浮动垃圾的情况请见如下示意图<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0410/60e7c659-790a-3405-af70-9ca4cfd9258d.jpg\" alt=\"\"><br>在运行回收过后，c就变成了浮动垃圾。<br>由于CMS会产生浮动垃圾，当回收过后，浮动垃圾如果产生过多，同时因为使用标记-清除算法会产生碎片，可能会导致回收过后的连续空间仍然不能容纳新生代移动过来或者新创建的大资源，因此会导致CMS回收失败，进而触发另外一次FULL GC，而这时候则采用SerialOld进行二次回收。<br>同时CMS因为可能产生浮动垃圾，而CMS在执行回收的同时新生代也有可能在进行回收操作，为了保证旧生代能够存放新生代转移过来的数据，CMS在旧生代内存到达全部容量的68%就触发了CMS的回收！</p>\n<h4 id=\"h4-7-garbagefirst-g1-\"><a name=\"7.GarbageFirst(G1)\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>7.GarbageFirst(G1)</h4><p>我们再来看垃圾回收器的总图，刚才我们可以看到，我在图上标记了一个？，其实这是一个新的垃圾回收器，既可以回收新生代也可以回收旧生代，SunHotSpot 1.6u14以上EarlyAccess版本加入了这个回收器，sun公司预期SunHotSpot1.7发布正式版，他是商用高性能垃圾回收器，通过重新划分内存区域，整合优化CMS，同时注重吞吐量和响应时间，但是杯具的是被Oracle收购之后这个收集器属于商用收费收集器，因此目前基本上没有人使用，我们在这里也就不多介绍，更多信息可以参考oracle新版本JDK说明。</p>\n</div>','2017-04-09',1,24,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(109,'java汇编','java 汇编 http://download.csdn.net/download/jiangfuqiang/8403497','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><p>java 汇编<br><a href=\"http://download.csdn.net/download/jiangfuqiang/8403497\">http://download.csdn.net/download/jiangfuqiang/8403497</a></p>\n</div>','2017-04-10',1,22,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(110,'jvm','-XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><p>-XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly</p>\n</div>','2017-04-10',1,28,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(111,'Adaboost','NaiveBayesSpamFilter 利用朴素贝叶斯算法实现垃圾邮件的过滤，并结合Adaboost改进该算法。 1 Naive Bayes spam filtering   假设邮件的内容中包含的词汇为Wi，垃圾邮件Spam，正常邮件ham。 判断一份邮件，内容包含的词汇为Wi，判断该邮件是否是垃圾邮件，即计算P（S|Wi）这个条件概率。根据Bayes’ theorem：   Bayes’ t','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h1 id=\"h1-naivebayesspamfilter\"><a name=\"NaiveBayesSpamFilter\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>NaiveBayesSpamFilter</h1><p>利用朴素贝叶斯算法实现垃圾邮件的过滤，并结合Adaboost改进该算法。</p>\n<h3 id=\"h3-1-naive-bayes-spam-filtering\"><a name=\"1 Naive Bayes spam filtering\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1 Naive Bayes spam filtering</h3><p>  假设邮件的内容中包含的词汇为Wi，垃圾邮件Spam，正常邮件ham。 判断一份邮件，内容包含的词汇为Wi，判断该邮件是否是垃圾邮件，即计算P（S|Wi）这个条件概率。根据Bayes’ theorem：</p>\n<p>  Bayes’ theorem</p>\n<p>  其中：</p>\n<p>Pr(S|Wi) 出现词汇Wi的邮件是垃圾邮件的条件概率（即后验概率）；<br>Pr(S) 训练阶段邮件数据集中垃圾邮件的概率，或实际调查的垃圾邮件的概率（即先验概率）；<br>Pr(Wi|S) 垃圾邮件中词汇Wi出现的概率；<br>Pr(H) 训练阶段邮件数据集中正常邮件的概率，或实际调查的正常邮件的概率；<br>Pr(Wi|H) 正常邮件中词汇Wi出现的概率；<br>  对于邮件中出现的所有词汇，考虑每个词汇出现事件的独立性，计算Pr(S|Wi)的联合概率Pr(S|W)，W={W1，W2，…Wn}：</p>\n<p>  Bayes’ theorem</p>\n<p>  其中：</p>\n<p>P 即Pr(S|W)，出现词汇W={W1，W2……Wn}的邮件是垃圾邮件的条件概率；<br>Pi 即Pr(S|Wi)，出现词汇Wi的邮件是垃圾邮件的条件概率；<br>  注： 程序中，通过计算出Pr(S|W)和Pr(H|W)，比较Pr(S|W)和Pr(H|W)的大小，判断是垃圾邮件还是正常邮件。我们发现Pr(S|W)和Pr(H|W)计算的分母相同，所以我们只需要比较分子即可。</p>\n<p>  但存在两个问题：</p>\n<p>当词汇不存在时，即ni=0，此时Pr(S|Wi) = 0，会造成P=0，无法比较<br>当Pr(S|Wi)较小时，连乘操作会造成下溢出问题<br>  解决方案：</p>\n<p>计算P(Wi|S)和P(Wi|H)时，将所有词汇初始化出现的次数为1，并将分母初始化为2（或根据样本/实际调查结果调整分母的值）。</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"com\"># 统计语料库中词汇在S和H中出现的次数</span></code></li><li class=\"L1\"><code><span class=\"pln\">wordsInSpamNum </span><span class=\"pun\">=</span><span class=\"pln\"> np</span><span class=\"pun\">.</span><span class=\"pln\">ones</span><span class=\"pun\">(</span><span class=\"pln\">numWords</span><span class=\"pun\">)</span></code></li><li class=\"L2\"><code><span class=\"pln\">wordsInHealthNum </span><span class=\"pun\">=</span><span class=\"pln\"> np</span><span class=\"pun\">.</span><span class=\"pln\">ones</span><span class=\"pun\">(</span><span class=\"pln\">numWords</span><span class=\"pun\">)</span></code></li><li class=\"L3\"><code><span class=\"pln\">spamWordsNum </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">2.0</span></code></li><li class=\"L4\"><code><span class=\"pln\">healthWordsNum </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">2.0</span></code></li></ol></pre><p>计算P(Wi|S)和P(Wi|H)时，对概率取对数<br>    pWordsSpamicity = np.log(wordsInSpamNum / spamWordsNum)<br>    pWordsHealthy = np.log(wordsInHealthNum / healthWordsNum)<br>  所以最终比较的是，P(W1|S)P(W2|S)….P(Wn|S)P(S)和P(W1|H)P(W2|H)….P(Wn|H)P(H)的大小。</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"pln\">ps </span><span class=\"pun\">=</span><span class=\"pln\"> sum</span><span class=\"pun\">(</span><span class=\"pln\">testWordsMarkedArray </span><span class=\"pun\">*</span><span class=\"pln\"> pWordsSpamicity</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">+</span><span class=\"pln\"> np</span><span class=\"pun\">.</span><span class=\"pln\">log</span><span class=\"pun\">(</span><span class=\"pln\">pSpam</span><span class=\"pun\">)</span></code></li><li class=\"L1\"><code><span class=\"pln\">ph </span><span class=\"pun\">=</span><span class=\"pln\"> sum</span><span class=\"pun\">(</span><span class=\"pln\">testWordsMarkedArray </span><span class=\"pun\">*</span><span class=\"pln\"> pWordsHealthy</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">+</span><span class=\"pln\"> np</span><span class=\"pun\">.</span><span class=\"pln\">log</span><span class=\"pun\">(</span><span class=\"lit\">1</span><span class=\"pln\"> </span><span class=\"pun\">-</span><span class=\"pln\"> pSpam</span><span class=\"pun\">)</span></code></li></ol></pre><p>  测试效果： 5574个样本，采用交叉验证，随机选取4574个作为训练样本，产生词汇列表（语料库），对1000个测试样本，分类的平均错误率约为：2.5%。</p>\n<h3 id=\"h3-2-running-adaboost-on-naive-bayes\"><a name=\"2 Running Adaboost on Naive Bayes\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2 Running Adaboost on Naive Bayes</h3><p>  我们在计算ps和ph联合后验概率时，可引入一个调整因子DS，其作用是调整词汇表中某一词汇的“垃圾程度”(spamicity)，</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"pln\">ps </span><span class=\"pun\">=</span><span class=\"pln\"> sum</span><span class=\"pun\">(</span><span class=\"pln\">testWordsMarkedArray </span><span class=\"pun\">*</span><span class=\"pln\"> pWordsSpamicity </span><span class=\"pun\">*</span><span class=\"pln\"> DS</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">+</span><span class=\"pln\"> np</span><span class=\"pun\">.</span><span class=\"pln\">log</span><span class=\"pun\">(</span><span class=\"pln\">pSpam</span><span class=\"pun\">)</span></code></li></ol></pre><p>  其中DS通过Adaboost算法迭代获取最佳值。原理如下：</p>\n<p>设定adaboost循环的次数count<br>交叉验证随机选择1000个样本<br>DS初始化为和词汇列表大小相等的全一向量<br>迭代循环count次：<br>    设定最小分类错误率为inf<br>    对于每一个样本：<br>        在当前DS下对样本分类<br>        如果分类出错：<br>            计算出错的程度，即比较ps和ph的相差alpha<br>            如果样本原本是spam，错分成ham：<br>                DS[样本包含的词汇] = np.abs(DS[样本包含的词汇] - np.exp(alpha) / DS[样本包含的词汇])<br>            如果样本原本是ham，错分成spam：<br>                DS[样本包含的词汇] = DS[样本包含的词汇] + np.exp(alpha) / DS[样本包含的词汇]<br>    计算错误率<br>    保存最小的错误率和此时的词汇列表、P(Wi|S)和P(Wi|H)、DS等信息，即保存训练好的最佳模型的信息<br>  测试效果： 5574个样本，获取Adaboost算法训练的最佳模型信息（包括词汇列表、P(Wi|S)和P(Wi|H)、DS等），对1000个测试样本，分类的平均错误率约为：0.5%。</p>\n</div>','2017-04-17',4,32,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(112,'Java堆.栈和常量池 笔记','Java堆.栈和常量池 笔记','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><p><a href=\"http://www.iteye.com/topic/634530\">Java堆.栈和常量池 笔记</a></p>\n</div>','2017-04-23',1,33,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(113,'redis','redis的数据结构 数据结构类型 结构存储的值 结构的读写能力 STRING 可以是字符串、整数、或者浮点数 对整个字符串或者字符串的其中一部分执行操作；对整数和浮点数执行自增或者自减 LIST 一个链表，链表上的每个节点都包含了一个字符串 从链表的两端推入或者弹出元素；根据偏移量对链表进行修剪；根据值查找或者移除元素 SET 包含字符串的无序收集器，并且被包含的每个字符串都是独一无二、各不相同','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h1 id=\"h1-redis-\"><a name=\"redis的数据结构\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>redis的数据结构</h1><table>\n<thead>\n<tr>\n<th>数据结构类型</th>\n<th>结构存储的值</th>\n<th>结构的读写能力</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>STRING</td>\n<td>可以是字符串、整数、或者浮点数</td>\n<td>对整个字符串或者字符串的其中一部分执行操作；对整数和浮点数执行自增或者自减</td>\n</tr>\n<tr>\n<td>LIST</td>\n<td>一个链表，链表上的每个节点都包含了一个字符串</td>\n<td>从链表的两端推入或者弹出元素；根据偏移量对链表进行修剪；根据值查找或者移除元素</td>\n</tr>\n<tr>\n<td>SET</td>\n<td>包含字符串的无序收集器，并且被包含的每个字符串都是独一无二、各不相同的</td>\n<td>添加、获取、移除单个元素；检查一个元素是否存在于集合中；计算交集、并集、差集；从集合里面随机获取元素</td>\n</tr>\n<tr>\n<td>HASH</td>\n<td>包含键值对的无语散列表</td>\n<td>添加、获取、移除单个键值对；获取所有键值对</td>\n</tr>\n<tr>\n<td>ZSET(有序集合)</td>\n<td>字符串成员与浮点数分值之间的有序映射，元素的排列顺序由分值的大小决定</td>\n<td>添加、获取、单个元素；根据分值范围或者成员来获取元素</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"h3--string-\"><a name=\"一、STRING基本操作\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、STRING基本操作</h3><p>（1）SET 设置存储在给定键中的值<br>（2）GET 获取存储在给定键中的值<br>（3）DEL 删除存储在给定键中的值</p>\n<h3 id=\"h3--list-\"><a name=\"二、LIST（列表）基本操作\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、LIST（列表）基本操作</h3><p>（1）RPUSH 将给定值推入列表的右端<br>（2）LRANGE 获取列表在给定范围上的所有值<br>（3）LINDEX 获取列表在给定位置上的单个元素<br>（4）LPOP 从列表的左端弹出一个值，并返回被弹出的值</p>\n<h3 id=\"h3--set-\"><a name=\"三、SET（集合）基本操作\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>　三、SET（集合）基本操作</h3><p>（1）SADD 将给定元素添加到集合<br>（2）SMEMBERS 返回集合包含的所有元素<br>（3）SISMEMBER 检查给定元素是否存在于集合中<br>（4）SREM 如果给定的元素存在于集合中，那么移除这个元素</p>\n<h3 id=\"h3--hash-\"><a name=\"四、HASH（散列）基本操作\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>四、HASH（散列）基本操作</h3><p>（1）HSET 在散列里面关联起给定的键值对<br>（2）HGET 获取指定散列键的值<br>（3）HGETALL 获取散列包含的所有键值对<br>（4）HDEL 如果给定键存在于散列里面，那么移除这个键</p>\n<h3 id=\"h3--zset-\"><a name=\"五、ZSET（有序集合）基本操作\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>五、ZSET（有序集合）基本操作</h3><p>（1）ZADD 将一个带有给定分值的成员添加到有序集合里面<br>（2）ZRANGE 根据元素在有序排列中所处的位置，从有序集合里面获取多个元素<br>（3）ZRANGEBYSCORE 获取有序集合在给定分值范围的所有元素<br>（4）ZREM 如果给定成员存在于有序集合，那么移除这个成员</p>\n</div>','2017-05-04',6,27,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(114,'工厂模式','工厂模式 目录 何为工厂模式 工厂方法与抽象工厂 如何在Java EE中通过@Producers与@Inject注解实现工厂模式 如何创建自定义注解以及通过@Qualifier消除具体实现之间的歧义 工厂模式有两种模式：工厂方法和抽象方法。它们的意图是一样的：提供一个接口，在不指定具体类的情况下创建相关或依赖的一系列对象。 一.何为工厂模式 工厂的目的在于创建对象。创建的逻辑被封装在工厂中，要么提','<h1 id=\"h1-u5DE5u5382u6A21u5F0F\"><a name=\"工厂模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>工厂模式</h1><p>目录</p>\r\n<ul>\r\n<li>何为工厂模式</li><li>工厂方法与抽象工厂</li><li>如何在Java EE中通过<a href=\"https://github.com/Producers\" title=\"&#64;Producers\" class=\"at-link\">@Producers</a>与<a href=\"https://github.com/Inject\" title=\"&#64;Inject\" class=\"at-link\">@Inject</a>注解实现工厂模式</li><li>如何创建自定义注解以及通过<a href=\"https://github.com/Qualifier\" title=\"&#64;Qualifier\" class=\"at-link\">@Qualifier</a>消除具体实现之间的歧义<br>工厂模式有两种模式：工厂方法和抽象方法。它们的意图是一样的：提供一个接口，在不指定具体类的情况下创建相关或依赖的一系列对象。</li></ul>\r\n<h3 id=\"h3--\"><a name=\"一.何为工厂模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一.何为工厂模式</h3><p>工厂的目的在于创建对象。创建的逻辑被封装在工厂中，要么提供一个方法来返回新创建的对象（工厂方法模式），要么将对象的创建委托给子类（抽象工厂模式）。<br>客户端不必考虑接口或类的不同实现，它只需通过工厂（工厂）获取接口实现的一个实例的即可，这样客户端与对象的创建就实现了解耦<br>解耦是应用依赖反转原则的结果，这带来了很多好处，其中最重要的好处就是实现了高层类与底层类之间的解耦。通过解耦，具体类实现的变化不会影响到客户端，这降低了类与类之间的耦合，并提升了灵活性。</p>\r\n<h3 id=\"h3--\"><a name=\"二.工厂方法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二.工厂方法</h3><p>GoF一书是这样描述工程方法模式的：“定义一个用于创建对象的接口，不过让子类决定实例化那个类”<br>工厂极大降低了new关键字的使用次数，并且将初始化过程与不同的具体实现封装起来。将这些需求中心化可以极大减少向系统中添加或删除具体类的影响以及具体的类依赖的影响。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src=\"http://ohlrxdl4p.bkt.clouddn.com/images/QQ截图20170506134421.jpg\" alt=\"\"><br><strong>1.使用普通代码实现工厂方法</strong><br>被具体实现继承的DrinksMachine抽象类</p>\r\n<pre><code class=\"lang-java\">public abstract class DrinksMachine {\r\n    public abstract Drink dispenseDrink();\r\n    public String displayMessage(){\r\n        return &quot;Thank for your custom.&quot;;\r\n    }\r\n}\r\n</code></pre>\r\n<p>DrinksMachine抽象类的CoffeeMachine实现</p>\r\n<pre><code class=\"lang-java\">public class CoffeeMachine extends DrinksMachine {\r\n    public Drink dispenseDrink() {\r\n        return new Coffee();\r\n    }\r\n}\r\n</code></pre>\r\n<p>DrinksMachine抽象类的SoftDrinksMachine实现</p>\r\n<pre><code class=\"lang-java\">public class SoftDrinksMachine extends DrinksMachine {\r\n    public Drink dispenseDrink() {\r\n        return new SoftDrink();\r\n    }\r\n}\r\n</code></pre>\r\n<p>Drink接口</p>\r\n<pre><code class=\"lang-java\">public interface Drink {}\r\n</code></pre>\r\n<p>Drink接口的SoftDrink实现</p>\r\n<pre><code class=\"lang-java\">public class SoftDrink implements Drink {\r\n    SoftDrink() {\r\n        System.out.println(&quot;Soft drink&quot;);\r\n    }\r\n}\r\n</code></pre>\r\n<p>Drink接口的Coffee实现</p>\r\n<pre><code class=\"lang-java\">public class Coffee implements Drink {\r\n    Coffee() {\r\n        System.out.println(&quot;Coffee&quot;);\r\n    }\r\n}\r\n</code></pre>\r\n<p>CoffeeType枚举<br>```java<br>public enum CoffeeType {EXPRESSO, LATTE}</p>\r\n<p>public Drink dispenseDrink(CoffeeType type) {<br>    Drink coffee = null;<br>    switch (type) {<br>        case EXPRESSO: coffee = new Expresso();<br>        case LATTE: coffee = new Latte();<br>    }<br>    return coffee;<br>}<br>```&lt;!--前面不能有空格--&gt;</p>','2017-05-06',1,30,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(115,'代理模式','代理模式(Proxy Pattern) GoF中给出的代理模式的定义为： 代理模式给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。 代理模式的英文叫做Proxy或Surrogate，它是一种对象结构型模式。 代理模式根据其目的和实现可分为很多种类，常用的代理模式包括如下几种： （1）远程代理（Remote Proxy）————为一个位于不同的地址空间的对象提供一个本地的代理对象','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h1 id=\"h1--proxy-pattern-\"><a name=\"代理模式(Proxy Pattern)\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代理模式(Proxy Pattern)</h1><p>GoF中给出的代理模式的定义为：<br>代理模式给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。<br>代理模式的英文叫做Proxy或Surrogate，它是一种对象结构型模式。<br>代理模式根据其目的和实现可分为很多种类，常用的代理模式包括如下几种：<br>（1）远程代理（Remote Proxy）————为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以是在同一台主机中，也可以是在另一台主机中，远程代理又称为大使（Ambassador）<br>（2）虚拟代理（Virtual Proxy）————如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。<br>（3）保护代理（Protect Proxy）————控制一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。<br>（4）缓冲代理（Cache Proxy）————为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。<br>（5）只能引用代理（Smart Reference Proxy）————当一个对象被引用时，提供一些额外的操作，例如将对象被调用的次数记录下来。<br><img src=\"http://ohlrxdl4p.bkt.clouddn.com/images/QQ截图20170507103646.jpg\" alt=\"\"></p>\n<p>代码实现：<br>1.抽象主题类——BuyTicket.java</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code class=\"lang-java\"><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">interface</span><span class=\"pln\"> </span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> showticket</span><span class=\"pun\">();</span></code></li><li class=\"L2\"><code class=\"lang-java\"><span class=\"pun\">}</span></code></li></ol></pre>\n<p>2.具体主题类——Train.java</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code class=\"lang-java\"><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Train</span><span class=\"pln\"> </span><span class=\"kwd\">implements</span><span class=\"pln\"> </span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"lit\">@Override</span></code></li><li class=\"L2\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> showticket</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L3\"><code class=\"lang-java\"><span class=\"pln\">        </span><span class=\"typ\">System</span><span class=\"pun\">.</span><span class=\"pln\">out</span><span class=\"pun\">.</span><span class=\"pln\">println</span><span class=\"pun\">(</span><span class=\"str\">\"one ticket\"</span><span class=\"pun\">);</span></code></li><li class=\"L4\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L5\"><code class=\"lang-java\"><span class=\"pun\">}</span></code></li></ol></pre>\n<p>3.代理角色类——TicketCenter.java</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code class=\"lang-java\"><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">TicketCenter</span><span class=\"pln\"> </span><span class=\"kwd\">implements</span><span class=\"pln\"> </span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> ticket</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code class=\"lang-java\"></code></li><li class=\"L3\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"typ\">TicketCenter</span><span class=\"pun\">(</span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> ticket</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code class=\"lang-java\"><span class=\"pln\">        </span><span class=\"kwd\">this</span><span class=\"pun\">.</span><span class=\"pln\">ticket </span><span class=\"pun\">=</span><span class=\"pln\"> ticket</span><span class=\"pun\">;</span></code></li><li class=\"L5\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code class=\"lang-java\"></code></li><li class=\"L7\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"lit\">@Override</span></code></li><li class=\"L8\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> showticket</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L9\"><code class=\"lang-java\"><span class=\"pln\">        ticket</span><span class=\"pun\">.</span><span class=\"pln\">showticket</span><span class=\"pun\">();</span></code></li><li class=\"L0\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code class=\"lang-java\"></code></li><li class=\"L2\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> buy</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L3\"><code class=\"lang-java\"><span class=\"pln\">        </span><span class=\"typ\">System</span><span class=\"pun\">.</span><span class=\"pln\">out</span><span class=\"pun\">.</span><span class=\"pln\">println</span><span class=\"pun\">(</span><span class=\"str\">\"by proxy\"</span><span class=\"pun\">);</span></code></li><li class=\"L4\"><code class=\"lang-java\"><span class=\"pln\">        showticket</span><span class=\"pun\">();</span></code></li><li class=\"L5\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code class=\"lang-java\"><span class=\"pun\">}</span></code></li></ol></pre>\n<p>4.客户端测试类</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code class=\"lang-java\"><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">ProxyPattern</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> main</span><span class=\"pun\">(</span><span class=\"typ\">String</span><span class=\"pln\"> args</span><span class=\"pun\">[])</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L2\"><code class=\"lang-java\"><span class=\"pln\">        </span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> x </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Train</span><span class=\"pun\">();</span></code></li><li class=\"L3\"><code class=\"lang-java\"><span class=\"pln\">        </span><span class=\"typ\">TicketCenter</span><span class=\"pln\"> y </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">TicketCenter</span><span class=\"pun\">(</span><span class=\"pln\">x</span><span class=\"pun\">);</span></code></li><li class=\"L4\"><code class=\"lang-java\"><span class=\"pln\">        y</span><span class=\"pun\">.</span><span class=\"pln\">buy</span><span class=\"pun\">();</span></code></li><li class=\"L5\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code class=\"lang-java\"><span class=\"pun\">}</span></code></li></ol></pre>\n<p>运行结果：</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code class=\"lang-html\"><span class=\"pln\">by proxy</span></code></li><li class=\"L1\"><code class=\"lang-html\"><span class=\"pln\">one ticket</span></code></li></ol></pre>\n</div>','2017-05-07',1,28,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(143,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,12,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(144,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,19,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(145,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,19,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(146,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,20,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(147,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,20,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(148,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,19,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(149,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,19,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(150,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,19,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(151,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,17,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(152,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,17,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(153,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,18,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(154,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,23,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(155,'BSbsbsbs','heloo 哦i已被肉','<h1 id=\"h1-heloo-i-\"><a name=\"heloo 哦i已被肉\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>heloo 哦i已被肉</h1>','2017-01-23',3,22,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(156,'2017-02-28学习笔记','','<p><img src=\"http://ohlrxdl4p.bkt.clouddn.com/images/826546_1482322555369_C5DABB18734059E89A45A0E9170722B0.png\" alt=\"\"></p>','2017-02-28',1,28,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(157,'2017-03-01学习笔记','知识点 1.java中只有值传递，没有引用传递http://guhanjie.iteye.com/blog/1683637 2.final关键字 final修饰变量，则等同于常量. final修饰方法中的参数，称为最终参数. final修饰类，则类不能被继承. final修饰方法，则方法不能被','<h1 id=\"h1-u77E5u8BC6u70B9\"><a name=\"知识点\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>知识点</h1><h4 id=\"h4-1-java-http-guhanjie-iteye-com-blog-1683637\"><a name=\"1.java中只有值传递，没有引用传递  http://guhanjie.iteye.com/blog/1683637\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.java中只有值传递，没有引用传递<a href=\"http://guhanjie.iteye.com/blog/1683637\">http://guhanjie.iteye.com/blog/1683637</a></h4><h4 id=\"h4-2-final-\"><a name=\"2.final关键字\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.final关键字</h4><ul>\r\n<li>final修饰变量，则等同于常量.</li><li>final修饰方法中的参数，称为最终参数.</li><li>final修饰类，则类不能被继承.</li><li>final修饰方法，则方法不能被重写.</li></ul>\r\n<h4 id=\"h4-3-integer-img-src-https-uploadfiles-nowcoder-com-images-20160717-6316247_1468761643205_9f7b85ab04292cf73778d98998a20ed1-alt-\"><a name=\"3.Integer<img src=\"https://uploadfiles.nowcoder.com/images/20160717/6316247_1468761643205_9F7B85AB04292CF73778D98998A20ED1\" alt=\"图片\">\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.Integer<img src=\"https://uploadfiles.nowcoder.com/images/20160717/6316247_1468761643205_9F7B85AB04292CF73778D98998A20ED1\" alt=\"图片\"></h4><h4 id=\"h4-4-java-\"><a name=\"4.java内存模型   点击原文\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.java内存模型 <a href=\"http://blog.csdn.net/ns_code/article/details/17565503\">点击原文</a></h4><p><img src=\"https://uploadfiles.nowcoder.com/images/20161223/415611_1482452184396_6FB53C51539B47559CF0D122A832CF63\" alt=\"\"></p>\r\n<h4 id=\"h4-5-java-reference\"><a name=\"5.java中是没有指针的，有reference\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.java中是没有指针的，有reference</h4><p>第一：指针变量是在栈内存中，它也是有值的，这个值存储的就是地址单元，这个地址就是来自于赋值操作。<br>第二：指针变量有类型，这个类型（如Person）的含义是指针指向的变量在栈内存（不是很确定）中的范围（大小），我理解为是占用的堆内存空间。<br>第三：声明一个对象时，是对“指针变量”的定义。<br>第四：用new关键字在堆内存创建了对象，在赋值时，是把这个对象的首地址传给了这个“指针变量”（即引用型变量）。</p>\r\n<h4 id=\"h4-6-string-\"><a name=\"6.String生成常量\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6.String生成常量</h4><pre><code class=\"lang-java\">String s1=&quot;abc&quot;+&quot;def&quot;;//生成的是一个常量，放在堆内存中\r\nString s2=new String（s1);//s2是一个变量\r\nif(s1.equals(s2))//比较的是字符串的内容\r\n    System.out.println(&quot;.equals succeeded&quot;);//输出\r\nif(s1==s2)//比较的是内存地址，但s1是常量，所以不相等\r\n    System.out.println(&quot;==succeeded&quot;);\r\n</code></pre>\r\n<h4 id=\"h4-7-jsp-\"><a name=\"7.jsp内置对象和属性\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>7.jsp内置对象和属性</h4><p>（１）request对象<br>客户端的请求信息被封装在request对象中，通过它才能了解到客户的需求，然后做出响应。它是HttpServletRequest类的实例。<br>（２）response对象<br>response对象包含了响应客户请求的有关信息，但在JSP中很少直接用到它。它是HttpServletResponse类的实例。<br>（３）session对象<br>session对象指的是客户端与服务器的一次会话，从客户连到服务器的一个WebApplication开始，直到客户端与服务器断开连接为止。它是HttpSession类的实例.<br>（４）out对象<br>out对象是JspWriter类的实例,是向客户端输出内容常用的对象<br>（５）page对象<br>page对象就是指向当前JSP页面本身，有点象类中的this指针，它是java.lang.Object类的实例<br>（６）application对象<br>application对象实现了用户间数据的共享，可存放全局变量。它开始于服务器的启动，直到服务器的关闭，在此期间，此对象将一直存在；这样在用户的前后连接或不同用户之间的连接中，可以对此对象的同一属性进行操作；在任何地方对此对象属性的操作，都将影响到其他用户对此的访问。服务器的启动和关闭决定了application对象的生命。它是ServletContext类的实例。<br>（７）exception对象<br>exception对象是一个例外对象，当一个页面在运行过程中发生了例外，就产生这个对象。如果一个JSP页面要应用此对象，就必须把isErrorPage设为true，否则无法编译。他实际上是java.lang.Throwable的对象<br>（８）pageContext对象<br>pageContext对象提供了对JSP页面内所有的对象及名字空间的访问，也就是说他可以访问到本页所在的SESSION，也可以取本页面所在的application的某一属性值，他相当于页面中所有功能的集大成者，它的本 类名也叫pageContext。<br>（９）config对象<br>config对象是在一个Servlet初始化时，JSP引擎向它传递信息用的，此信息包括Servlet初始化时所要用到的参数（通过属性名和属性值构成）以及服务器的有关信息（通过传递一个ServletContext对象）</p>','2017-03-01',1,31,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(158,'2017-03-02学习笔记','知识点 一、static public class Spike\r\n{\r\n    public static void main(String[] args)\r\n    {\r\n        Counter a = new Counter();\r\n        System.out.println(a.increment());\r\n        System.out.println(a.anot','<h1 id=\"h1-u77E5u8BC6u70B9\"><a name=\"知识点\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>知识点</h1><h4 id=\"h4--static\"><a name=\"一、static\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、static</h4><pre><code class=\"lang-java\">public class Spike\r\n{\r\n    public static void main(String[] args)\r\n    {\r\n        Counter a = new Counter();\r\n        System.out.println(a.increment());\r\n        System.out.println(a.anotherIncrement());\r\n        Counter b = new Counter();\r\n        System.out.println(b.increment());\r\n    }\r\n}\r\nclass Counter\r\n{\r\n    private static int count = 0;\r\n    public int increment()\r\n    {\r\n        return count++;\r\n    }\r\n    public int anotherIncrement()\r\n    {\r\n        return ++count;\r\n    }\r\n}\r\n</code></pre>\r\n<p>count是静态变量，为所有对象所共享，因此不管a.increment()还是b.increment()都会使count持续增加。<br>increment()方法返回当前count值，然后count增加1<br>antoherIncrement()方法让count增加1，然后返回count值<br>第一次a.increment()返回值为0，此时count值为1<br>第二次a.anotherIncrement()先让count+1再返回，返回值为2<br>第三次b.increment()先返回count当前值2，然后count+1</p>\r\n<h4 id=\"h4--aop-\"><a name=\"二、AOP面向切面\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、AOP面向切面</h4><p>AOP的概念是Aspected Oriented Programming 面向方面编程。<br>  好处：AOP将程序分解成各个方面或者说关注点。这使得可以模块化，相当横向上分切了。它可以解决OOP和过程化方法不能够很好解决的横切（crosscut）问题，如：事务、安全、日志等横切关注。<br>  实现AOP有几种方式:<br>  1.Spring 1.2版本中通过ProxyFactoryBean来实现aop,即通过动态代理来实现的,Aspect必须继承MethodBeforeAdvice,MethodAfterAdvice等<br>  2.Spring 2.0 AOP需要改的是FBI 这个类，而且它也不需要再实现某些接口<br>  3.三使用标注（<a href=\"https://github.com/AspectJ\" title=\"&#64;AspectJ\" class=\"at-link\">@AspectJ</a>）实现AOP<br>    AOP 和 OOP的区别：</p>\r\n<pre><code>```html\r\n 1. 面向方面编程 AOP 偏重业务处理过程的某个步骤或阶段，强调降低模块之间的耦合度，使代码拥有更好的移植性。  \r\n 2. 面向对象编程 (oop) 则是对业务分析中抽取的实体进行方法和属性的封装。\r\n ```\r\n</code></pre><p>也可以说 AOP 是面向业务中的动词领域， OOP 面向名词领域。<br>AOP 的一个很重要的特点是源代码无关性，也就是说如果我们的系统中引用了 AOP 组件，即使我们把该组件去掉，系统代码也应该能够编译通过。要实现这一点，可以使用动态 proxy 模式。</p>\r\n<h4 id=\"h4--jdbc-\"><a name=\"三、jdbc桥接模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、jdbc桥接模式</h4><p>桥接模式：<br>定义 ：将抽象部分与它的实现部分分离，使它们都可以独立地变化。<br>意图 ：将抽象与实现解耦。<br>桥接模式所涉及的角色</p>\r\n<ol>\r\n<li>Abstraction ：定义抽象接口，拥有一个Implementor类型的对象引用</li><li>RefinedAbstraction ：扩展Abstraction中的接口定义</li><li>Implementor ：是具体实现的接口，Implementor和RefinedAbstraction接口并不一定完全一致，实际上这两个接口可以完全不一样Implementor提供具体操作方法，而Abstraction提供更高层次的调用</li><li>ConcreteImplementor ：实现Implementor接口，给出具体实现<br>Jdk中的桥接模式：JDBC<br>JDBC连接 数据库 的时候，在各个数据库之间进行切换，基本不需要动太多的代码，甚至丝毫不动，原因就是JDBC提供了统一接口，每个数据库提供各自的实现，用一个叫做数据库驱动的程序来桥接就行了<h4 id=\"h4--\"><a name=\"四、抽象类\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>四、抽象类</h4>抽象类和普通类有三点区别：<br>1）抽象方法必须为public和protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public。<br>2）抽象类不能用来创建对象，但是它可以有构造方法，用来帮助子类实例化。<br>3）如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为abstract类。<h4 id=\"h4--\"><a name=\"五、接口\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>五、接口</h4>接口的主要特点<br>1）接口中的成员变量默认都是public、static、final类型的，必须被显示初始化。<br>2）接口中的方法默认都是public、abstract类型的。<br>3）接口中只能包含public、static、final类型的成员变量和public、abstract类型的成员方法。<br>4）接口没有构造方法，不能被实例化。<br>5）一个接口不能实现另一个接口，但它可以继承多个其他接口。<br>6）接口必须通过类来实现它的抽象方法。<br>7）与子类继承抽象父类相似，当类实现了某个接口时，它必须实现接口中所有的抽象方法，否则这个类必须被定义为抽象类。<br>8）一个类只能继承一个直接的父类，但能实现多个接口。<h4 id=\"h4--\"><a name=\"六、抽象类和接口的区别\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>六、抽象类和接口的区别</h4>1）抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract方法；<br>2）抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；<br>3）接口中不能含有静态代码块以及静态方法，而抽象类尅有静态代码块和静态方法；<br>4）一个类只能继承一个抽象类，而一个类却可以实现多个接口。<br>5）抽象类中的方法子类必须全部实现，不然子类也是抽象类，而接口中的抽象方法子类必须全部实现，是可选择实现的。<br>6）抽象类是一种模板设计模式，而接口时一种行为规范。</li></ol>','2017-03-02',1,38,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(159,'2017-03-03学习笔记','一、String StringBuffer.toString()源码： @Override\r\npublic synchronized String toString() {\r\n    if (toStringCache == null) {\r\n        toStringCache = Arrays.copyOfRange(value, 0, count);\r\n    }\r\n    retur','<h4 id=\"h4--string\"><a name=\"一、String\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、String</h4><p>StringBuffer.toString()源码：</p>\r\n<pre><code class=\"lang-java\">@Override\r\npublic synchronized String toString() {\r\n    if (toStringCache == null) {\r\n        toStringCache = Arrays.copyOfRange(value, 0, count);\r\n    }\r\n    return new String(toStringCache, true);\r\n}\r\n</code></pre>\r\n<p>Arrays.copyOfRange用的是System.arraycopy</p>\r\n<pre><code class=\"lang-java\">public static char[] copyOfRange(char[] original, int from, int to) {\r\n        int newLength = to - from;\r\n        if (newLength &lt; 0)\r\n            throw new IllegalArgumentException(from + &quot; &gt; &quot; + to);\r\n        char[] copy = new char[newLength];\r\n        System.arraycopy(original, from, copy, 0,\r\n                         Math.min(original.length - from, newLength));\r\n        return copy;\r\n    }\r\n</code></pre>\r\n<p>1.String是值传入，不是引用传入。<br>2.String对String  类型进行改变的时候其实都等同于生成了一个新的  String  对象，然后将指针指向新的  String  对象，而不是StringBuffer；StringBuffer每次结果都会对  StringBuffer  对象本身进行操作，而不是生成新的对象，再改变对象引用。<br>3.效率比较String&lt;StringBuffer&lt;StringBuilder，但是在 String S1 = “This is only a” + “ simple” + “ test”时，String效率最高。</p>\r\n<h4 id=\"h4--jvm-\"><a name=\"二、jvm知识图谱\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、jvm知识图谱</h4><p><a href=\"https://zhuanlan.zhihu.com/p/25511795\">引用自知乎</a><br><img src=\"https://pic2.zhimg.com/v2-701563ac1fe745fc8e1234c96e82ac99_r.jpg\" alt=\"\"></p>\r\n<h4 id=\"h4--treemap-linkhashmap\"><a name=\"三、Treemap、LinkHashMap\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、Treemap、LinkHashMap</h4><p>1.TreeMap取出来的是排序后的键值对。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。<br>2.LinkedHashMap 是HashMap的一个子类，如果需要输出的顺序和输入的相同,那么用LinkedHashMap可以实现,它还可以按读取顺序来排列。</p>\r\n<h4 id=\"h4--sql-\"><a name=\"四、sql模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>四、sql模式</h4><p>MySQL数据库中，变量分为 系统变量（以”@@”开头）和用户自定义变量。系统变量分为全局系统变量(global)和会话系统变量(session)。<br>@<a href=\"https://github.com/global\" title=\"&#64;global\" class=\"at-link\">@global</a>     仅用于访问全局系统变量的值；<br>@<a href=\"https://github.com/session\" title=\"&#64;session\" class=\"at-link\">@session</a>  仅用于访问会话系统变量的值；<br>@@              先访问会话系统变量的值，若不存在则去访问全局系统变量的值；<br>sql_mode 为系统变量，既是全局系统变量，又是会话系统变量。</p>\r\n<h4 id=\"h4--\"><a name=\"五、代码的执行顺序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>五、代码的执行顺序</h4><p>父类Ｂ静态代码块-&gt;子类Ａ静态代码块-&gt;父类Ｂ非静态代码块-&gt;父类Ｂ构造函数-&gt;子类Ａ非静态代码块-&gt;子类Ａ构造函数<br><img src=\"http://ohlrxdl4p.bkt.clouddn.com/images/QQ截图20170303165728.jpg\" alt=\"\"></p>','2017-03-03',1,37,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(160,'ifhifhajfe','hello','<h1 id=\"h1-hello\"><a name=\"hello\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>hello</h1>','2017-03-05',1,34,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(161,'2017-03-05学习笔记','java的堆，栈，静态代码区（常量区） 详解','<p><a href=\"http://blog.csdn.net/u012031380/article/details/54981472\"> java的堆，栈，静态代码区（常量区） 详解</a></p>','2017-03-05',1,34,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(162,'java归并排序','package datastruct;\r\n\r\n/**\r\n * Created by Zephery on 2017/3/3.\r\n */\r\npublic class Solution {\r\n    public static void printArray(int[] arr, int i, int j) {\r\n        System.out.print(\"[\");\r\n        for','<pre><code class=\"lang-java\">package datastruct;\r\n\r\n/**\r\n * Created by Zephery on 2017/3/3.\r\n */\r\npublic class Solution {\r\n    public static void printArray(int[] arr, int i, int j) {\r\n        System.out.print(&quot;[&quot;);\r\n        for (int k = i; k &lt; j; k++) {\r\n            System.out.print(arr[k] + &quot;,&quot;);\r\n        }\r\n        System.out.print(arr[j] + &quot;]&quot;);\r\n    }\r\n\r\n    private static void mergesort(int[] arr, int i, int j) {\r\n        int mid = 0;\r\n        if (i &lt; j) {\r\n            mid = (i + j) / 2;\r\n            mergesort(arr, i, mid);\r\n            mergesort(arr, mid + 1, j);\r\n            merge(arr, i, mid, j);\r\n        }\r\n    }\r\n\r\n    private static void merge(int[] arr, int i, int mid, int j) {\r\n        System.out.print(&quot;Left:&quot;);\r\n        printArray(arr, i, mid);\r\n        System.out.println(&quot;Right:&quot;);\r\n        printArray(arr, mid + 1, j);\r\n        System.out.println();\r\n        int temp[] = new int[arr.length];\r\n        int l = i;\r\n        int r = j;\r\n        int m = mid + 1;\r\n        int k = l;\r\n        while (l &lt;= mid &amp;&amp; m &lt;= r) {\r\n            if (arr[l] &lt;= arr[m]) {\r\n                temp[k++] = arr[l++];\r\n            } else {\r\n                temp[k++] = arr[m++];\r\n            }\r\n        }\r\n        while (l &lt;= mid) {\r\n            temp[k++] = arr[l++];\r\n        }\r\n        while (m &lt;= r) {\r\n            temp[k++] = arr[m++];\r\n        }\r\n        for (int i1 = i; i1 &lt;= j; i1++) {\r\n            arr[i1] = temp[i1];\r\n        }\r\n        System.out.print(&quot;After Merge:&quot;);\r\n        printArray(arr, i, j);\r\n        System.out.println();\r\n    }\r\n\r\n    public static void main(String args[]) {\r\n        int[] arr = {9, 4, 8, 3, 1, 2, 5};\r\n        System.out.print(&quot;Initial Array:&quot;);\r\n        printArray(arr, 0, arr.length - 1);\r\n        System.out.println();\r\n        mergesort(arr, 0, arr.length - 1);\r\n    }\r\n}\r\n</code></pre>\r\n<pre><code class=\"lang-js\">Initial Array:[9,4,8,3,1,2,5]\r\nLeft:[9]Right:\r\n[4]\r\nAfter Merge:[4,9]\r\nLeft:[8]Right:\r\n[3]\r\nAfter Merge:[3,8]\r\nLeft:[4,9]Right:\r\n[3,8]\r\nAfter Merge:[3,4,8,9]\r\nLeft:[1]Right:\r\n[2]\r\nAfter Merge:[1,2]\r\nLeft:[1,2]Right:\r\n[5]\r\nAfter Merge:[1,2,5]\r\nLeft:[3,4,8,9]Right:\r\n[1,2,5]\r\nAfter Merge:[1,2,3,4,5,8,9]\r\n</code></pre>','2017-03-06',1,36,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(163,'2017-03-10学习笔记','1.Integer和int，装箱拆箱 1、基本型和基本型封装型进行“==”运算符的比较，基本型封装型将会自动拆箱变为基本型后再进行比较，因此Integer(0)会自动拆箱为int类型再进行比较，显然返回true； 2、两个Integer类型进行“==”比较，如果其值在-128至127，那么返回true，否则返回false, 这跟Integer.valueOf()的缓冲对象有关，这里不进行赘述。 3','<h1 id=\"h1-1-integer-int-\"><a name=\"1.Integer和int，装箱拆箱\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.Integer和int，装箱拆箱</h1><p>1、基本型和基本型封装型进行“==”运算符的比较，基本型封装型将会自动拆箱变为基本型后再进行比较，因此Integer(0)会自动拆箱为int类型再进行比较，显然返回true；<br>2、两个Integer类型进行“==”比较，如果其值在-128至127，那么返回true，否则返回false, 这跟Integer.valueOf()的缓冲对象有关，这里不进行赘述。<br>3、两个基本型的封装型进行equals()比较，首先equals()会比较类型，如果类型相同，则继续比较值，如果值也相同，返回true<br>4、基本型封装类型调用equals(),但是参数是基本类型，这时候，先会进行自动装箱，基本型转换为其封装类型，再进行3中的比较。</p>\r\n<pre><code class=\"lang-java\">int a=257;\r\nInteger b=257;\r\nInteger c=257;\r\nInteger b2=57;\r\nInteger c2=57;\r\nSystem.out.println(a==b);\r\n//System.out.println(a.equals(b));  编译出错，基本型不能调用equals()\r\nSystem.out.println(b.equals(257.0));\r\nSystem.out.println(b==c);\r\nSystem.out.println(b2==c2);\r\n</code></pre>\r\n<p>因此上面的代码的结果因此为 true, false, false, true</p>\r\n<h1 id=\"h1-2-\"><a name=\"2.线程调度\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.线程调度</h1><p>分为协同式调度和抢占式调度，Java使用的是抢占式调度，也就是每个线程将由操作系统来分配执行时间，线程的切换不由线程本身来决定（协同式调度）。这就是平台独立的原因。</p>\r\n<h1 id=\"h1-3-\"><a name=\"3.重载，重写\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.重载，重写</h1><p>重写：<br>两同，两小，一大<br>两同：方法名，方法参数列表相同。<br>两小：抛出的异常类型要小于等于父类，返回值类型要小于等于父类<br>一大：访问权限大于等于父类。<br>重载：<br>在同一个类中，方法名和方法参数列表不同，其他的（访问权限、返回值）随意。</p>\r\n<h1 id=\"h1-4-jvm-\"><a name=\"4.  JVM面试题\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.<a href=\"http://blog.csdn.net/hsk256/article/details/49104955\">JVM面试题</a></h1>','2017-03-10',1,31,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(164,'2017-03-12学习笔记','1.继承的加载顺序 执行顺序大体上可以说是先父类后子类，父类static域 ==》子类static域 ==》父类数据成员域 ==》父类构造器 ==》子类数据成员域 ==》子类构造器 2.优化Hibernate所鼓励的7大措施： 1.尽量使用many-to-one，避免使用单项one-to-many 2.灵活使用单向one-to-many 3.不用一对一，使用多对一代替一对一 4.配置对象缓存，不使','<h4 id=\"h4-1-\"><a name=\"1.  继承的加载顺序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.<a href=\"http://www.cnblogs.com/SirSmith/p/5536288.html\">继承的加载顺序</a></h4><p><img src=\"http://images2015.cnblogs.com/blog/452847/201605/452847-20160527221410288-2119099273.png\" alt=\"\"></p>\r\n<p>执行顺序大体上可以说是先父类后子类，父类static域 ==》子类static域 ==》父类数据成员域 ==》父类构造器 ==》子类数据成员域 ==》子类构造器</p>\r\n<h4 id=\"h4-2-hibernate-7-\"><a name=\"2.优化Hibernate所鼓励的7大措施：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.优化Hibernate所鼓励的7大措施：</h4><p>1.尽量使用many-to-one，避免使用单项one-to-many<br>2.灵活使用单向one-to-many<br>3.不用一对一，使用多对一代替一对一<br>4.配置对象缓存，不使用集合缓存<br>5.一对多使用Bag 多对一使用Set<br>6.继承使用显示多态 HQL:from object polymorphism=”exlicit” 避免查处所有对象<br>7.消除大表，使用二级缓存</p>\r\n<h4 id=\"h4-3-java-\"><a name=\"3.java中的数据类型分类：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.java中的数据类型分类：</h4><p>基本数据类型（或叫做原生类、内置类型）8种：<br>    整数：byte，short，int，long（默认是int类型）<br>    浮点类型： float，double（默认是double类型）<br>    字符类型：char<br>    布尔类型：boolean<br>引用数据类型3种：数组，类，接口</p>\r\n<h4 id=\"h4-4-\"><a name=\"4.触发器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.触发器</h4><p>drop trigger 删除触发器<br>Drop用于删除数据表或数据库，或删除数据表字段。<br>remove：删除数据库文件<br>Truncate：删除数据表中的数据（仅数据表中的数据，不删除表）。</p>','2017-03-12',1,26,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(165,'2017-03-14学习笔记','1.Servlet的生命周期分为5个阶段：加载、创建、初始化、处理客户请求、卸载。 (1)加载：容器通过类加载器使用servlet类对应的文件加载servlet (2)创建：通过调用servlet构造函数创建一个servlet对象 (3)初始化：调用init方法初始化 (4)处理客户请求：每当有一个客户请求，容器会创建一个线程来处理客户请求 (5)卸载：调用destroy方法让servlet自己释','<h4 id=\"h4-1-servlet-5-\"><a name=\"1.Servlet的生命周期分为5个阶段：加载、创建、初始化、处理客户请求、卸载。\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.Servlet的生命周期分为5个阶段：加载、创建、初始化、处理客户请求、卸载。</h4><p>(1)加载：容器通过类加载器使用servlet类对应的文件加载servlet<br>(2)创建：通过调用servlet构造函数创建一个servlet对象<br>(3)初始化：调用init方法初始化<br>(4)处理客户请求：每当有一个客户请求，容器会创建一个线程来处理客户请求<br>(5)卸载：调用destroy方法让servlet自己释放其占用的资源</p>\r\n<h4 id=\"h4-2-jsp\"><a name=\"2.JSP\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.JSP</h4><p><img src=\"http://uploadfiles.nowcoder.com/images/20160308/595432_1457414324036_C3D4EB7F2D61708D0C0BE2921A45B74D\" alt=\"\"></p>','2017-03-14',1,22,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(166,'2017-03-17学习笔记','1.GC线程是否和守护线程 2.java堆排序','<h4 id=\"h4-1-gc-\"><a name=\"1.GC线程是否和守护线程\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.GC线程是否和守护线程</h4><h4 id=\"h4-2-java-\"><a name=\"2.java堆排序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.java堆排序</h4>','2017-03-17',1,21,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(167,'春招~好失落啊','自己的情况：广东人，大学跑到天津一所二本学校，网络工程专业，大一大二学ccna、ccnp，发现没有创造性，按着别人的死规定敲命令好无聊，大三彻底转向编程，c++看着不爽，调研一番后选择java，自学java和java web，对jsp、servlet略过，直接上手框架（Struts，hibernate，spring），看书，找视频，敲项目，非专业课（操作系统，数据库等）不听，捣鼓一番觉得还行，继续','<p>自己的情况：广东人，大学跑到天津一所二本学校，网络工程专业，大一大二学ccna、ccnp，发现没有创造性，按着别人的死规定敲命令好无聊，大三彻底转向编程，c++看着不爽，调研一番后选择java，自学java和java web，对jsp、servlet略过，直接上手框架（Struts，hibernate，spring），看书，找视频，敲项目，非专业课（操作系统，数据库等）不听，捣鼓一番觉得还行，继续学习spring mvc，mybatis，开始了解hadoop、spark，同时搭了自己的网站，跟了软件工程的同学比了比，还能算上前列吧，当然，基础和算法跟前列的人还没得比~~~</p>\r\n<p>去年秋招，腾讯、阿里等笔试全挂，京东的没怎么做却过了，不敢去面试（真心没怎么做题），最后去了北京一家创业公司实习了三个月多，感觉真心好，12月几乎整整一个月雾霾，受不了，还是回广东吧。在家过了春节，2月10号跟同学一起来深圳，就这样，开始了春招之旅~~~~</p>\r\n<p>第一家，面试的问的差不多全答对，手写了几个sql也对了，不过居然没有问hashmap，给的工资6000到9000，想了想，还是不去的好，太郊区，后来一查，是个培训兼外包的企业，还好没去。。。。</p>\r\n<p>第二家，某ERP公司，额，笔试，全是sql，做了，感觉还可以，面试直接说我们公司不用java，用的一个小众语言，薪资应届生只有3500，直接走人。。。。</p>\r\n<p>第三家，找工作，对广东真是彻底失望了，投的简历除了培训机构理你，其他的都不理人的，无奈之下投了北京的一家创业公司（A轮），薪资1万，电话面试，过了。。。。。后来想想，还是不去北京了，虽然工资高，但是没有朋友，过得像个死人一样。</p>\r\n<p>第四家，深圳一家创业公司，做东南亚社交软件的，可惜薪资没谈成，4K-6K，这可是深圳啊。。。。</p>\r\n<p>第五家，广州凡科，那天一早就从深圳跑过去，没吃饭，下午到就做笔试题，头晕，手抖，然后一面就是跟你讲笔试题，讲了两道，就叫我走了。。。仅仅半个小时，广深来回6个小时。。。</p>\r\n<p>第六家，广州某搞运维的公司，笔试差不多答对，面试问的问题也答对，但是没给offer。。。不理解</p>\r\n<p>第七家，然后晚上跑去了广工的久邦数码宣讲，试卷发到我这的时候，HR说我这方向的试卷没带够。。。。无奈向他要了大数据的题，全是数据库的题，过几天后得知居然过了，然后一面，问的问题没啥印象，除了left join的原理没答对。。。今天得知挂了。。。。</p>\r\n<p><img src=\"http://images2015.cnblogs.com/blog/755525/201703/755525-20170318000537838-305991370.png\" alt=\"\"></p>\r\n<p>第八家，极天信息（A轮），笔试的题目没看懂它问的啥，一面没啥印象了，然后是经理面，说广州没那么高的工资（7000），等消息，估计也没谈成。。。。</p>\r\n<p>第九家，中国移动，最气的了，一面就是HR面，问了两个问题，为什么不在北京留着，你觉得相比其他人你有什么优势。我只能说我真不会说话更不知怎么回答，就强调勤奋，然后直接被HR叫走人了，3分钟=w=</p>\r\n<p>第十家，珍爱网，找别人内推的，三个问题没答上来，就不跟你们说了，亲爱的竞争对手们=w=，谈了四十分钟吧，出来后感觉很不好，估计也是挂了。。。</p>\r\n<p>今天晚上，收到了久邦数码的拒绝信，瞬间觉得好无奈好迷茫，有时候就那么一个简简单单的问题，答不好就直接拒绝的，改怎么心平气和的面对下一个面试。有时候真不理解公司是怎么招人的，是不是真的“把部分简历扔进垃圾桶，不招那些运气不好的人”？也只能这么安慰自己。可是，事实呢？</p>\r\n<p><img src=\"http://images2015.cnblogs.com/blog/755525/201703/755525-20170318001336463-1583022291.jpg\" alt=\"\"></p>\r\n<p>这些天，有时间都是往深圳图书馆跑，看书，刷牛客网，补算法，看源码，做了这么多，该怎么告诉自己不要放弃。。。。。开始有点想念北京的雾霾</p>','2017-03-18',5,23,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(168,'数据库','1.SQL执行的顺序 2.NULL “空值” 和”NULL”的概念： 1：空值(‘’)是不占用空间的,判断空字符用 = ‘’ 或者 <> ‘’ 来进行处理; 2: NULL值是未知的，且占用空间，不走索引;判断 NULL 用 IS NULL 或者 is not null , SQL 语句函数中可以使用 ifnull ()函数来进行处理. 注：在进行 count ()统计某列的记录数的时候，如果采用','<h4 id=\"h4-1-sql-\"><a name=\"1.SQL执行的顺序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.SQL执行的顺序</h4><p><img src=\"http://uploadfiles.nowcoder.com/images/20150828/415611_1440751995009_3B3E1329A400F0022B20C4F32AEFC9EF\" alt=\"\"></p>\r\n<h4 id=\"h4-2-null\"><a name=\"2.NULL\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.NULL</h4><p>“空值” 和”NULL”的概念：<br>  1：空值(‘’)是不占用空间的,判断空字符用 = ‘’ 或者 &lt;&gt; ‘’ 来进行处理;<br> 2: NULL值是未知的，且占用空间，不走索引;判断 NULL 用 IS NULL 或者 is not null , SQL 语句函数中可以使用 ifnull ()函数来进行处理.<br>注：在进行 count ()统计某列的记录数的时候，如果采用的 NULL 值，会别系统自动忽略掉，但是空值是统计到其中</p>\r\n<h4 id=\"h4-3-\"><a name=\"3.\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.</h4><p>在MySQL数据库中，NULL对于一些特殊类型的列来说，其代表了一种特殊的含义，而不仅仅是一个空值。<br>IS NULL: 此运算符返回true，当列的值是NULL。<br>IS NOT NULL: 运算符返回true，当列的值不是NULL。<br>&lt;=&gt; 操作符比较值（不同于=运算符）为ture，即使两个NULL值<br>涉及NULL条件是特殊的。不能使用 =NULL 或 !=NULL 寻找NULL值的列</p>\r\n<h4 id=\"h4-4-nf\"><a name=\"4.NF\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.NF</h4><p>第一范式（   1NF   ）：   字段具有   原子性   ,   不可再分   。所有关系型数据库系统都满足第一范式）数据库表中的字段都是单一属性的，不可再分。例如，姓名字段，其中的姓和名必须作为一个整体，无法区分哪部分是姓，哪部分是名，如果要区分出姓和名，必须设计成两个独立的字段。<br>第二范式（   2NF   ）：   第二范式（   2NF   ）是在   第一范式（   1NF   ）的基础上   建立起来的，即满足第二范式（   2NF   ）必须先满足第一范式（   1NF   ）。要求   数据库表中的每个实例或行必须可以被惟一地区分   。通常需要为表加上一个列，以存储各个实例的惟一标识。这个惟一属性列被称为   主关键字或主键   。<br>        第二范式（   2NF   ）要求   实体的属性完全依赖于主关键字   。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。简而言之，第二范式就是非主属性非部分依赖于主关键字。<br>第三范式 （  3NF  ） ：   满足第三范式（   3NF   ）   必须先满足第二范式（   2NF   ）   。简而言之，第三范式（   3NF   ）要求一个数据库表中   不包含   已在其它表中   已包含的非主关键字信息   。所以第三范式具有如下特征：<br>1   ，每一列只有一个值<br>2   ，每一行都能区分。<br>3   ，每一个表都   不包含其他表已经包含   的非主关键字信息。<br>例如，帖子表中只能出现发帖人的   id   ，而不能出现发帖人的   id   ，还同时出现发帖人姓名，否则，只要出现同一发帖人   id   的所有记录，它们中的姓名部分都必须严格保持一致，这就是   数据冗余   。</p>','2017-03-18',3,20,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(169,'重载与重写','目前的问题：父类的功能无法满足子类的需求。 方法重写的前提： 必须要存在继承的关系。 方法的重写: 子父类出了同名的函数，这个我们就称作为方法的重写。 什么是时候要使用方法的重写：父类的功能无法满足子类的需求时。 方法重写要注意的事项： 1.方法重写时， 方法名与形参列表必须一致。 2.方法重写时，子类的权限修饰符必须要大于或者等于父类的权限修饰符。 3.方法重写时，子类的返回值类型必须要小于或者','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><p>目前的问题：父类的功能无法满足子类的需求。</p>\n<p>方法重写的前提： 必须要存在继承的关系。</p>\n<p>方法的重写: 子父类出了同名的函数，这个我们就称作为方法的重写。</p>\n<p>什么是时候要使用方法的重写：父类的功能无法满足子类的需求时。</p>\n<p>方法重写要注意的事项：<br>    1.方法重写时， 方法名与形参列表必须一致。<br>    2.方法重写时，子类的权限修饰符必须要大于或者等于父类的权限修饰符。<br>    3.方法重写时，子类的返回值类型必须要小于或者 等于父类的返回值类型。<br>    4.方法重写时， 子类抛出的异常类型要小于或者等于父类抛出的异常类型。<br>            Exception(最坏)<br>            RuntimeException(小坏)</p>\n<p>方法的重载：在一个类中 存在两个或者两个 以上的同名函数,称作为方法重载。</p>\n<p>方法重载的要求</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"lit\">1.</span><span class=\"pln\"> </span><span class=\"pun\">函数名要一致。</span></code></li><li class=\"L1\"><code><span class=\"lit\">2.</span><span class=\"pln\"> </span><span class=\"pun\">形参列表不一致（形参的个数或形参</span><span class=\"pln\"> </span><span class=\"pun\">的类型不一致）</span></code></li><li class=\"L2\"><code><span class=\"lit\">3.</span><span class=\"pln\"> </span><span class=\"pun\">与返回值类型无关。</span></code></li></ol></pre></div>','2017-03-21',1,20,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(170,'垃圾回收算法','垃圾回收算法 1、标记-清除算法 2、复制算法 3、标记-整理算法 一、标记-清除算法 标记-清除算法采用从根集合进行扫描，对存活的对象对象标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收，如上图所示。 标记-清除算法不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效，但由于标记-清除算法直接回收不存活的对象，因此会造成内存碎片！ 二、复制算法 复制算法','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h2 id=\"h2-u5783u573Eu56DEu6536u7B97u6CD5\"><a name=\"垃圾回收算法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>垃圾回收算法</h2><p>1、标记-清除算法<br>2、复制算法<br>3、标记-整理算法</p>\n<h4 id=\"h4--\"><a name=\"一、标记-清除算法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、标记-清除算法</h4><p><img src=\"http://dl2.iteye.com/upload/attachment/0075/0386/29ae17ad-f8af-38b4-9e25-28ef3550858f.jpg\" alt=\"\">标记-清除算法采用从根集合进行扫描，对存活的对象对象标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收，如上图所示。<br>标记-清除算法不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效，但由于标记-清除算法直接回收不存活的对象，因此会造成内存碎片！</p>\n<h4 id=\"h4--\"><a name=\"二、复制算法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、复制算法</h4><p><img src=\"http://dl2.iteye.com/upload/attachment/0075/0388/91a656d4-f08a-377b-8eea-5785c2932533.jpg\" alt=\"\"><br>复制算法采用从根集合扫描，并将存活对象复制到一块新的，没有使用过的空间中，这种算法当控件存活的对象比较少时，极为高效，但是带来的成本是需要一块内存交换空间用于进行对象的移动。也就是我们前面提到的s0 s1等空间。</p>\n<h4 id=\"h4--\"><a name=\"三、标记-整理算法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、标记-整理算法</h4><p><img src=\"http://dl2.iteye.com/upload/attachment/0075/0390/6ba95f80-c7bc-3d09-b927-ac09297e9920.jpg\" alt=\"\"><br> 标记-整理算法采用标记-清除算法一样的方式进行对象的标记，但在清除时不同，在回收不存活的对象占用的空间后，会将所有的存活对象往左端空闲空间移动，并更新对应的指针。标记-整理算法是在标记-清除算法的基础上，又进行了对象的移动，因此成本更高，但是却解决了内存碎片的问题。</p>\n</div>','2017-04-09',1,17,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(171,'java分代回收','一、新生代内存的回收（minor GC）主要采用复制算法，下图展示了minor GC的执行过程。 二、对于新生代和旧生代，JVM可使用很多种垃圾回收器进行垃圾回收，下图展示了不同生代不通垃圾回收器，其中两个回收器之间有连线表示这两个回收器可以同时使用。 而这些垃圾回收器又分为串行回收方式、并行回收方式合并发回收方式执行，分别运用于不同的场景。如下图所示 三、收集器 1.Serial收集器 看名字我','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h2 id=\"h2--minor-gc-minor-gc-\"><a name=\"一、新生代内存的回收（minor GC）主要采用复制算法，下图展示了minor GC的执行过程。\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、新生代内存的回收（minor GC）主要采用复制算法，下图展示了minor GC的执行过程。</h2><p><img src=\"http://dl2.iteye.com/upload/attachment/0075/0392/732c7557-aa9a-3551-b14d-f543c5b0c94b.jpg\" alt=\"\"></p>\n<h2 id=\"h2--jvm-\"><a name=\"二、对于新生代和旧生代，JVM可使用很多种垃圾回收器进行垃圾回收，下图展示了不同生代不通垃圾回收器，其中两个回收器之间有连线表示这两个回收器可以同时使用。\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、对于新生代和旧生代，JVM可使用很多种垃圾回收器进行垃圾回收，下图展示了不同生代不通垃圾回收器，其中两个回收器之间有连线表示这两个回收器可以同时使用。</h2><p><img src=\"http://dl2.iteye.com/upload/attachment/0075/0394/0172f624-9018-3642-bf26-05a2c3071639.jpg\" alt=\"\"><br>而这些垃圾回收器又分为串行回收方式、并行回收方式合并发回收方式执行，分别运用于不同的场景。如下图所示<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0396/c962c2ad-273f-3de4-b2e3-a4dd8b946215.jpg\" alt=\"\"></p>\n<h2 id=\"h2--\"><a name=\"三、收集器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、收集器</h2><h4 id=\"h4-1-serial-\"><a name=\"1.Serial收集器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.Serial收集器</h4><p>看名字我们都可以看的出来，这个属于串行收集器。其运行示意图如下<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0398/681da5ca-5eff-3984-bece-3d80dfe905be.jpg\" alt=\"\"><br>    收集器是历史最悠久的一个回收器，JDK1.3之前广泛使用这个收集器，目前也是ClientVM下 ServerVM 4核4GB以下机器的默认垃圾回收器。串行收集器并不是只能使用一个CPU进行收集，而是当JVM需要进行垃圾回收的时候，需要中断所有的用户线程，知道它回收结束为止，因此又号称“Stop The World” 的垃圾回收器。注意，JVM中文名称为java虚拟机，因此它就像一台虚拟的电脑一样在工作，而其中的每一个线程就被认为是JVM的一个处理器，因此大家看到图中的CPU0、CPU1实际为用户的线程，而不是真正机器的CPU，大家不要误解哦。<br>    串行回收方式适合低端机器，是Client模式下的默认收集器，对CPU和内存的消耗不高，适合用户交互比较少，后台任务较多的系统。<br>    Serial收集器默认新旧生代的回收器搭配为Serial+ SerialOld</p>\n<h4 id=\"h4-2-parnew-\"><a name=\"2.ParNew收集器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.ParNew收集器</h4><p>ParNew收集器其实就是多线程版本的Serial收集器，其运行示意图如下<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0400/6443b39c-ed33-3d93-a690-87e646439561.jpg\" alt=\"\"><br>同样有Stop The World的问题，他是多CPU模式下的首选回收器（该回收器在单CPU的环境下回收效率远远低于Serial收集器，所以一定要注意场景哦），也是Server模式下的默认收集器。</p>\n<h4 id=\"h4-3-parallelscavenge\"><a name=\"3.ParallelScavenge\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.ParallelScavenge</h4><p>ParallelScavenge又被称为是吞吐量优先的收集器，器运行示意图如下<br><img src=\"http://dl.iteye.com/upload/attachment/0075/0402/5007beba-0b0e-3cf4-b146-c28b6c0dd696.jpg\" alt=\"\"><br> ParallelScavenge<br>所提到的吞吐量=程序运行时间/(JVM执行回收的时间+程序运行时间),假设程序运行了100分钟，JVM的垃圾回收占用1分钟，那么吞吐量就是99%。在当今网络告诉发达的今天，良好的响应速度是提升用户体验的一个重要指标，多核并行云计算的发展要求程序尽可能的使用CPU和内存资源，尽快的计算出最终结果，因此在交互不多的云端，比较适合使用该回收器。</p>\n<h4 id=\"h4-4-parallelold\"><a name=\"4.ParallelOld\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.ParallelOld</h4><p>ParallelOld是老生代并行收集器的一种，使用标记整理算法、是老生代吞吐量优先的一个收集器。这个收集器是JDK1.6之后刚引入的一款收集器，我们看之前那个图之间的关联关系可以看到，早期没有ParallelOld之前，吞吐量优先的收集器老生代只能使用串行回收收集器，大大的拖累了吞吐量优先的性能，自从JDK1.6之后，才能真正做到较高效率的吞吐量优先。其运行示意图如下<br><img src=\"http://dl.iteye.com/upload/attachment/0075/0406/9a14da85-f943-3408-ba88-c6bb3842a792.jpg\" alt=\"\"></p>\n<h4 id=\"h4-5-serialold\"><a name=\"5.SerialOld\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.SerialOld</h4><p>SerialOld是旧生代Client模式下的默认收集器，单线程执行；在JDK1.6之前也是ParallelScvenge回收新生代模式下旧生代的默认收集器，同时也是并发收集器CMS回收失败后的备用收集器。其运行示意图如下<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0404/ce7aabd5-b0e0-3cda-9b6c-607cf6ebf689.jpg\" alt=\"\"></p>\n<h4 id=\"h4-5-cms\"><a name=\"5.CMS\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.CMS</h4><p>CMS又称响应时间优先(最短回收停顿)的回收器，使用并发模式回收垃圾，使用标记-清除算法，CMS对CPU是非常敏感的，它的回收线程数=（CPU+3）/4，因此当CPU是2核的实惠，回收线程将占用的CPU资源的50%，而当CPU核心数为4时仅占用25%。他的运行示意图如下<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0408/4239228b-879f-382f-81c6-5c32799886d6.jpg\" alt=\"\"><br>模式主要分为四个过程：<br>1.初始标记<br>2.并发标记<br>3.重新标记<br>4.并发清除<br>在初始标记的时候，需要中断所有用户线程，在并发标记阶段，用户线程和标记线程<br>并发执行，而在这个过程中，随着内存引用关系的变化，可能会发生原来标记的对象被释放，进而引发新的垃圾，因此可能会产生一系列的浮动垃圾，不能被回收。</p>\n<p>CMS 为了确保能够扫描到所有的对象，避免在Initial Marking 中还有未标识到的对象，采用的方法为找到标记了的对象，并将这些对象放入Stack 中，扫描时寻找此对象依赖的对象，如果依赖的对象的地址在其之前，则将此对象进行标记，并同时放入Stack 中，如依赖的对象地址在其之后，则仅标记该对象。<br>在进行Concurrent Marking 时minor GC 也可能会同时进行，这个时候很容易造成旧生代对象引用关系改变，CMS 为了应对这样的并发现象，提供了一个Mod Union Table 来进行记录，在这个Mod Union Table中记录每次minor GC 后修改了的Card 的信息。这也是ParallelScavenge不能和CMS一起使用的原因。<br>CMS产生浮动垃圾的情况请见如下示意图<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0410/60e7c659-790a-3405-af70-9ca4cfd9258d.jpg\" alt=\"\"><br>在运行回收过后，c就变成了浮动垃圾。<br>由于CMS会产生浮动垃圾，当回收过后，浮动垃圾如果产生过多，同时因为使用标记-清除算法会产生碎片，可能会导致回收过后的连续空间仍然不能容纳新生代移动过来或者新创建的大资源，因此会导致CMS回收失败，进而触发另外一次FULL GC，而这时候则采用SerialOld进行二次回收。<br>同时CMS因为可能产生浮动垃圾，而CMS在执行回收的同时新生代也有可能在进行回收操作，为了保证旧生代能够存放新生代转移过来的数据，CMS在旧生代内存到达全部容量的68%就触发了CMS的回收！</p>\n<h4 id=\"h4-7-garbagefirst-g1-\"><a name=\"7.GarbageFirst(G1)\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>7.GarbageFirst(G1)</h4><p>我们再来看垃圾回收器的总图，刚才我们可以看到，我在图上标记了一个？，其实这是一个新的垃圾回收器，既可以回收新生代也可以回收旧生代，SunHotSpot 1.6u14以上EarlyAccess版本加入了这个回收器，sun公司预期SunHotSpot1.7发布正式版，他是商用高性能垃圾回收器，通过重新划分内存区域，整合优化CMS，同时注重吞吐量和响应时间，但是杯具的是被Oracle收购之后这个收集器属于商用收费收集器，因此目前基本上没有人使用，我们在这里也就不多介绍，更多信息可以参考oracle新版本JDK说明。</p>\n</div>','2017-04-09',1,16,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(172,'java汇编','java 汇编 http://download.csdn.net/download/jiangfuqiang/8403497','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><p>java 汇编<br><a href=\"http://download.csdn.net/download/jiangfuqiang/8403497\">http://download.csdn.net/download/jiangfuqiang/8403497</a></p>\n</div>','2017-04-10',1,16,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(173,'jvm','-XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><p>-XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly</p>\n</div>','2017-04-10',1,18,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(174,'Adaboost','NaiveBayesSpamFilter 利用朴素贝叶斯算法实现垃圾邮件的过滤，并结合Adaboost改进该算法。 1 Naive Bayes spam filtering   假设邮件的内容中包含的词汇为Wi，垃圾邮件Spam，正常邮件ham。 判断一份邮件，内容包含的词汇为Wi，判断该邮件是否是垃圾邮件，即计算P（S|Wi）这个条件概率。根据Bayes’ theorem：   Bayes’ t','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h1 id=\"h1-naivebayesspamfilter\"><a name=\"NaiveBayesSpamFilter\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>NaiveBayesSpamFilter</h1><p>利用朴素贝叶斯算法实现垃圾邮件的过滤，并结合Adaboost改进该算法。</p>\n<h3 id=\"h3-1-naive-bayes-spam-filtering\"><a name=\"1 Naive Bayes spam filtering\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1 Naive Bayes spam filtering</h3><p>  假设邮件的内容中包含的词汇为Wi，垃圾邮件Spam，正常邮件ham。 判断一份邮件，内容包含的词汇为Wi，判断该邮件是否是垃圾邮件，即计算P（S|Wi）这个条件概率。根据Bayes’ theorem：</p>\n<p>  Bayes’ theorem</p>\n<p>  其中：</p>\n<p>Pr(S|Wi) 出现词汇Wi的邮件是垃圾邮件的条件概率（即后验概率）；<br>Pr(S) 训练阶段邮件数据集中垃圾邮件的概率，或实际调查的垃圾邮件的概率（即先验概率）；<br>Pr(Wi|S) 垃圾邮件中词汇Wi出现的概率；<br>Pr(H) 训练阶段邮件数据集中正常邮件的概率，或实际调查的正常邮件的概率；<br>Pr(Wi|H) 正常邮件中词汇Wi出现的概率；<br>  对于邮件中出现的所有词汇，考虑每个词汇出现事件的独立性，计算Pr(S|Wi)的联合概率Pr(S|W)，W={W1，W2，…Wn}：</p>\n<p>  Bayes’ theorem</p>\n<p>  其中：</p>\n<p>P 即Pr(S|W)，出现词汇W={W1，W2……Wn}的邮件是垃圾邮件的条件概率；<br>Pi 即Pr(S|Wi)，出现词汇Wi的邮件是垃圾邮件的条件概率；<br>  注： 程序中，通过计算出Pr(S|W)和Pr(H|W)，比较Pr(S|W)和Pr(H|W)的大小，判断是垃圾邮件还是正常邮件。我们发现Pr(S|W)和Pr(H|W)计算的分母相同，所以我们只需要比较分子即可。</p>\n<p>  但存在两个问题：</p>\n<p>当词汇不存在时，即ni=0，此时Pr(S|Wi) = 0，会造成P=0，无法比较<br>当Pr(S|Wi)较小时，连乘操作会造成下溢出问题<br>  解决方案：</p>\n<p>计算P(Wi|S)和P(Wi|H)时，将所有词汇初始化出现的次数为1，并将分母初始化为2（或根据样本/实际调查结果调整分母的值）。</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"com\"># 统计语料库中词汇在S和H中出现的次数</span></code></li><li class=\"L1\"><code><span class=\"pln\">wordsInSpamNum </span><span class=\"pun\">=</span><span class=\"pln\"> np</span><span class=\"pun\">.</span><span class=\"pln\">ones</span><span class=\"pun\">(</span><span class=\"pln\">numWords</span><span class=\"pun\">)</span></code></li><li class=\"L2\"><code><span class=\"pln\">wordsInHealthNum </span><span class=\"pun\">=</span><span class=\"pln\"> np</span><span class=\"pun\">.</span><span class=\"pln\">ones</span><span class=\"pun\">(</span><span class=\"pln\">numWords</span><span class=\"pun\">)</span></code></li><li class=\"L3\"><code><span class=\"pln\">spamWordsNum </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">2.0</span></code></li><li class=\"L4\"><code><span class=\"pln\">healthWordsNum </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">2.0</span></code></li></ol></pre><p>计算P(Wi|S)和P(Wi|H)时，对概率取对数<br>    pWordsSpamicity = np.log(wordsInSpamNum / spamWordsNum)<br>    pWordsHealthy = np.log(wordsInHealthNum / healthWordsNum)<br>  所以最终比较的是，P(W1|S)P(W2|S)….P(Wn|S)P(S)和P(W1|H)P(W2|H)….P(Wn|H)P(H)的大小。</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"pln\">ps </span><span class=\"pun\">=</span><span class=\"pln\"> sum</span><span class=\"pun\">(</span><span class=\"pln\">testWordsMarkedArray </span><span class=\"pun\">*</span><span class=\"pln\"> pWordsSpamicity</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">+</span><span class=\"pln\"> np</span><span class=\"pun\">.</span><span class=\"pln\">log</span><span class=\"pun\">(</span><span class=\"pln\">pSpam</span><span class=\"pun\">)</span></code></li><li class=\"L1\"><code><span class=\"pln\">ph </span><span class=\"pun\">=</span><span class=\"pln\"> sum</span><span class=\"pun\">(</span><span class=\"pln\">testWordsMarkedArray </span><span class=\"pun\">*</span><span class=\"pln\"> pWordsHealthy</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">+</span><span class=\"pln\"> np</span><span class=\"pun\">.</span><span class=\"pln\">log</span><span class=\"pun\">(</span><span class=\"lit\">1</span><span class=\"pln\"> </span><span class=\"pun\">-</span><span class=\"pln\"> pSpam</span><span class=\"pun\">)</span></code></li></ol></pre><p>  测试效果： 5574个样本，采用交叉验证，随机选取4574个作为训练样本，产生词汇列表（语料库），对1000个测试样本，分类的平均错误率约为：2.5%。</p>\n<h3 id=\"h3-2-running-adaboost-on-naive-bayes\"><a name=\"2 Running Adaboost on Naive Bayes\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2 Running Adaboost on Naive Bayes</h3><p>  我们在计算ps和ph联合后验概率时，可引入一个调整因子DS，其作用是调整词汇表中某一词汇的“垃圾程度”(spamicity)，</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"pln\">ps </span><span class=\"pun\">=</span><span class=\"pln\"> sum</span><span class=\"pun\">(</span><span class=\"pln\">testWordsMarkedArray </span><span class=\"pun\">*</span><span class=\"pln\"> pWordsSpamicity </span><span class=\"pun\">*</span><span class=\"pln\"> DS</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">+</span><span class=\"pln\"> np</span><span class=\"pun\">.</span><span class=\"pln\">log</span><span class=\"pun\">(</span><span class=\"pln\">pSpam</span><span class=\"pun\">)</span></code></li></ol></pre><p>  其中DS通过Adaboost算法迭代获取最佳值。原理如下：</p>\n<p>设定adaboost循环的次数count<br>交叉验证随机选择1000个样本<br>DS初始化为和词汇列表大小相等的全一向量<br>迭代循环count次：<br>    设定最小分类错误率为inf<br>    对于每一个样本：<br>        在当前DS下对样本分类<br>        如果分类出错：<br>            计算出错的程度，即比较ps和ph的相差alpha<br>            如果样本原本是spam，错分成ham：<br>                DS[样本包含的词汇] = np.abs(DS[样本包含的词汇] - np.exp(alpha) / DS[样本包含的词汇])<br>            如果样本原本是ham，错分成spam：<br>                DS[样本包含的词汇] = DS[样本包含的词汇] + np.exp(alpha) / DS[样本包含的词汇]<br>    计算错误率<br>    保存最小的错误率和此时的词汇列表、P(Wi|S)和P(Wi|H)、DS等信息，即保存训练好的最佳模型的信息<br>  测试效果： 5574个样本，获取Adaboost算法训练的最佳模型信息（包括词汇列表、P(Wi|S)和P(Wi|H)、DS等），对1000个测试样本，分类的平均错误率约为：0.5%。</p>\n</div>','2017-04-17',4,22,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(175,'Java堆.栈和常量池 笔记','Java堆.栈和常量池 笔记','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><p><a href=\"http://www.iteye.com/topic/634530\">Java堆.栈和常量池 笔记</a></p>\n</div>','2017-04-23',1,18,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(176,'redis','redis的数据结构 数据结构类型 结构存储的值 结构的读写能力 STRING 可以是字符串、整数、或者浮点数 对整个字符串或者字符串的其中一部分执行操作；对整数和浮点数执行自增或者自减 LIST 一个链表，链表上的每个节点都包含了一个字符串 从链表的两端推入或者弹出元素；根据偏移量对链表进行修剪；根据值查找或者移除元素 SET 包含字符串的无序收集器，并且被包含的每个字符串都是独一无二、各不相同','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h1 id=\"h1-redis-\"><a name=\"redis的数据结构\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>redis的数据结构</h1><table>\n<thead>\n<tr>\n<th>数据结构类型</th>\n<th>结构存储的值</th>\n<th>结构的读写能力</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>STRING</td>\n<td>可以是字符串、整数、或者浮点数</td>\n<td>对整个字符串或者字符串的其中一部分执行操作；对整数和浮点数执行自增或者自减</td>\n</tr>\n<tr>\n<td>LIST</td>\n<td>一个链表，链表上的每个节点都包含了一个字符串</td>\n<td>从链表的两端推入或者弹出元素；根据偏移量对链表进行修剪；根据值查找或者移除元素</td>\n</tr>\n<tr>\n<td>SET</td>\n<td>包含字符串的无序收集器，并且被包含的每个字符串都是独一无二、各不相同的</td>\n<td>添加、获取、移除单个元素；检查一个元素是否存在于集合中；计算交集、并集、差集；从集合里面随机获取元素</td>\n</tr>\n<tr>\n<td>HASH</td>\n<td>包含键值对的无语散列表</td>\n<td>添加、获取、移除单个键值对；获取所有键值对</td>\n</tr>\n<tr>\n<td>ZSET(有序集合)</td>\n<td>字符串成员与浮点数分值之间的有序映射，元素的排列顺序由分值的大小决定</td>\n<td>添加、获取、单个元素；根据分值范围或者成员来获取元素</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"h3--string-\"><a name=\"一、STRING基本操作\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、STRING基本操作</h3><p>（1）SET 设置存储在给定键中的值<br>（2）GET 获取存储在给定键中的值<br>（3）DEL 删除存储在给定键中的值</p>\n<h3 id=\"h3--list-\"><a name=\"二、LIST（列表）基本操作\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、LIST（列表）基本操作</h3><p>（1）RPUSH 将给定值推入列表的右端<br>（2）LRANGE 获取列表在给定范围上的所有值<br>（3）LINDEX 获取列表在给定位置上的单个元素<br>（4）LPOP 从列表的左端弹出一个值，并返回被弹出的值</p>\n<h3 id=\"h3--set-\"><a name=\"三、SET（集合）基本操作\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>　三、SET（集合）基本操作</h3><p>（1）SADD 将给定元素添加到集合<br>（2）SMEMBERS 返回集合包含的所有元素<br>（3）SISMEMBER 检查给定元素是否存在于集合中<br>（4）SREM 如果给定的元素存在于集合中，那么移除这个元素</p>\n<h3 id=\"h3--hash-\"><a name=\"四、HASH（散列）基本操作\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>四、HASH（散列）基本操作</h3><p>（1）HSET 在散列里面关联起给定的键值对<br>（2）HGET 获取指定散列键的值<br>（3）HGETALL 获取散列包含的所有键值对<br>（4）HDEL 如果给定键存在于散列里面，那么移除这个键</p>\n<h3 id=\"h3--zset-\"><a name=\"五、ZSET（有序集合）基本操作\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>五、ZSET（有序集合）基本操作</h3><p>（1）ZADD 将一个带有给定分值的成员添加到有序集合里面<br>（2）ZRANGE 根据元素在有序排列中所处的位置，从有序集合里面获取多个元素<br>（3）ZRANGEBYSCORE 获取有序集合在给定分值范围的所有元素<br>（4）ZREM 如果给定成员存在于有序集合，那么移除这个成员</p>\n</div>','2017-05-04',6,24,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(177,'工厂模式','工厂模式 目录 何为工厂模式 工厂方法与抽象工厂 如何在Java EE中通过@Producers与@Inject注解实现工厂模式 如何创建自定义注解以及通过@Qualifier消除具体实现之间的歧义 工厂模式有两种模式：工厂方法和抽象方法。它们的意图是一样的：提供一个接口，在不指定具体类的情况下创建相关或依赖的一系列对象。 一.何为工厂模式 工厂的目的在于创建对象。创建的逻辑被封装在工厂中，要么提','<h1 id=\"h1-u5DE5u5382u6A21u5F0F\"><a name=\"工厂模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>工厂模式</h1><p>目录</p>\r\n<ul>\r\n<li>何为工厂模式</li><li>工厂方法与抽象工厂</li><li>如何在Java EE中通过<a href=\"https://github.com/Producers\" title=\"&#64;Producers\" class=\"at-link\">@Producers</a>与<a href=\"https://github.com/Inject\" title=\"&#64;Inject\" class=\"at-link\">@Inject</a>注解实现工厂模式</li><li>如何创建自定义注解以及通过<a href=\"https://github.com/Qualifier\" title=\"&#64;Qualifier\" class=\"at-link\">@Qualifier</a>消除具体实现之间的歧义<br>工厂模式有两种模式：工厂方法和抽象方法。它们的意图是一样的：提供一个接口，在不指定具体类的情况下创建相关或依赖的一系列对象。</li></ul>\r\n<h3 id=\"h3--\"><a name=\"一.何为工厂模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一.何为工厂模式</h3><p>工厂的目的在于创建对象。创建的逻辑被封装在工厂中，要么提供一个方法来返回新创建的对象（工厂方法模式），要么将对象的创建委托给子类（抽象工厂模式）。<br>客户端不必考虑接口或类的不同实现，它只需通过工厂（工厂）获取接口实现的一个实例的即可，这样客户端与对象的创建就实现了解耦<br>解耦是应用依赖反转原则的结果，这带来了很多好处，其中最重要的好处就是实现了高层类与底层类之间的解耦。通过解耦，具体类实现的变化不会影响到客户端，这降低了类与类之间的耦合，并提升了灵活性。</p>\r\n<h3 id=\"h3--\"><a name=\"二.工厂方法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二.工厂方法</h3><p>GoF一书是这样描述工程方法模式的：“定义一个用于创建对象的接口，不过让子类决定实例化那个类”<br>工厂极大降低了new关键字的使用次数，并且将初始化过程与不同的具体实现封装起来。将这些需求中心化可以极大减少向系统中添加或删除具体类的影响以及具体的类依赖的影响。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src=\"http://ohlrxdl4p.bkt.clouddn.com/images/QQ截图20170506134421.jpg\" alt=\"\"><br><strong>1.使用普通代码实现工厂方法</strong><br>被具体实现继承的DrinksMachine抽象类</p>\r\n<pre><code class=\"lang-java\">public abstract class DrinksMachine {\r\n    public abstract Drink dispenseDrink();\r\n    public String displayMessage(){\r\n        return &quot;Thank for your custom.&quot;;\r\n    }\r\n}\r\n</code></pre>\r\n<p>DrinksMachine抽象类的CoffeeMachine实现</p>\r\n<pre><code class=\"lang-java\">public class CoffeeMachine extends DrinksMachine {\r\n    public Drink dispenseDrink() {\r\n        return new Coffee();\r\n    }\r\n}\r\n</code></pre>\r\n<p>DrinksMachine抽象类的SoftDrinksMachine实现</p>\r\n<pre><code class=\"lang-java\">public class SoftDrinksMachine extends DrinksMachine {\r\n    public Drink dispenseDrink() {\r\n        return new SoftDrink();\r\n    }\r\n}\r\n</code></pre>\r\n<p>Drink接口</p>\r\n<pre><code class=\"lang-java\">public interface Drink {}\r\n</code></pre>\r\n<p>Drink接口的SoftDrink实现</p>\r\n<pre><code class=\"lang-java\">public class SoftDrink implements Drink {\r\n    SoftDrink() {\r\n        System.out.println(&quot;Soft drink&quot;);\r\n    }\r\n}\r\n</code></pre>\r\n<p>Drink接口的Coffee实现</p>\r\n<pre><code class=\"lang-java\">public class Coffee implements Drink {\r\n    Coffee() {\r\n        System.out.println(&quot;Coffee&quot;);\r\n    }\r\n}\r\n</code></pre>\r\n<p>CoffeeType枚举<br>```java<br>public enum CoffeeType {EXPRESSO, LATTE}</p>\r\n<p>public Drink dispenseDrink(CoffeeType type) {<br>    Drink coffee = null;<br>    switch (type) {<br>        case EXPRESSO: coffee = new Expresso();<br>        case LATTE: coffee = new Latte();<br>    }<br>    return coffee;<br>}<br>```&lt;!--前面不能有空格--&gt;</p>','2017-05-06',1,29,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(178,'代理模式','代理模式(Proxy Pattern) GoF中给出的代理模式的定义为： 代理模式给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。 代理模式的英文叫做Proxy或Surrogate，它是一种对象结构型模式。 代理模式根据其目的和实现可分为很多种类，常用的代理模式包括如下几种： （1）远程代理（Remote Proxy）————为一个位于不同的地址空间的对象提供一个本地的代理对象','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h1 id=\"h1--proxy-pattern-\"><a name=\"代理模式(Proxy Pattern)\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代理模式(Proxy Pattern)</h1><p>GoF中给出的代理模式的定义为：<br>代理模式给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。<br>代理模式的英文叫做Proxy或Surrogate，它是一种对象结构型模式。<br>代理模式根据其目的和实现可分为很多种类，常用的代理模式包括如下几种：<br>（1）远程代理（Remote Proxy）————为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以是在同一台主机中，也可以是在另一台主机中，远程代理又称为大使（Ambassador）<br>（2）虚拟代理（Virtual Proxy）————如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。<br>（3）保护代理（Protect Proxy）————控制一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。<br>（4）缓冲代理（Cache Proxy）————为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。<br>（5）只能引用代理（Smart Reference Proxy）————当一个对象被引用时，提供一些额外的操作，例如将对象被调用的次数记录下来。<br><img src=\"http://ohlrxdl4p.bkt.clouddn.com/images/QQ截图20170507103646.jpg\" alt=\"\"></p>\n<p>代码实现：<br>1.抽象主题类——BuyTicket.java</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code class=\"lang-java\"><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">interface</span><span class=\"pln\"> </span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> showticket</span><span class=\"pun\">();</span></code></li><li class=\"L2\"><code class=\"lang-java\"><span class=\"pun\">}</span></code></li></ol></pre>\n<p>2.具体主题类——Train.java</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code class=\"lang-java\"><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Train</span><span class=\"pln\"> </span><span class=\"kwd\">implements</span><span class=\"pln\"> </span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"lit\">@Override</span></code></li><li class=\"L2\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> showticket</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L3\"><code class=\"lang-java\"><span class=\"pln\">        </span><span class=\"typ\">System</span><span class=\"pun\">.</span><span class=\"pln\">out</span><span class=\"pun\">.</span><span class=\"pln\">println</span><span class=\"pun\">(</span><span class=\"str\">\"one ticket\"</span><span class=\"pun\">);</span></code></li><li class=\"L4\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L5\"><code class=\"lang-java\"><span class=\"pun\">}</span></code></li></ol></pre>\n<p>3.代理角色类——TicketCenter.java</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code class=\"lang-java\"><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">TicketCenter</span><span class=\"pln\"> </span><span class=\"kwd\">implements</span><span class=\"pln\"> </span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> ticket</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code class=\"lang-java\"></code></li><li class=\"L3\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"typ\">TicketCenter</span><span class=\"pun\">(</span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> ticket</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code class=\"lang-java\"><span class=\"pln\">        </span><span class=\"kwd\">this</span><span class=\"pun\">.</span><span class=\"pln\">ticket </span><span class=\"pun\">=</span><span class=\"pln\"> ticket</span><span class=\"pun\">;</span></code></li><li class=\"L5\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code class=\"lang-java\"></code></li><li class=\"L7\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"lit\">@Override</span></code></li><li class=\"L8\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> showticket</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L9\"><code class=\"lang-java\"><span class=\"pln\">        ticket</span><span class=\"pun\">.</span><span class=\"pln\">showticket</span><span class=\"pun\">();</span></code></li><li class=\"L0\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code class=\"lang-java\"></code></li><li class=\"L2\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> buy</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L3\"><code class=\"lang-java\"><span class=\"pln\">        </span><span class=\"typ\">System</span><span class=\"pun\">.</span><span class=\"pln\">out</span><span class=\"pun\">.</span><span class=\"pln\">println</span><span class=\"pun\">(</span><span class=\"str\">\"by proxy\"</span><span class=\"pun\">);</span></code></li><li class=\"L4\"><code class=\"lang-java\"><span class=\"pln\">        showticket</span><span class=\"pun\">();</span></code></li><li class=\"L5\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code class=\"lang-java\"><span class=\"pun\">}</span></code></li></ol></pre>\n<p>4.客户端测试类</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code class=\"lang-java\"><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">ProxyPattern</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> main</span><span class=\"pun\">(</span><span class=\"typ\">String</span><span class=\"pln\"> args</span><span class=\"pun\">[])</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L2\"><code class=\"lang-java\"><span class=\"pln\">        </span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> x </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Train</span><span class=\"pun\">();</span></code></li><li class=\"L3\"><code class=\"lang-java\"><span class=\"pln\">        </span><span class=\"typ\">TicketCenter</span><span class=\"pln\"> y </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">TicketCenter</span><span class=\"pun\">(</span><span class=\"pln\">x</span><span class=\"pun\">);</span></code></li><li class=\"L4\"><code class=\"lang-java\"><span class=\"pln\">        y</span><span class=\"pun\">.</span><span class=\"pln\">buy</span><span class=\"pun\">();</span></code></li><li class=\"L5\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code class=\"lang-java\"><span class=\"pun\">}</span></code></li></ol></pre>\n<p>运行结果：</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code class=\"lang-html\"><span class=\"pln\">by proxy</span></code></li><li class=\"L1\"><code class=\"lang-html\"><span class=\"pln\">one ticket</span></code></li></ol></pre>\n</div>','2017-05-07',1,29,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(179,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,25,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(180,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,19,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(181,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,19,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(182,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,19,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(183,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,19,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(184,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,21,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(185,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,25,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(186,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,26,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(187,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,25,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(188,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,21,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(189,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,23,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(190,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,18,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(191,'BSbsbsbs','heloo 哦i已被肉','<h1 id=\"h1-heloo-i-\"><a name=\"heloo 哦i已被肉\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>heloo 哦i已被肉</h1>','2017-01-23',3,16,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(192,'2017-02-28学习笔记','','<p><img src=\"http://ohlrxdl4p.bkt.clouddn.com/images/826546_1482322555369_C5DABB18734059E89A45A0E9170722B0.png\" alt=\"\"></p>','2017-02-28',1,22,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(193,'2017-03-01学习笔记','知识点 1.java中只有值传递，没有引用传递http://guhanjie.iteye.com/blog/1683637 2.final关键字 final修饰变量，则等同于常量. final修饰方法中的参数，称为最终参数. final修饰类，则类不能被继承. final修饰方法，则方法不能被','<h1 id=\"h1-u77E5u8BC6u70B9\"><a name=\"知识点\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>知识点</h1><h4 id=\"h4-1-java-http-guhanjie-iteye-com-blog-1683637\"><a name=\"1.java中只有值传递，没有引用传递  http://guhanjie.iteye.com/blog/1683637\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.java中只有值传递，没有引用传递<a href=\"http://guhanjie.iteye.com/blog/1683637\">http://guhanjie.iteye.com/blog/1683637</a></h4><h4 id=\"h4-2-final-\"><a name=\"2.final关键字\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.final关键字</h4><ul>\r\n<li>final修饰变量，则等同于常量.</li><li>final修饰方法中的参数，称为最终参数.</li><li>final修饰类，则类不能被继承.</li><li>final修饰方法，则方法不能被重写.</li></ul>\r\n<h4 id=\"h4-3-integer-img-src-https-uploadfiles-nowcoder-com-images-20160717-6316247_1468761643205_9f7b85ab04292cf73778d98998a20ed1-alt-\"><a name=\"3.Integer<img src=\"https://uploadfiles.nowcoder.com/images/20160717/6316247_1468761643205_9F7B85AB04292CF73778D98998A20ED1\" alt=\"图片\">\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.Integer<img src=\"https://uploadfiles.nowcoder.com/images/20160717/6316247_1468761643205_9F7B85AB04292CF73778D98998A20ED1\" alt=\"图片\"></h4><h4 id=\"h4-4-java-\"><a name=\"4.java内存模型   点击原文\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.java内存模型 <a href=\"http://blog.csdn.net/ns_code/article/details/17565503\">点击原文</a></h4><p><img src=\"https://uploadfiles.nowcoder.com/images/20161223/415611_1482452184396_6FB53C51539B47559CF0D122A832CF63\" alt=\"\"></p>\r\n<h4 id=\"h4-5-java-reference\"><a name=\"5.java中是没有指针的，有reference\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.java中是没有指针的，有reference</h4><p>第一：指针变量是在栈内存中，它也是有值的，这个值存储的就是地址单元，这个地址就是来自于赋值操作。<br>第二：指针变量有类型，这个类型（如Person）的含义是指针指向的变量在栈内存（不是很确定）中的范围（大小），我理解为是占用的堆内存空间。<br>第三：声明一个对象时，是对“指针变量”的定义。<br>第四：用new关键字在堆内存创建了对象，在赋值时，是把这个对象的首地址传给了这个“指针变量”（即引用型变量）。</p>\r\n<h4 id=\"h4-6-string-\"><a name=\"6.String生成常量\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6.String生成常量</h4><pre><code class=\"lang-java\">String s1=&quot;abc&quot;+&quot;def&quot;;//生成的是一个常量，放在堆内存中\r\nString s2=new String（s1);//s2是一个变量\r\nif(s1.equals(s2))//比较的是字符串的内容\r\n    System.out.println(&quot;.equals succeeded&quot;);//输出\r\nif(s1==s2)//比较的是内存地址，但s1是常量，所以不相等\r\n    System.out.println(&quot;==succeeded&quot;);\r\n</code></pre>\r\n<h4 id=\"h4-7-jsp-\"><a name=\"7.jsp内置对象和属性\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>7.jsp内置对象和属性</h4><p>（１）request对象<br>客户端的请求信息被封装在request对象中，通过它才能了解到客户的需求，然后做出响应。它是HttpServletRequest类的实例。<br>（２）response对象<br>response对象包含了响应客户请求的有关信息，但在JSP中很少直接用到它。它是HttpServletResponse类的实例。<br>（３）session对象<br>session对象指的是客户端与服务器的一次会话，从客户连到服务器的一个WebApplication开始，直到客户端与服务器断开连接为止。它是HttpSession类的实例.<br>（４）out对象<br>out对象是JspWriter类的实例,是向客户端输出内容常用的对象<br>（５）page对象<br>page对象就是指向当前JSP页面本身，有点象类中的this指针，它是java.lang.Object类的实例<br>（６）application对象<br>application对象实现了用户间数据的共享，可存放全局变量。它开始于服务器的启动，直到服务器的关闭，在此期间，此对象将一直存在；这样在用户的前后连接或不同用户之间的连接中，可以对此对象的同一属性进行操作；在任何地方对此对象属性的操作，都将影响到其他用户对此的访问。服务器的启动和关闭决定了application对象的生命。它是ServletContext类的实例。<br>（７）exception对象<br>exception对象是一个例外对象，当一个页面在运行过程中发生了例外，就产生这个对象。如果一个JSP页面要应用此对象，就必须把isErrorPage设为true，否则无法编译。他实际上是java.lang.Throwable的对象<br>（８）pageContext对象<br>pageContext对象提供了对JSP页面内所有的对象及名字空间的访问，也就是说他可以访问到本页所在的SESSION，也可以取本页面所在的application的某一属性值，他相当于页面中所有功能的集大成者，它的本 类名也叫pageContext。<br>（９）config对象<br>config对象是在一个Servlet初始化时，JSP引擎向它传递信息用的，此信息包括Servlet初始化时所要用到的参数（通过属性名和属性值构成）以及服务器的有关信息（通过传递一个ServletContext对象）</p>','2017-03-01',1,30,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(194,'2017-03-02学习笔记','知识点 一、static public class Spike\r\n{\r\n    public static void main(String[] args)\r\n    {\r\n        Counter a = new Counter();\r\n        System.out.println(a.increment());\r\n        System.out.println(a.anot','<h1 id=\"h1-u77E5u8BC6u70B9\"><a name=\"知识点\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>知识点</h1><h4 id=\"h4--static\"><a name=\"一、static\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、static</h4><pre><code class=\"lang-java\">public class Spike\r\n{\r\n    public static void main(String[] args)\r\n    {\r\n        Counter a = new Counter();\r\n        System.out.println(a.increment());\r\n        System.out.println(a.anotherIncrement());\r\n        Counter b = new Counter();\r\n        System.out.println(b.increment());\r\n    }\r\n}\r\nclass Counter\r\n{\r\n    private static int count = 0;\r\n    public int increment()\r\n    {\r\n        return count++;\r\n    }\r\n    public int anotherIncrement()\r\n    {\r\n        return ++count;\r\n    }\r\n}\r\n</code></pre>\r\n<p>count是静态变量，为所有对象所共享，因此不管a.increment()还是b.increment()都会使count持续增加。<br>increment()方法返回当前count值，然后count增加1<br>antoherIncrement()方法让count增加1，然后返回count值<br>第一次a.increment()返回值为0，此时count值为1<br>第二次a.anotherIncrement()先让count+1再返回，返回值为2<br>第三次b.increment()先返回count当前值2，然后count+1</p>\r\n<h4 id=\"h4--aop-\"><a name=\"二、AOP面向切面\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、AOP面向切面</h4><p>AOP的概念是Aspected Oriented Programming 面向方面编程。<br>  好处：AOP将程序分解成各个方面或者说关注点。这使得可以模块化，相当横向上分切了。它可以解决OOP和过程化方法不能够很好解决的横切（crosscut）问题，如：事务、安全、日志等横切关注。<br>  实现AOP有几种方式:<br>  1.Spring 1.2版本中通过ProxyFactoryBean来实现aop,即通过动态代理来实现的,Aspect必须继承MethodBeforeAdvice,MethodAfterAdvice等<br>  2.Spring 2.0 AOP需要改的是FBI 这个类，而且它也不需要再实现某些接口<br>  3.三使用标注（<a href=\"https://github.com/AspectJ\" title=\"&#64;AspectJ\" class=\"at-link\">@AspectJ</a>）实现AOP<br>    AOP 和 OOP的区别：</p>\r\n<pre><code>```html\r\n 1. 面向方面编程 AOP 偏重业务处理过程的某个步骤或阶段，强调降低模块之间的耦合度，使代码拥有更好的移植性。  \r\n 2. 面向对象编程 (oop) 则是对业务分析中抽取的实体进行方法和属性的封装。\r\n ```\r\n</code></pre><p>也可以说 AOP 是面向业务中的动词领域， OOP 面向名词领域。<br>AOP 的一个很重要的特点是源代码无关性，也就是说如果我们的系统中引用了 AOP 组件，即使我们把该组件去掉，系统代码也应该能够编译通过。要实现这一点，可以使用动态 proxy 模式。</p>\r\n<h4 id=\"h4--jdbc-\"><a name=\"三、jdbc桥接模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、jdbc桥接模式</h4><p>桥接模式：<br>定义 ：将抽象部分与它的实现部分分离，使它们都可以独立地变化。<br>意图 ：将抽象与实现解耦。<br>桥接模式所涉及的角色</p>\r\n<ol>\r\n<li>Abstraction ：定义抽象接口，拥有一个Implementor类型的对象引用</li><li>RefinedAbstraction ：扩展Abstraction中的接口定义</li><li>Implementor ：是具体实现的接口，Implementor和RefinedAbstraction接口并不一定完全一致，实际上这两个接口可以完全不一样Implementor提供具体操作方法，而Abstraction提供更高层次的调用</li><li>ConcreteImplementor ：实现Implementor接口，给出具体实现<br>Jdk中的桥接模式：JDBC<br>JDBC连接 数据库 的时候，在各个数据库之间进行切换，基本不需要动太多的代码，甚至丝毫不动，原因就是JDBC提供了统一接口，每个数据库提供各自的实现，用一个叫做数据库驱动的程序来桥接就行了<h4 id=\"h4--\"><a name=\"四、抽象类\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>四、抽象类</h4>抽象类和普通类有三点区别：<br>1）抽象方法必须为public和protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public。<br>2）抽象类不能用来创建对象，但是它可以有构造方法，用来帮助子类实例化。<br>3）如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为abstract类。<h4 id=\"h4--\"><a name=\"五、接口\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>五、接口</h4>接口的主要特点<br>1）接口中的成员变量默认都是public、static、final类型的，必须被显示初始化。<br>2）接口中的方法默认都是public、abstract类型的。<br>3）接口中只能包含public、static、final类型的成员变量和public、abstract类型的成员方法。<br>4）接口没有构造方法，不能被实例化。<br>5）一个接口不能实现另一个接口，但它可以继承多个其他接口。<br>6）接口必须通过类来实现它的抽象方法。<br>7）与子类继承抽象父类相似，当类实现了某个接口时，它必须实现接口中所有的抽象方法，否则这个类必须被定义为抽象类。<br>8）一个类只能继承一个直接的父类，但能实现多个接口。<h4 id=\"h4--\"><a name=\"六、抽象类和接口的区别\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>六、抽象类和接口的区别</h4>1）抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract方法；<br>2）抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；<br>3）接口中不能含有静态代码块以及静态方法，而抽象类尅有静态代码块和静态方法；<br>4）一个类只能继承一个抽象类，而一个类却可以实现多个接口。<br>5）抽象类中的方法子类必须全部实现，不然子类也是抽象类，而接口中的抽象方法子类必须全部实现，是可选择实现的。<br>6）抽象类是一种模板设计模式，而接口时一种行为规范。</li></ol>','2017-03-02',1,37,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(195,'2017-03-03学习笔记','一、String StringBuffer.toString()源码： @Override\r\npublic synchronized String toString() {\r\n    if (toStringCache == null) {\r\n        toStringCache = Arrays.copyOfRange(value, 0, count);\r\n    }\r\n    retur','<h4 id=\"h4--string\"><a name=\"一、String\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、String</h4><p>StringBuffer.toString()源码：</p>\r\n<pre><code class=\"lang-java\">@Override\r\npublic synchronized String toString() {\r\n    if (toStringCache == null) {\r\n        toStringCache = Arrays.copyOfRange(value, 0, count);\r\n    }\r\n    return new String(toStringCache, true);\r\n}\r\n</code></pre>\r\n<p>Arrays.copyOfRange用的是System.arraycopy</p>\r\n<pre><code class=\"lang-java\">public static char[] copyOfRange(char[] original, int from, int to) {\r\n        int newLength = to - from;\r\n        if (newLength &lt; 0)\r\n            throw new IllegalArgumentException(from + &quot; &gt; &quot; + to);\r\n        char[] copy = new char[newLength];\r\n        System.arraycopy(original, from, copy, 0,\r\n                         Math.min(original.length - from, newLength));\r\n        return copy;\r\n    }\r\n</code></pre>\r\n<p>1.String是值传入，不是引用传入。<br>2.String对String  类型进行改变的时候其实都等同于生成了一个新的  String  对象，然后将指针指向新的  String  对象，而不是StringBuffer；StringBuffer每次结果都会对  StringBuffer  对象本身进行操作，而不是生成新的对象，再改变对象引用。<br>3.效率比较String&lt;StringBuffer&lt;StringBuilder，但是在 String S1 = “This is only a” + “ simple” + “ test”时，String效率最高。</p>\r\n<h4 id=\"h4--jvm-\"><a name=\"二、jvm知识图谱\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、jvm知识图谱</h4><p><a href=\"https://zhuanlan.zhihu.com/p/25511795\">引用自知乎</a><br><img src=\"https://pic2.zhimg.com/v2-701563ac1fe745fc8e1234c96e82ac99_r.jpg\" alt=\"\"></p>\r\n<h4 id=\"h4--treemap-linkhashmap\"><a name=\"三、Treemap、LinkHashMap\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、Treemap、LinkHashMap</h4><p>1.TreeMap取出来的是排序后的键值对。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。<br>2.LinkedHashMap 是HashMap的一个子类，如果需要输出的顺序和输入的相同,那么用LinkedHashMap可以实现,它还可以按读取顺序来排列。</p>\r\n<h4 id=\"h4--sql-\"><a name=\"四、sql模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>四、sql模式</h4><p>MySQL数据库中，变量分为 系统变量（以”@@”开头）和用户自定义变量。系统变量分为全局系统变量(global)和会话系统变量(session)。<br>@<a href=\"https://github.com/global\" title=\"&#64;global\" class=\"at-link\">@global</a>     仅用于访问全局系统变量的值；<br>@<a href=\"https://github.com/session\" title=\"&#64;session\" class=\"at-link\">@session</a>  仅用于访问会话系统变量的值；<br>@@              先访问会话系统变量的值，若不存在则去访问全局系统变量的值；<br>sql_mode 为系统变量，既是全局系统变量，又是会话系统变量。</p>\r\n<h4 id=\"h4--\"><a name=\"五、代码的执行顺序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>五、代码的执行顺序</h4><p>父类Ｂ静态代码块-&gt;子类Ａ静态代码块-&gt;父类Ｂ非静态代码块-&gt;父类Ｂ构造函数-&gt;子类Ａ非静态代码块-&gt;子类Ａ构造函数<br><img src=\"http://ohlrxdl4p.bkt.clouddn.com/images/QQ截图20170303165728.jpg\" alt=\"\"></p>','2017-03-03',1,35,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(196,'ifhifhajfe','hello','<h1 id=\"h1-hello\"><a name=\"hello\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>hello</h1>','2017-03-05',1,35,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(197,'2017-03-05学习笔记','java的堆，栈，静态代码区（常量区） 详解','<p><a href=\"http://blog.csdn.net/u012031380/article/details/54981472\"> java的堆，栈，静态代码区（常量区） 详解</a></p>','2017-03-05',1,36,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(198,'java归并排序','package datastruct;\r\n\r\n/**\r\n * Created by Zephery on 2017/3/3.\r\n */\r\npublic class Solution {\r\n    public static void printArray(int[] arr, int i, int j) {\r\n        System.out.print(\"[\");\r\n        for','<pre><code class=\"lang-java\">package datastruct;\r\n\r\n/**\r\n * Created by Zephery on 2017/3/3.\r\n */\r\npublic class Solution {\r\n    public static void printArray(int[] arr, int i, int j) {\r\n        System.out.print(&quot;[&quot;);\r\n        for (int k = i; k &lt; j; k++) {\r\n            System.out.print(arr[k] + &quot;,&quot;);\r\n        }\r\n        System.out.print(arr[j] + &quot;]&quot;);\r\n    }\r\n\r\n    private static void mergesort(int[] arr, int i, int j) {\r\n        int mid = 0;\r\n        if (i &lt; j) {\r\n            mid = (i + j) / 2;\r\n            mergesort(arr, i, mid);\r\n            mergesort(arr, mid + 1, j);\r\n            merge(arr, i, mid, j);\r\n        }\r\n    }\r\n\r\n    private static void merge(int[] arr, int i, int mid, int j) {\r\n        System.out.print(&quot;Left:&quot;);\r\n        printArray(arr, i, mid);\r\n        System.out.println(&quot;Right:&quot;);\r\n        printArray(arr, mid + 1, j);\r\n        System.out.println();\r\n        int temp[] = new int[arr.length];\r\n        int l = i;\r\n        int r = j;\r\n        int m = mid + 1;\r\n        int k = l;\r\n        while (l &lt;= mid &amp;&amp; m &lt;= r) {\r\n            if (arr[l] &lt;= arr[m]) {\r\n                temp[k++] = arr[l++];\r\n            } else {\r\n                temp[k++] = arr[m++];\r\n            }\r\n        }\r\n        while (l &lt;= mid) {\r\n            temp[k++] = arr[l++];\r\n        }\r\n        while (m &lt;= r) {\r\n            temp[k++] = arr[m++];\r\n        }\r\n        for (int i1 = i; i1 &lt;= j; i1++) {\r\n            arr[i1] = temp[i1];\r\n        }\r\n        System.out.print(&quot;After Merge:&quot;);\r\n        printArray(arr, i, j);\r\n        System.out.println();\r\n    }\r\n\r\n    public static void main(String args[]) {\r\n        int[] arr = {9, 4, 8, 3, 1, 2, 5};\r\n        System.out.print(&quot;Initial Array:&quot;);\r\n        printArray(arr, 0, arr.length - 1);\r\n        System.out.println();\r\n        mergesort(arr, 0, arr.length - 1);\r\n    }\r\n}\r\n</code></pre>\r\n<pre><code class=\"lang-js\">Initial Array:[9,4,8,3,1,2,5]\r\nLeft:[9]Right:\r\n[4]\r\nAfter Merge:[4,9]\r\nLeft:[8]Right:\r\n[3]\r\nAfter Merge:[3,8]\r\nLeft:[4,9]Right:\r\n[3,8]\r\nAfter Merge:[3,4,8,9]\r\nLeft:[1]Right:\r\n[2]\r\nAfter Merge:[1,2]\r\nLeft:[1,2]Right:\r\n[5]\r\nAfter Merge:[1,2,5]\r\nLeft:[3,4,8,9]Right:\r\n[1,2,5]\r\nAfter Merge:[1,2,3,4,5,8,9]\r\n</code></pre>','2017-03-06',1,36,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(199,'2017-03-10学习笔记','1.Integer和int，装箱拆箱 1、基本型和基本型封装型进行“==”运算符的比较，基本型封装型将会自动拆箱变为基本型后再进行比较，因此Integer(0)会自动拆箱为int类型再进行比较，显然返回true； 2、两个Integer类型进行“==”比较，如果其值在-128至127，那么返回true，否则返回false, 这跟Integer.valueOf()的缓冲对象有关，这里不进行赘述。 3','<h1 id=\"h1-1-integer-int-\"><a name=\"1.Integer和int，装箱拆箱\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.Integer和int，装箱拆箱</h1><p>1、基本型和基本型封装型进行“==”运算符的比较，基本型封装型将会自动拆箱变为基本型后再进行比较，因此Integer(0)会自动拆箱为int类型再进行比较，显然返回true；<br>2、两个Integer类型进行“==”比较，如果其值在-128至127，那么返回true，否则返回false, 这跟Integer.valueOf()的缓冲对象有关，这里不进行赘述。<br>3、两个基本型的封装型进行equals()比较，首先equals()会比较类型，如果类型相同，则继续比较值，如果值也相同，返回true<br>4、基本型封装类型调用equals(),但是参数是基本类型，这时候，先会进行自动装箱，基本型转换为其封装类型，再进行3中的比较。</p>\r\n<pre><code class=\"lang-java\">int a=257;\r\nInteger b=257;\r\nInteger c=257;\r\nInteger b2=57;\r\nInteger c2=57;\r\nSystem.out.println(a==b);\r\n//System.out.println(a.equals(b));  编译出错，基本型不能调用equals()\r\nSystem.out.println(b.equals(257.0));\r\nSystem.out.println(b==c);\r\nSystem.out.println(b2==c2);\r\n</code></pre>\r\n<p>因此上面的代码的结果因此为 true, false, false, true</p>\r\n<h1 id=\"h1-2-\"><a name=\"2.线程调度\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.线程调度</h1><p>分为协同式调度和抢占式调度，Java使用的是抢占式调度，也就是每个线程将由操作系统来分配执行时间，线程的切换不由线程本身来决定（协同式调度）。这就是平台独立的原因。</p>\r\n<h1 id=\"h1-3-\"><a name=\"3.重载，重写\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.重载，重写</h1><p>重写：<br>两同，两小，一大<br>两同：方法名，方法参数列表相同。<br>两小：抛出的异常类型要小于等于父类，返回值类型要小于等于父类<br>一大：访问权限大于等于父类。<br>重载：<br>在同一个类中，方法名和方法参数列表不同，其他的（访问权限、返回值）随意。</p>\r\n<h1 id=\"h1-4-jvm-\"><a name=\"4.  JVM面试题\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.<a href=\"http://blog.csdn.net/hsk256/article/details/49104955\">JVM面试题</a></h1>','2017-03-10',1,34,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(200,'2017-03-12学习笔记','1.继承的加载顺序 执行顺序大体上可以说是先父类后子类，父类static域 ==》子类static域 ==》父类数据成员域 ==》父类构造器 ==》子类数据成员域 ==》子类构造器 2.优化Hibernate所鼓励的7大措施： 1.尽量使用many-to-one，避免使用单项one-to-many 2.灵活使用单向one-to-many 3.不用一对一，使用多对一代替一对一 4.配置对象缓存，不使','<h4 id=\"h4-1-\"><a name=\"1.  继承的加载顺序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.<a href=\"http://www.cnblogs.com/SirSmith/p/5536288.html\">继承的加载顺序</a></h4><p><img src=\"http://images2015.cnblogs.com/blog/452847/201605/452847-20160527221410288-2119099273.png\" alt=\"\"></p>\r\n<p>执行顺序大体上可以说是先父类后子类，父类static域 ==》子类static域 ==》父类数据成员域 ==》父类构造器 ==》子类数据成员域 ==》子类构造器</p>\r\n<h4 id=\"h4-2-hibernate-7-\"><a name=\"2.优化Hibernate所鼓励的7大措施：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.优化Hibernate所鼓励的7大措施：</h4><p>1.尽量使用many-to-one，避免使用单项one-to-many<br>2.灵活使用单向one-to-many<br>3.不用一对一，使用多对一代替一对一<br>4.配置对象缓存，不使用集合缓存<br>5.一对多使用Bag 多对一使用Set<br>6.继承使用显示多态 HQL:from object polymorphism=”exlicit” 避免查处所有对象<br>7.消除大表，使用二级缓存</p>\r\n<h4 id=\"h4-3-java-\"><a name=\"3.java中的数据类型分类：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.java中的数据类型分类：</h4><p>基本数据类型（或叫做原生类、内置类型）8种：<br>    整数：byte，short，int，long（默认是int类型）<br>    浮点类型： float，double（默认是double类型）<br>    字符类型：char<br>    布尔类型：boolean<br>引用数据类型3种：数组，类，接口</p>\r\n<h4 id=\"h4-4-\"><a name=\"4.触发器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.触发器</h4><p>drop trigger 删除触发器<br>Drop用于删除数据表或数据库，或删除数据表字段。<br>remove：删除数据库文件<br>Truncate：删除数据表中的数据（仅数据表中的数据，不删除表）。</p>','2017-03-12',1,29,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(201,'2017-03-14学习笔记','1.Servlet的生命周期分为5个阶段：加载、创建、初始化、处理客户请求、卸载。 (1)加载：容器通过类加载器使用servlet类对应的文件加载servlet (2)创建：通过调用servlet构造函数创建一个servlet对象 (3)初始化：调用init方法初始化 (4)处理客户请求：每当有一个客户请求，容器会创建一个线程来处理客户请求 (5)卸载：调用destroy方法让servlet自己释','<h4 id=\"h4-1-servlet-5-\"><a name=\"1.Servlet的生命周期分为5个阶段：加载、创建、初始化、处理客户请求、卸载。\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.Servlet的生命周期分为5个阶段：加载、创建、初始化、处理客户请求、卸载。</h4><p>(1)加载：容器通过类加载器使用servlet类对应的文件加载servlet<br>(2)创建：通过调用servlet构造函数创建一个servlet对象<br>(3)初始化：调用init方法初始化<br>(4)处理客户请求：每当有一个客户请求，容器会创建一个线程来处理客户请求<br>(5)卸载：调用destroy方法让servlet自己释放其占用的资源</p>\r\n<h4 id=\"h4-2-jsp\"><a name=\"2.JSP\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.JSP</h4><p><img src=\"http://uploadfiles.nowcoder.com/images/20160308/595432_1457414324036_C3D4EB7F2D61708D0C0BE2921A45B74D\" alt=\"\"></p>','2017-03-14',1,21,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(202,'2017-03-17学习笔记','1.GC线程是否和守护线程 2.java堆排序','<h4 id=\"h4-1-gc-\"><a name=\"1.GC线程是否和守护线程\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.GC线程是否和守护线程</h4><h4 id=\"h4-2-java-\"><a name=\"2.java堆排序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.java堆排序</h4>','2017-03-17',1,16,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(203,'春招~好失落啊','自己的情况：广东人，大学跑到天津一所二本学校，网络工程专业，大一大二学ccna、ccnp，发现没有创造性，按着别人的死规定敲命令好无聊，大三彻底转向编程，c++看着不爽，调研一番后选择java，自学java和java web，对jsp、servlet略过，直接上手框架（Struts，hibernate，spring），看书，找视频，敲项目，非专业课（操作系统，数据库等）不听，捣鼓一番觉得还行，继续','<p>自己的情况：广东人，大学跑到天津一所二本学校，网络工程专业，大一大二学ccna、ccnp，发现没有创造性，按着别人的死规定敲命令好无聊，大三彻底转向编程，c++看着不爽，调研一番后选择java，自学java和java web，对jsp、servlet略过，直接上手框架（Struts，hibernate，spring），看书，找视频，敲项目，非专业课（操作系统，数据库等）不听，捣鼓一番觉得还行，继续学习spring mvc，mybatis，开始了解hadoop、spark，同时搭了自己的网站，跟了软件工程的同学比了比，还能算上前列吧，当然，基础和算法跟前列的人还没得比~~~</p>\r\n<p>去年秋招，腾讯、阿里等笔试全挂，京东的没怎么做却过了，不敢去面试（真心没怎么做题），最后去了北京一家创业公司实习了三个月多，感觉真心好，12月几乎整整一个月雾霾，受不了，还是回广东吧。在家过了春节，2月10号跟同学一起来深圳，就这样，开始了春招之旅~~~~</p>\r\n<p>第一家，面试的问的差不多全答对，手写了几个sql也对了，不过居然没有问hashmap，给的工资6000到9000，想了想，还是不去的好，太郊区，后来一查，是个培训兼外包的企业，还好没去。。。。</p>\r\n<p>第二家，某ERP公司，额，笔试，全是sql，做了，感觉还可以，面试直接说我们公司不用java，用的一个小众语言，薪资应届生只有3500，直接走人。。。。</p>\r\n<p>第三家，找工作，对广东真是彻底失望了，投的简历除了培训机构理你，其他的都不理人的，无奈之下投了北京的一家创业公司（A轮），薪资1万，电话面试，过了。。。。。后来想想，还是不去北京了，虽然工资高，但是没有朋友，过得像个死人一样。</p>\r\n<p>第四家，深圳一家创业公司，做东南亚社交软件的，可惜薪资没谈成，4K-6K，这可是深圳啊。。。。</p>\r\n<p>第五家，广州凡科，那天一早就从深圳跑过去，没吃饭，下午到就做笔试题，头晕，手抖，然后一面就是跟你讲笔试题，讲了两道，就叫我走了。。。仅仅半个小时，广深来回6个小时。。。</p>\r\n<p>第六家，广州某搞运维的公司，笔试差不多答对，面试问的问题也答对，但是没给offer。。。不理解</p>\r\n<p>第七家，然后晚上跑去了广工的久邦数码宣讲，试卷发到我这的时候，HR说我这方向的试卷没带够。。。。无奈向他要了大数据的题，全是数据库的题，过几天后得知居然过了，然后一面，问的问题没啥印象，除了left join的原理没答对。。。今天得知挂了。。。。</p>\r\n<p><img src=\"http://images2015.cnblogs.com/blog/755525/201703/755525-20170318000537838-305991370.png\" alt=\"\"></p>\r\n<p>第八家，极天信息（A轮），笔试的题目没看懂它问的啥，一面没啥印象了，然后是经理面，说广州没那么高的工资（7000），等消息，估计也没谈成。。。。</p>\r\n<p>第九家，中国移动，最气的了，一面就是HR面，问了两个问题，为什么不在北京留着，你觉得相比其他人你有什么优势。我只能说我真不会说话更不知怎么回答，就强调勤奋，然后直接被HR叫走人了，3分钟=w=</p>\r\n<p>第十家，珍爱网，找别人内推的，三个问题没答上来，就不跟你们说了，亲爱的竞争对手们=w=，谈了四十分钟吧，出来后感觉很不好，估计也是挂了。。。</p>\r\n<p>今天晚上，收到了久邦数码的拒绝信，瞬间觉得好无奈好迷茫，有时候就那么一个简简单单的问题，答不好就直接拒绝的，改怎么心平气和的面对下一个面试。有时候真不理解公司是怎么招人的，是不是真的“把部分简历扔进垃圾桶，不招那些运气不好的人”？也只能这么安慰自己。可是，事实呢？</p>\r\n<p><img src=\"http://images2015.cnblogs.com/blog/755525/201703/755525-20170318001336463-1583022291.jpg\" alt=\"\"></p>\r\n<p>这些天，有时间都是往深圳图书馆跑，看书，刷牛客网，补算法，看源码，做了这么多，该怎么告诉自己不要放弃。。。。。开始有点想念北京的雾霾</p>','2017-03-18',5,17,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(204,'数据库','1.SQL执行的顺序 2.NULL “空值” 和”NULL”的概念： 1：空值(‘’)是不占用空间的,判断空字符用 = ‘’ 或者 <> ‘’ 来进行处理; 2: NULL值是未知的，且占用空间，不走索引;判断 NULL 用 IS NULL 或者 is not null , SQL 语句函数中可以使用 ifnull ()函数来进行处理. 注：在进行 count ()统计某列的记录数的时候，如果采用','<h4 id=\"h4-1-sql-\"><a name=\"1.SQL执行的顺序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.SQL执行的顺序</h4><p><img src=\"http://uploadfiles.nowcoder.com/images/20150828/415611_1440751995009_3B3E1329A400F0022B20C4F32AEFC9EF\" alt=\"\"></p>\r\n<h4 id=\"h4-2-null\"><a name=\"2.NULL\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.NULL</h4><p>“空值” 和”NULL”的概念：<br>  1：空值(‘’)是不占用空间的,判断空字符用 = ‘’ 或者 &lt;&gt; ‘’ 来进行处理;<br> 2: NULL值是未知的，且占用空间，不走索引;判断 NULL 用 IS NULL 或者 is not null , SQL 语句函数中可以使用 ifnull ()函数来进行处理.<br>注：在进行 count ()统计某列的记录数的时候，如果采用的 NULL 值，会别系统自动忽略掉，但是空值是统计到其中</p>\r\n<h4 id=\"h4-3-\"><a name=\"3.\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.</h4><p>在MySQL数据库中，NULL对于一些特殊类型的列来说，其代表了一种特殊的含义，而不仅仅是一个空值。<br>IS NULL: 此运算符返回true，当列的值是NULL。<br>IS NOT NULL: 运算符返回true，当列的值不是NULL。<br>&lt;=&gt; 操作符比较值（不同于=运算符）为ture，即使两个NULL值<br>涉及NULL条件是特殊的。不能使用 =NULL 或 !=NULL 寻找NULL值的列</p>\r\n<h4 id=\"h4-4-nf\"><a name=\"4.NF\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.NF</h4><p>第一范式（   1NF   ）：   字段具有   原子性   ,   不可再分   。所有关系型数据库系统都满足第一范式）数据库表中的字段都是单一属性的，不可再分。例如，姓名字段，其中的姓和名必须作为一个整体，无法区分哪部分是姓，哪部分是名，如果要区分出姓和名，必须设计成两个独立的字段。<br>第二范式（   2NF   ）：   第二范式（   2NF   ）是在   第一范式（   1NF   ）的基础上   建立起来的，即满足第二范式（   2NF   ）必须先满足第一范式（   1NF   ）。要求   数据库表中的每个实例或行必须可以被惟一地区分   。通常需要为表加上一个列，以存储各个实例的惟一标识。这个惟一属性列被称为   主关键字或主键   。<br>        第二范式（   2NF   ）要求   实体的属性完全依赖于主关键字   。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。简而言之，第二范式就是非主属性非部分依赖于主关键字。<br>第三范式 （  3NF  ） ：   满足第三范式（   3NF   ）   必须先满足第二范式（   2NF   ）   。简而言之，第三范式（   3NF   ）要求一个数据库表中   不包含   已在其它表中   已包含的非主关键字信息   。所以第三范式具有如下特征：<br>1   ，每一列只有一个值<br>2   ，每一行都能区分。<br>3   ，每一个表都   不包含其他表已经包含   的非主关键字信息。<br>例如，帖子表中只能出现发帖人的   id   ，而不能出现发帖人的   id   ，还同时出现发帖人姓名，否则，只要出现同一发帖人   id   的所有记录，它们中的姓名部分都必须严格保持一致，这就是   数据冗余   。</p>','2017-03-18',3,19,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(205,'重载与重写','目前的问题：父类的功能无法满足子类的需求。 方法重写的前提： 必须要存在继承的关系。 方法的重写: 子父类出了同名的函数，这个我们就称作为方法的重写。 什么是时候要使用方法的重写：父类的功能无法满足子类的需求时。 方法重写要注意的事项： 1.方法重写时， 方法名与形参列表必须一致。 2.方法重写时，子类的权限修饰符必须要大于或者等于父类的权限修饰符。 3.方法重写时，子类的返回值类型必须要小于或者','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><p>目前的问题：父类的功能无法满足子类的需求。</p>\n<p>方法重写的前提： 必须要存在继承的关系。</p>\n<p>方法的重写: 子父类出了同名的函数，这个我们就称作为方法的重写。</p>\n<p>什么是时候要使用方法的重写：父类的功能无法满足子类的需求时。</p>\n<p>方法重写要注意的事项：<br>    1.方法重写时， 方法名与形参列表必须一致。<br>    2.方法重写时，子类的权限修饰符必须要大于或者等于父类的权限修饰符。<br>    3.方法重写时，子类的返回值类型必须要小于或者 等于父类的返回值类型。<br>    4.方法重写时， 子类抛出的异常类型要小于或者等于父类抛出的异常类型。<br>            Exception(最坏)<br>            RuntimeException(小坏)</p>\n<p>方法的重载：在一个类中 存在两个或者两个 以上的同名函数,称作为方法重载。</p>\n<p>方法重载的要求</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"lit\">1.</span><span class=\"pln\"> </span><span class=\"pun\">函数名要一致。</span></code></li><li class=\"L1\"><code><span class=\"lit\">2.</span><span class=\"pln\"> </span><span class=\"pun\">形参列表不一致（形参的个数或形参</span><span class=\"pln\"> </span><span class=\"pun\">的类型不一致）</span></code></li><li class=\"L2\"><code><span class=\"lit\">3.</span><span class=\"pln\"> </span><span class=\"pun\">与返回值类型无关。</span></code></li></ol></pre></div>','2017-03-21',1,19,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(206,'垃圾回收算法','垃圾回收算法 1、标记-清除算法 2、复制算法 3、标记-整理算法 一、标记-清除算法 标记-清除算法采用从根集合进行扫描，对存活的对象对象标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收，如上图所示。 标记-清除算法不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效，但由于标记-清除算法直接回收不存活的对象，因此会造成内存碎片！ 二、复制算法 复制算法','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h2 id=\"h2-u5783u573Eu56DEu6536u7B97u6CD5\"><a name=\"垃圾回收算法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>垃圾回收算法</h2><p>1、标记-清除算法<br>2、复制算法<br>3、标记-整理算法</p>\n<h4 id=\"h4--\"><a name=\"一、标记-清除算法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、标记-清除算法</h4><p><img src=\"http://dl2.iteye.com/upload/attachment/0075/0386/29ae17ad-f8af-38b4-9e25-28ef3550858f.jpg\" alt=\"\">标记-清除算法采用从根集合进行扫描，对存活的对象对象标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收，如上图所示。<br>标记-清除算法不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效，但由于标记-清除算法直接回收不存活的对象，因此会造成内存碎片！</p>\n<h4 id=\"h4--\"><a name=\"二、复制算法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、复制算法</h4><p><img src=\"http://dl2.iteye.com/upload/attachment/0075/0388/91a656d4-f08a-377b-8eea-5785c2932533.jpg\" alt=\"\"><br>复制算法采用从根集合扫描，并将存活对象复制到一块新的，没有使用过的空间中，这种算法当控件存活的对象比较少时，极为高效，但是带来的成本是需要一块内存交换空间用于进行对象的移动。也就是我们前面提到的s0 s1等空间。</p>\n<h4 id=\"h4--\"><a name=\"三、标记-整理算法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、标记-整理算法</h4><p><img src=\"http://dl2.iteye.com/upload/attachment/0075/0390/6ba95f80-c7bc-3d09-b927-ac09297e9920.jpg\" alt=\"\"><br> 标记-整理算法采用标记-清除算法一样的方式进行对象的标记，但在清除时不同，在回收不存活的对象占用的空间后，会将所有的存活对象往左端空闲空间移动，并更新对应的指针。标记-整理算法是在标记-清除算法的基础上，又进行了对象的移动，因此成本更高，但是却解决了内存碎片的问题。</p>\n</div>','2017-04-09',1,17,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(207,'java分代回收','一、新生代内存的回收（minor GC）主要采用复制算法，下图展示了minor GC的执行过程。 二、对于新生代和旧生代，JVM可使用很多种垃圾回收器进行垃圾回收，下图展示了不同生代不通垃圾回收器，其中两个回收器之间有连线表示这两个回收器可以同时使用。 而这些垃圾回收器又分为串行回收方式、并行回收方式合并发回收方式执行，分别运用于不同的场景。如下图所示 三、收集器 1.Serial收集器 看名字我','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h2 id=\"h2--minor-gc-minor-gc-\"><a name=\"一、新生代内存的回收（minor GC）主要采用复制算法，下图展示了minor GC的执行过程。\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、新生代内存的回收（minor GC）主要采用复制算法，下图展示了minor GC的执行过程。</h2><p><img src=\"http://dl2.iteye.com/upload/attachment/0075/0392/732c7557-aa9a-3551-b14d-f543c5b0c94b.jpg\" alt=\"\"></p>\n<h2 id=\"h2--jvm-\"><a name=\"二、对于新生代和旧生代，JVM可使用很多种垃圾回收器进行垃圾回收，下图展示了不同生代不通垃圾回收器，其中两个回收器之间有连线表示这两个回收器可以同时使用。\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、对于新生代和旧生代，JVM可使用很多种垃圾回收器进行垃圾回收，下图展示了不同生代不通垃圾回收器，其中两个回收器之间有连线表示这两个回收器可以同时使用。</h2><p><img src=\"http://dl2.iteye.com/upload/attachment/0075/0394/0172f624-9018-3642-bf26-05a2c3071639.jpg\" alt=\"\"><br>而这些垃圾回收器又分为串行回收方式、并行回收方式合并发回收方式执行，分别运用于不同的场景。如下图所示<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0396/c962c2ad-273f-3de4-b2e3-a4dd8b946215.jpg\" alt=\"\"></p>\n<h2 id=\"h2--\"><a name=\"三、收集器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、收集器</h2><h4 id=\"h4-1-serial-\"><a name=\"1.Serial收集器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.Serial收集器</h4><p>看名字我们都可以看的出来，这个属于串行收集器。其运行示意图如下<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0398/681da5ca-5eff-3984-bece-3d80dfe905be.jpg\" alt=\"\"><br>    收集器是历史最悠久的一个回收器，JDK1.3之前广泛使用这个收集器，目前也是ClientVM下 ServerVM 4核4GB以下机器的默认垃圾回收器。串行收集器并不是只能使用一个CPU进行收集，而是当JVM需要进行垃圾回收的时候，需要中断所有的用户线程，知道它回收结束为止，因此又号称“Stop The World” 的垃圾回收器。注意，JVM中文名称为java虚拟机，因此它就像一台虚拟的电脑一样在工作，而其中的每一个线程就被认为是JVM的一个处理器，因此大家看到图中的CPU0、CPU1实际为用户的线程，而不是真正机器的CPU，大家不要误解哦。<br>    串行回收方式适合低端机器，是Client模式下的默认收集器，对CPU和内存的消耗不高，适合用户交互比较少，后台任务较多的系统。<br>    Serial收集器默认新旧生代的回收器搭配为Serial+ SerialOld</p>\n<h4 id=\"h4-2-parnew-\"><a name=\"2.ParNew收集器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.ParNew收集器</h4><p>ParNew收集器其实就是多线程版本的Serial收集器，其运行示意图如下<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0400/6443b39c-ed33-3d93-a690-87e646439561.jpg\" alt=\"\"><br>同样有Stop The World的问题，他是多CPU模式下的首选回收器（该回收器在单CPU的环境下回收效率远远低于Serial收集器，所以一定要注意场景哦），也是Server模式下的默认收集器。</p>\n<h4 id=\"h4-3-parallelscavenge\"><a name=\"3.ParallelScavenge\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.ParallelScavenge</h4><p>ParallelScavenge又被称为是吞吐量优先的收集器，器运行示意图如下<br><img src=\"http://dl.iteye.com/upload/attachment/0075/0402/5007beba-0b0e-3cf4-b146-c28b6c0dd696.jpg\" alt=\"\"><br> ParallelScavenge<br>所提到的吞吐量=程序运行时间/(JVM执行回收的时间+程序运行时间),假设程序运行了100分钟，JVM的垃圾回收占用1分钟，那么吞吐量就是99%。在当今网络告诉发达的今天，良好的响应速度是提升用户体验的一个重要指标，多核并行云计算的发展要求程序尽可能的使用CPU和内存资源，尽快的计算出最终结果，因此在交互不多的云端，比较适合使用该回收器。</p>\n<h4 id=\"h4-4-parallelold\"><a name=\"4.ParallelOld\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.ParallelOld</h4><p>ParallelOld是老生代并行收集器的一种，使用标记整理算法、是老生代吞吐量优先的一个收集器。这个收集器是JDK1.6之后刚引入的一款收集器，我们看之前那个图之间的关联关系可以看到，早期没有ParallelOld之前，吞吐量优先的收集器老生代只能使用串行回收收集器，大大的拖累了吞吐量优先的性能，自从JDK1.6之后，才能真正做到较高效率的吞吐量优先。其运行示意图如下<br><img src=\"http://dl.iteye.com/upload/attachment/0075/0406/9a14da85-f943-3408-ba88-c6bb3842a792.jpg\" alt=\"\"></p>\n<h4 id=\"h4-5-serialold\"><a name=\"5.SerialOld\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.SerialOld</h4><p>SerialOld是旧生代Client模式下的默认收集器，单线程执行；在JDK1.6之前也是ParallelScvenge回收新生代模式下旧生代的默认收集器，同时也是并发收集器CMS回收失败后的备用收集器。其运行示意图如下<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0404/ce7aabd5-b0e0-3cda-9b6c-607cf6ebf689.jpg\" alt=\"\"></p>\n<h4 id=\"h4-5-cms\"><a name=\"5.CMS\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.CMS</h4><p>CMS又称响应时间优先(最短回收停顿)的回收器，使用并发模式回收垃圾，使用标记-清除算法，CMS对CPU是非常敏感的，它的回收线程数=（CPU+3）/4，因此当CPU是2核的实惠，回收线程将占用的CPU资源的50%，而当CPU核心数为4时仅占用25%。他的运行示意图如下<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0408/4239228b-879f-382f-81c6-5c32799886d6.jpg\" alt=\"\"><br>模式主要分为四个过程：<br>1.初始标记<br>2.并发标记<br>3.重新标记<br>4.并发清除<br>在初始标记的时候，需要中断所有用户线程，在并发标记阶段，用户线程和标记线程<br>并发执行，而在这个过程中，随着内存引用关系的变化，可能会发生原来标记的对象被释放，进而引发新的垃圾，因此可能会产生一系列的浮动垃圾，不能被回收。</p>\n<p>CMS 为了确保能够扫描到所有的对象，避免在Initial Marking 中还有未标识到的对象，采用的方法为找到标记了的对象，并将这些对象放入Stack 中，扫描时寻找此对象依赖的对象，如果依赖的对象的地址在其之前，则将此对象进行标记，并同时放入Stack 中，如依赖的对象地址在其之后，则仅标记该对象。<br>在进行Concurrent Marking 时minor GC 也可能会同时进行，这个时候很容易造成旧生代对象引用关系改变，CMS 为了应对这样的并发现象，提供了一个Mod Union Table 来进行记录，在这个Mod Union Table中记录每次minor GC 后修改了的Card 的信息。这也是ParallelScavenge不能和CMS一起使用的原因。<br>CMS产生浮动垃圾的情况请见如下示意图<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0410/60e7c659-790a-3405-af70-9ca4cfd9258d.jpg\" alt=\"\"><br>在运行回收过后，c就变成了浮动垃圾。<br>由于CMS会产生浮动垃圾，当回收过后，浮动垃圾如果产生过多，同时因为使用标记-清除算法会产生碎片，可能会导致回收过后的连续空间仍然不能容纳新生代移动过来或者新创建的大资源，因此会导致CMS回收失败，进而触发另外一次FULL GC，而这时候则采用SerialOld进行二次回收。<br>同时CMS因为可能产生浮动垃圾，而CMS在执行回收的同时新生代也有可能在进行回收操作，为了保证旧生代能够存放新生代转移过来的数据，CMS在旧生代内存到达全部容量的68%就触发了CMS的回收！</p>\n<h4 id=\"h4-7-garbagefirst-g1-\"><a name=\"7.GarbageFirst(G1)\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>7.GarbageFirst(G1)</h4><p>我们再来看垃圾回收器的总图，刚才我们可以看到，我在图上标记了一个？，其实这是一个新的垃圾回收器，既可以回收新生代也可以回收旧生代，SunHotSpot 1.6u14以上EarlyAccess版本加入了这个回收器，sun公司预期SunHotSpot1.7发布正式版，他是商用高性能垃圾回收器，通过重新划分内存区域，整合优化CMS，同时注重吞吐量和响应时间，但是杯具的是被Oracle收购之后这个收集器属于商用收费收集器，因此目前基本上没有人使用，我们在这里也就不多介绍，更多信息可以参考oracle新版本JDK说明。</p>\n</div>','2017-04-09',1,20,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(208,'java汇编','java 汇编 http://download.csdn.net/download/jiangfuqiang/8403497','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><p>java 汇编<br><a href=\"http://download.csdn.net/download/jiangfuqiang/8403497\">http://download.csdn.net/download/jiangfuqiang/8403497</a></p>\n</div>','2017-04-10',1,25,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(209,'jvm','-XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><p>-XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly</p>\n</div>','2017-04-10',1,31,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(210,'Adaboost','NaiveBayesSpamFilter 利用朴素贝叶斯算法实现垃圾邮件的过滤，并结合Adaboost改进该算法。 1 Naive Bayes spam filtering   假设邮件的内容中包含的词汇为Wi，垃圾邮件Spam，正常邮件ham。 判断一份邮件，内容包含的词汇为Wi，判断该邮件是否是垃圾邮件，即计算P（S|Wi）这个条件概率。根据Bayes’ theorem：   Bayes’ t','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h1 id=\"h1-naivebayesspamfilter\"><a name=\"NaiveBayesSpamFilter\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>NaiveBayesSpamFilter</h1><p>利用朴素贝叶斯算法实现垃圾邮件的过滤，并结合Adaboost改进该算法。</p>\n<h3 id=\"h3-1-naive-bayes-spam-filtering\"><a name=\"1 Naive Bayes spam filtering\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1 Naive Bayes spam filtering</h3><p>  假设邮件的内容中包含的词汇为Wi，垃圾邮件Spam，正常邮件ham。 判断一份邮件，内容包含的词汇为Wi，判断该邮件是否是垃圾邮件，即计算P（S|Wi）这个条件概率。根据Bayes’ theorem：</p>\n<p>  Bayes’ theorem</p>\n<p>  其中：</p>\n<p>Pr(S|Wi) 出现词汇Wi的邮件是垃圾邮件的条件概率（即后验概率）；<br>Pr(S) 训练阶段邮件数据集中垃圾邮件的概率，或实际调查的垃圾邮件的概率（即先验概率）；<br>Pr(Wi|S) 垃圾邮件中词汇Wi出现的概率；<br>Pr(H) 训练阶段邮件数据集中正常邮件的概率，或实际调查的正常邮件的概率；<br>Pr(Wi|H) 正常邮件中词汇Wi出现的概率；<br>  对于邮件中出现的所有词汇，考虑每个词汇出现事件的独立性，计算Pr(S|Wi)的联合概率Pr(S|W)，W={W1，W2，…Wn}：</p>\n<p>  Bayes’ theorem</p>\n<p>  其中：</p>\n<p>P 即Pr(S|W)，出现词汇W={W1，W2……Wn}的邮件是垃圾邮件的条件概率；<br>Pi 即Pr(S|Wi)，出现词汇Wi的邮件是垃圾邮件的条件概率；<br>  注： 程序中，通过计算出Pr(S|W)和Pr(H|W)，比较Pr(S|W)和Pr(H|W)的大小，判断是垃圾邮件还是正常邮件。我们发现Pr(S|W)和Pr(H|W)计算的分母相同，所以我们只需要比较分子即可。</p>\n<p>  但存在两个问题：</p>\n<p>当词汇不存在时，即ni=0，此时Pr(S|Wi) = 0，会造成P=0，无法比较<br>当Pr(S|Wi)较小时，连乘操作会造成下溢出问题<br>  解决方案：</p>\n<p>计算P(Wi|S)和P(Wi|H)时，将所有词汇初始化出现的次数为1，并将分母初始化为2（或根据样本/实际调查结果调整分母的值）。</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"com\"># 统计语料库中词汇在S和H中出现的次数</span></code></li><li class=\"L1\"><code><span class=\"pln\">wordsInSpamNum </span><span class=\"pun\">=</span><span class=\"pln\"> np</span><span class=\"pun\">.</span><span class=\"pln\">ones</span><span class=\"pun\">(</span><span class=\"pln\">numWords</span><span class=\"pun\">)</span></code></li><li class=\"L2\"><code><span class=\"pln\">wordsInHealthNum </span><span class=\"pun\">=</span><span class=\"pln\"> np</span><span class=\"pun\">.</span><span class=\"pln\">ones</span><span class=\"pun\">(</span><span class=\"pln\">numWords</span><span class=\"pun\">)</span></code></li><li class=\"L3\"><code><span class=\"pln\">spamWordsNum </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">2.0</span></code></li><li class=\"L4\"><code><span class=\"pln\">healthWordsNum </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">2.0</span></code></li></ol></pre><p>计算P(Wi|S)和P(Wi|H)时，对概率取对数<br>    pWordsSpamicity = np.log(wordsInSpamNum / spamWordsNum)<br>    pWordsHealthy = np.log(wordsInHealthNum / healthWordsNum)<br>  所以最终比较的是，P(W1|S)P(W2|S)….P(Wn|S)P(S)和P(W1|H)P(W2|H)….P(Wn|H)P(H)的大小。</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"pln\">ps </span><span class=\"pun\">=</span><span class=\"pln\"> sum</span><span class=\"pun\">(</span><span class=\"pln\">testWordsMarkedArray </span><span class=\"pun\">*</span><span class=\"pln\"> pWordsSpamicity</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">+</span><span class=\"pln\"> np</span><span class=\"pun\">.</span><span class=\"pln\">log</span><span class=\"pun\">(</span><span class=\"pln\">pSpam</span><span class=\"pun\">)</span></code></li><li class=\"L1\"><code><span class=\"pln\">ph </span><span class=\"pun\">=</span><span class=\"pln\"> sum</span><span class=\"pun\">(</span><span class=\"pln\">testWordsMarkedArray </span><span class=\"pun\">*</span><span class=\"pln\"> pWordsHealthy</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">+</span><span class=\"pln\"> np</span><span class=\"pun\">.</span><span class=\"pln\">log</span><span class=\"pun\">(</span><span class=\"lit\">1</span><span class=\"pln\"> </span><span class=\"pun\">-</span><span class=\"pln\"> pSpam</span><span class=\"pun\">)</span></code></li></ol></pre><p>  测试效果： 5574个样本，采用交叉验证，随机选取4574个作为训练样本，产生词汇列表（语料库），对1000个测试样本，分类的平均错误率约为：2.5%。</p>\n<h3 id=\"h3-2-running-adaboost-on-naive-bayes\"><a name=\"2 Running Adaboost on Naive Bayes\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2 Running Adaboost on Naive Bayes</h3><p>  我们在计算ps和ph联合后验概率时，可引入一个调整因子DS，其作用是调整词汇表中某一词汇的“垃圾程度”(spamicity)，</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"pln\">ps </span><span class=\"pun\">=</span><span class=\"pln\"> sum</span><span class=\"pun\">(</span><span class=\"pln\">testWordsMarkedArray </span><span class=\"pun\">*</span><span class=\"pln\"> pWordsSpamicity </span><span class=\"pun\">*</span><span class=\"pln\"> DS</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">+</span><span class=\"pln\"> np</span><span class=\"pun\">.</span><span class=\"pln\">log</span><span class=\"pun\">(</span><span class=\"pln\">pSpam</span><span class=\"pun\">)</span></code></li></ol></pre><p>  其中DS通过Adaboost算法迭代获取最佳值。原理如下：</p>\n<p>设定adaboost循环的次数count<br>交叉验证随机选择1000个样本<br>DS初始化为和词汇列表大小相等的全一向量<br>迭代循环count次：<br>    设定最小分类错误率为inf<br>    对于每一个样本：<br>        在当前DS下对样本分类<br>        如果分类出错：<br>            计算出错的程度，即比较ps和ph的相差alpha<br>            如果样本原本是spam，错分成ham：<br>                DS[样本包含的词汇] = np.abs(DS[样本包含的词汇] - np.exp(alpha) / DS[样本包含的词汇])<br>            如果样本原本是ham，错分成spam：<br>                DS[样本包含的词汇] = DS[样本包含的词汇] + np.exp(alpha) / DS[样本包含的词汇]<br>    计算错误率<br>    保存最小的错误率和此时的词汇列表、P(Wi|S)和P(Wi|H)、DS等信息，即保存训练好的最佳模型的信息<br>  测试效果： 5574个样本，获取Adaboost算法训练的最佳模型信息（包括词汇列表、P(Wi|S)和P(Wi|H)、DS等），对1000个测试样本，分类的平均错误率约为：0.5%。</p>\n</div>','2017-04-17',4,33,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(211,'Java堆.栈和常量池 笔记','Java堆.栈和常量池 笔记','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><p><a href=\"http://www.iteye.com/topic/634530\">Java堆.栈和常量池 笔记</a></p>\n</div>','2017-04-23',1,27,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(212,'redis','redis的数据结构 数据结构类型 结构存储的值 结构的读写能力 STRING 可以是字符串、整数、或者浮点数 对整个字符串或者字符串的其中一部分执行操作；对整数和浮点数执行自增或者自减 LIST 一个链表，链表上的每个节点都包含了一个字符串 从链表的两端推入或者弹出元素；根据偏移量对链表进行修剪；根据值查找或者移除元素 SET 包含字符串的无序收集器，并且被包含的每个字符串都是独一无二、各不相同','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h1 id=\"h1-redis-\"><a name=\"redis的数据结构\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>redis的数据结构</h1><table>\n<thead>\n<tr>\n<th>数据结构类型</th>\n<th>结构存储的值</th>\n<th>结构的读写能力</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>STRING</td>\n<td>可以是字符串、整数、或者浮点数</td>\n<td>对整个字符串或者字符串的其中一部分执行操作；对整数和浮点数执行自增或者自减</td>\n</tr>\n<tr>\n<td>LIST</td>\n<td>一个链表，链表上的每个节点都包含了一个字符串</td>\n<td>从链表的两端推入或者弹出元素；根据偏移量对链表进行修剪；根据值查找或者移除元素</td>\n</tr>\n<tr>\n<td>SET</td>\n<td>包含字符串的无序收集器，并且被包含的每个字符串都是独一无二、各不相同的</td>\n<td>添加、获取、移除单个元素；检查一个元素是否存在于集合中；计算交集、并集、差集；从集合里面随机获取元素</td>\n</tr>\n<tr>\n<td>HASH</td>\n<td>包含键值对的无语散列表</td>\n<td>添加、获取、移除单个键值对；获取所有键值对</td>\n</tr>\n<tr>\n<td>ZSET(有序集合)</td>\n<td>字符串成员与浮点数分值之间的有序映射，元素的排列顺序由分值的大小决定</td>\n<td>添加、获取、单个元素；根据分值范围或者成员来获取元素</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"h3--string-\"><a name=\"一、STRING基本操作\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、STRING基本操作</h3><p>（1）SET 设置存储在给定键中的值<br>（2）GET 获取存储在给定键中的值<br>（3）DEL 删除存储在给定键中的值</p>\n<h3 id=\"h3--list-\"><a name=\"二、LIST（列表）基本操作\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、LIST（列表）基本操作</h3><p>（1）RPUSH 将给定值推入列表的右端<br>（2）LRANGE 获取列表在给定范围上的所有值<br>（3）LINDEX 获取列表在给定位置上的单个元素<br>（4）LPOP 从列表的左端弹出一个值，并返回被弹出的值</p>\n<h3 id=\"h3--set-\"><a name=\"三、SET（集合）基本操作\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>　三、SET（集合）基本操作</h3><p>（1）SADD 将给定元素添加到集合<br>（2）SMEMBERS 返回集合包含的所有元素<br>（3）SISMEMBER 检查给定元素是否存在于集合中<br>（4）SREM 如果给定的元素存在于集合中，那么移除这个元素</p>\n<h3 id=\"h3--hash-\"><a name=\"四、HASH（散列）基本操作\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>四、HASH（散列）基本操作</h3><p>（1）HSET 在散列里面关联起给定的键值对<br>（2）HGET 获取指定散列键的值<br>（3）HGETALL 获取散列包含的所有键值对<br>（4）HDEL 如果给定键存在于散列里面，那么移除这个键</p>\n<h3 id=\"h3--zset-\"><a name=\"五、ZSET（有序集合）基本操作\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>五、ZSET（有序集合）基本操作</h3><p>（1）ZADD 将一个带有给定分值的成员添加到有序集合里面<br>（2）ZRANGE 根据元素在有序排列中所处的位置，从有序集合里面获取多个元素<br>（3）ZRANGEBYSCORE 获取有序集合在给定分值范围的所有元素<br>（4）ZREM 如果给定成员存在于有序集合，那么移除这个成员</p>\n</div>','2017-05-04',6,27,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(213,'工厂模式','工厂模式 目录 何为工厂模式 工厂方法与抽象工厂 如何在Java EE中通过@Producers与@Inject注解实现工厂模式 如何创建自定义注解以及通过@Qualifier消除具体实现之间的歧义 工厂模式有两种模式：工厂方法和抽象方法。它们的意图是一样的：提供一个接口，在不指定具体类的情况下创建相关或依赖的一系列对象。 一.何为工厂模式 工厂的目的在于创建对象。创建的逻辑被封装在工厂中，要么提','<h1 id=\"h1-u5DE5u5382u6A21u5F0F\"><a name=\"工厂模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>工厂模式</h1><p>目录</p>\r\n<ul>\r\n<li>何为工厂模式</li><li>工厂方法与抽象工厂</li><li>如何在Java EE中通过<a href=\"https://github.com/Producers\" title=\"&#64;Producers\" class=\"at-link\">@Producers</a>与<a href=\"https://github.com/Inject\" title=\"&#64;Inject\" class=\"at-link\">@Inject</a>注解实现工厂模式</li><li>如何创建自定义注解以及通过<a href=\"https://github.com/Qualifier\" title=\"&#64;Qualifier\" class=\"at-link\">@Qualifier</a>消除具体实现之间的歧义<br>工厂模式有两种模式：工厂方法和抽象方法。它们的意图是一样的：提供一个接口，在不指定具体类的情况下创建相关或依赖的一系列对象。</li></ul>\r\n<h3 id=\"h3--\"><a name=\"一.何为工厂模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一.何为工厂模式</h3><p>工厂的目的在于创建对象。创建的逻辑被封装在工厂中，要么提供一个方法来返回新创建的对象（工厂方法模式），要么将对象的创建委托给子类（抽象工厂模式）。<br>客户端不必考虑接口或类的不同实现，它只需通过工厂（工厂）获取接口实现的一个实例的即可，这样客户端与对象的创建就实现了解耦<br>解耦是应用依赖反转原则的结果，这带来了很多好处，其中最重要的好处就是实现了高层类与底层类之间的解耦。通过解耦，具体类实现的变化不会影响到客户端，这降低了类与类之间的耦合，并提升了灵活性。</p>\r\n<h3 id=\"h3--\"><a name=\"二.工厂方法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二.工厂方法</h3><p>GoF一书是这样描述工程方法模式的：“定义一个用于创建对象的接口，不过让子类决定实例化那个类”<br>工厂极大降低了new关键字的使用次数，并且将初始化过程与不同的具体实现封装起来。将这些需求中心化可以极大减少向系统中添加或删除具体类的影响以及具体的类依赖的影响。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src=\"http://ohlrxdl4p.bkt.clouddn.com/images/QQ截图20170506134421.jpg\" alt=\"\"><br><strong>1.使用普通代码实现工厂方法</strong><br>被具体实现继承的DrinksMachine抽象类</p>\r\n<pre><code class=\"lang-java\">public abstract class DrinksMachine {\r\n    public abstract Drink dispenseDrink();\r\n    public String displayMessage(){\r\n        return &quot;Thank for your custom.&quot;;\r\n    }\r\n}\r\n</code></pre>\r\n<p>DrinksMachine抽象类的CoffeeMachine实现</p>\r\n<pre><code class=\"lang-java\">public class CoffeeMachine extends DrinksMachine {\r\n    public Drink dispenseDrink() {\r\n        return new Coffee();\r\n    }\r\n}\r\n</code></pre>\r\n<p>DrinksMachine抽象类的SoftDrinksMachine实现</p>\r\n<pre><code class=\"lang-java\">public class SoftDrinksMachine extends DrinksMachine {\r\n    public Drink dispenseDrink() {\r\n        return new SoftDrink();\r\n    }\r\n}\r\n</code></pre>\r\n<p>Drink接口</p>\r\n<pre><code class=\"lang-java\">public interface Drink {}\r\n</code></pre>\r\n<p>Drink接口的SoftDrink实现</p>\r\n<pre><code class=\"lang-java\">public class SoftDrink implements Drink {\r\n    SoftDrink() {\r\n        System.out.println(&quot;Soft drink&quot;);\r\n    }\r\n}\r\n</code></pre>\r\n<p>Drink接口的Coffee实现</p>\r\n<pre><code class=\"lang-java\">public class Coffee implements Drink {\r\n    Coffee() {\r\n        System.out.println(&quot;Coffee&quot;);\r\n    }\r\n}\r\n</code></pre>\r\n<p>CoffeeType枚举<br>```java<br>public enum CoffeeType {EXPRESSO, LATTE}</p>\r\n<p>public Drink dispenseDrink(CoffeeType type) {<br>    Drink coffee = null;<br>    switch (type) {<br>        case EXPRESSO: coffee = new Expresso();<br>        case LATTE: coffee = new Latte();<br>    }<br>    return coffee;<br>}<br>```&lt;!--前面不能有空格--&gt;</p>','2017-05-06',1,29,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(214,'代理模式','代理模式(Proxy Pattern) GoF中给出的代理模式的定义为： 代理模式给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。 代理模式的英文叫做Proxy或Surrogate，它是一种对象结构型模式。 代理模式根据其目的和实现可分为很多种类，常用的代理模式包括如下几种： （1）远程代理（Remote Proxy）————为一个位于不同的地址空间的对象提供一个本地的代理对象','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h1 id=\"h1--proxy-pattern-\"><a name=\"代理模式(Proxy Pattern)\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代理模式(Proxy Pattern)</h1><p>GoF中给出的代理模式的定义为：<br>代理模式给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。<br>代理模式的英文叫做Proxy或Surrogate，它是一种对象结构型模式。<br>代理模式根据其目的和实现可分为很多种类，常用的代理模式包括如下几种：<br>（1）远程代理（Remote Proxy）————为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以是在同一台主机中，也可以是在另一台主机中，远程代理又称为大使（Ambassador）<br>（2）虚拟代理（Virtual Proxy）————如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。<br>（3）保护代理（Protect Proxy）————控制一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。<br>（4）缓冲代理（Cache Proxy）————为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。<br>（5）只能引用代理（Smart Reference Proxy）————当一个对象被引用时，提供一些额外的操作，例如将对象被调用的次数记录下来。<br><img src=\"http://ohlrxdl4p.bkt.clouddn.com/images/QQ截图20170507103646.jpg\" alt=\"\"></p>\n<p>代码实现：<br>1.抽象主题类——BuyTicket.java</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code class=\"lang-java\"><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">interface</span><span class=\"pln\"> </span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> showticket</span><span class=\"pun\">();</span></code></li><li class=\"L2\"><code class=\"lang-java\"><span class=\"pun\">}</span></code></li></ol></pre>\n<p>2.具体主题类——Train.java</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code class=\"lang-java\"><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Train</span><span class=\"pln\"> </span><span class=\"kwd\">implements</span><span class=\"pln\"> </span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"lit\">@Override</span></code></li><li class=\"L2\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> showticket</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L3\"><code class=\"lang-java\"><span class=\"pln\">        </span><span class=\"typ\">System</span><span class=\"pun\">.</span><span class=\"pln\">out</span><span class=\"pun\">.</span><span class=\"pln\">println</span><span class=\"pun\">(</span><span class=\"str\">\"one ticket\"</span><span class=\"pun\">);</span></code></li><li class=\"L4\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L5\"><code class=\"lang-java\"><span class=\"pun\">}</span></code></li></ol></pre>\n<p>3.代理角色类——TicketCenter.java</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code class=\"lang-java\"><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">TicketCenter</span><span class=\"pln\"> </span><span class=\"kwd\">implements</span><span class=\"pln\"> </span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> ticket</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code class=\"lang-java\"></code></li><li class=\"L3\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"typ\">TicketCenter</span><span class=\"pun\">(</span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> ticket</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code class=\"lang-java\"><span class=\"pln\">        </span><span class=\"kwd\">this</span><span class=\"pun\">.</span><span class=\"pln\">ticket </span><span class=\"pun\">=</span><span class=\"pln\"> ticket</span><span class=\"pun\">;</span></code></li><li class=\"L5\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code class=\"lang-java\"></code></li><li class=\"L7\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"lit\">@Override</span></code></li><li class=\"L8\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> showticket</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L9\"><code class=\"lang-java\"><span class=\"pln\">        ticket</span><span class=\"pun\">.</span><span class=\"pln\">showticket</span><span class=\"pun\">();</span></code></li><li class=\"L0\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code class=\"lang-java\"></code></li><li class=\"L2\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> buy</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L3\"><code class=\"lang-java\"><span class=\"pln\">        </span><span class=\"typ\">System</span><span class=\"pun\">.</span><span class=\"pln\">out</span><span class=\"pun\">.</span><span class=\"pln\">println</span><span class=\"pun\">(</span><span class=\"str\">\"by proxy\"</span><span class=\"pun\">);</span></code></li><li class=\"L4\"><code class=\"lang-java\"><span class=\"pln\">        showticket</span><span class=\"pun\">();</span></code></li><li class=\"L5\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code class=\"lang-java\"><span class=\"pun\">}</span></code></li></ol></pre>\n<p>4.客户端测试类</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code class=\"lang-java\"><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">ProxyPattern</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> main</span><span class=\"pun\">(</span><span class=\"typ\">String</span><span class=\"pln\"> args</span><span class=\"pun\">[])</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L2\"><code class=\"lang-java\"><span class=\"pln\">        </span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> x </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Train</span><span class=\"pun\">();</span></code></li><li class=\"L3\"><code class=\"lang-java\"><span class=\"pln\">        </span><span class=\"typ\">TicketCenter</span><span class=\"pln\"> y </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">TicketCenter</span><span class=\"pun\">(</span><span class=\"pln\">x</span><span class=\"pun\">);</span></code></li><li class=\"L4\"><code class=\"lang-java\"><span class=\"pln\">        y</span><span class=\"pun\">.</span><span class=\"pln\">buy</span><span class=\"pun\">();</span></code></li><li class=\"L5\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code class=\"lang-java\"><span class=\"pun\">}</span></code></li></ol></pre>\n<p>运行结果：</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code class=\"lang-html\"><span class=\"pln\">by proxy</span></code></li><li class=\"L1\"><code class=\"lang-html\"><span class=\"pln\">one ticket</span></code></li></ol></pre>\n</div>','2017-05-07',1,21,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(270,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,14,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(271,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,21,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(272,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,20,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(273,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,20,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(274,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,20,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(275,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,20,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(276,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,19,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(277,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,18,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(278,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,16,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(279,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,16,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(280,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,18,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(281,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,20,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(282,'BSbsbsbs','heloo 哦i已被肉','<h1 id=\"h1-heloo-i-\"><a name=\"heloo 哦i已被肉\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>heloo 哦i已被肉</h1>','2017-01-23',3,26,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(283,'2017-02-28学习笔记','','<p><img src=\"http://ohlrxdl4p.bkt.clouddn.com/images/826546_1482322555369_C5DABB18734059E89A45A0E9170722B0.png\" alt=\"\"></p>','2017-02-28',1,30,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(284,'2017-03-01学习笔记','知识点 1.java中只有值传递，没有引用传递http://guhanjie.iteye.com/blog/1683637 2.final关键字 final修饰变量，则等同于常量. final修饰方法中的参数，称为最终参数. final修饰类，则类不能被继承. final修饰方法，则方法不能被','<h1 id=\"h1-u77E5u8BC6u70B9\"><a name=\"知识点\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>知识点</h1><h4 id=\"h4-1-java-http-guhanjie-iteye-com-blog-1683637\"><a name=\"1.java中只有值传递，没有引用传递  http://guhanjie.iteye.com/blog/1683637\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.java中只有值传递，没有引用传递<a href=\"http://guhanjie.iteye.com/blog/1683637\">http://guhanjie.iteye.com/blog/1683637</a></h4><h4 id=\"h4-2-final-\"><a name=\"2.final关键字\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.final关键字</h4><ul>\r\n<li>final修饰变量，则等同于常量.</li><li>final修饰方法中的参数，称为最终参数.</li><li>final修饰类，则类不能被继承.</li><li>final修饰方法，则方法不能被重写.</li></ul>\r\n<h4 id=\"h4-3-integer-img-src-https-uploadfiles-nowcoder-com-images-20160717-6316247_1468761643205_9f7b85ab04292cf73778d98998a20ed1-alt-\"><a name=\"3.Integer<img src=\"https://uploadfiles.nowcoder.com/images/20160717/6316247_1468761643205_9F7B85AB04292CF73778D98998A20ED1\" alt=\"图片\">\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.Integer<img src=\"https://uploadfiles.nowcoder.com/images/20160717/6316247_1468761643205_9F7B85AB04292CF73778D98998A20ED1\" alt=\"图片\"></h4><h4 id=\"h4-4-java-\"><a name=\"4.java内存模型   点击原文\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.java内存模型 <a href=\"http://blog.csdn.net/ns_code/article/details/17565503\">点击原文</a></h4><p><img src=\"https://uploadfiles.nowcoder.com/images/20161223/415611_1482452184396_6FB53C51539B47559CF0D122A832CF63\" alt=\"\"></p>\r\n<h4 id=\"h4-5-java-reference\"><a name=\"5.java中是没有指针的，有reference\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.java中是没有指针的，有reference</h4><p>第一：指针变量是在栈内存中，它也是有值的，这个值存储的就是地址单元，这个地址就是来自于赋值操作。<br>第二：指针变量有类型，这个类型（如Person）的含义是指针指向的变量在栈内存（不是很确定）中的范围（大小），我理解为是占用的堆内存空间。<br>第三：声明一个对象时，是对“指针变量”的定义。<br>第四：用new关键字在堆内存创建了对象，在赋值时，是把这个对象的首地址传给了这个“指针变量”（即引用型变量）。</p>\r\n<h4 id=\"h4-6-string-\"><a name=\"6.String生成常量\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6.String生成常量</h4><pre><code class=\"lang-java\">String s1=&quot;abc&quot;+&quot;def&quot;;//生成的是一个常量，放在堆内存中\r\nString s2=new String（s1);//s2是一个变量\r\nif(s1.equals(s2))//比较的是字符串的内容\r\n    System.out.println(&quot;.equals succeeded&quot;);//输出\r\nif(s1==s2)//比较的是内存地址，但s1是常量，所以不相等\r\n    System.out.println(&quot;==succeeded&quot;);\r\n</code></pre>\r\n<h4 id=\"h4-7-jsp-\"><a name=\"7.jsp内置对象和属性\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>7.jsp内置对象和属性</h4><p>（１）request对象<br>客户端的请求信息被封装在request对象中，通过它才能了解到客户的需求，然后做出响应。它是HttpServletRequest类的实例。<br>（２）response对象<br>response对象包含了响应客户请求的有关信息，但在JSP中很少直接用到它。它是HttpServletResponse类的实例。<br>（３）session对象<br>session对象指的是客户端与服务器的一次会话，从客户连到服务器的一个WebApplication开始，直到客户端与服务器断开连接为止。它是HttpSession类的实例.<br>（４）out对象<br>out对象是JspWriter类的实例,是向客户端输出内容常用的对象<br>（５）page对象<br>page对象就是指向当前JSP页面本身，有点象类中的this指针，它是java.lang.Object类的实例<br>（６）application对象<br>application对象实现了用户间数据的共享，可存放全局变量。它开始于服务器的启动，直到服务器的关闭，在此期间，此对象将一直存在；这样在用户的前后连接或不同用户之间的连接中，可以对此对象的同一属性进行操作；在任何地方对此对象属性的操作，都将影响到其他用户对此的访问。服务器的启动和关闭决定了application对象的生命。它是ServletContext类的实例。<br>（７）exception对象<br>exception对象是一个例外对象，当一个页面在运行过程中发生了例外，就产生这个对象。如果一个JSP页面要应用此对象，就必须把isErrorPage设为true，否则无法编译。他实际上是java.lang.Throwable的对象<br>（８）pageContext对象<br>pageContext对象提供了对JSP页面内所有的对象及名字空间的访问，也就是说他可以访问到本页所在的SESSION，也可以取本页面所在的application的某一属性值，他相当于页面中所有功能的集大成者，它的本 类名也叫pageContext。<br>（９）config对象<br>config对象是在一个Servlet初始化时，JSP引擎向它传递信息用的，此信息包括Servlet初始化时所要用到的参数（通过属性名和属性值构成）以及服务器的有关信息（通过传递一个ServletContext对象）</p>','2017-03-01',1,35,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(285,'2017-03-02学习笔记','知识点 一、static public class Spike\r\n{\r\n    public static void main(String[] args)\r\n    {\r\n        Counter a = new Counter();\r\n        System.out.println(a.increment());\r\n        System.out.println(a.anot','<h1 id=\"h1-u77E5u8BC6u70B9\"><a name=\"知识点\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>知识点</h1><h4 id=\"h4--static\"><a name=\"一、static\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、static</h4><pre><code class=\"lang-java\">public class Spike\r\n{\r\n    public static void main(String[] args)\r\n    {\r\n        Counter a = new Counter();\r\n        System.out.println(a.increment());\r\n        System.out.println(a.anotherIncrement());\r\n        Counter b = new Counter();\r\n        System.out.println(b.increment());\r\n    }\r\n}\r\nclass Counter\r\n{\r\n    private static int count = 0;\r\n    public int increment()\r\n    {\r\n        return count++;\r\n    }\r\n    public int anotherIncrement()\r\n    {\r\n        return ++count;\r\n    }\r\n}\r\n</code></pre>\r\n<p>count是静态变量，为所有对象所共享，因此不管a.increment()还是b.increment()都会使count持续增加。<br>increment()方法返回当前count值，然后count增加1<br>antoherIncrement()方法让count增加1，然后返回count值<br>第一次a.increment()返回值为0，此时count值为1<br>第二次a.anotherIncrement()先让count+1再返回，返回值为2<br>第三次b.increment()先返回count当前值2，然后count+1</p>\r\n<h4 id=\"h4--aop-\"><a name=\"二、AOP面向切面\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、AOP面向切面</h4><p>AOP的概念是Aspected Oriented Programming 面向方面编程。<br>  好处：AOP将程序分解成各个方面或者说关注点。这使得可以模块化，相当横向上分切了。它可以解决OOP和过程化方法不能够很好解决的横切（crosscut）问题，如：事务、安全、日志等横切关注。<br>  实现AOP有几种方式:<br>  1.Spring 1.2版本中通过ProxyFactoryBean来实现aop,即通过动态代理来实现的,Aspect必须继承MethodBeforeAdvice,MethodAfterAdvice等<br>  2.Spring 2.0 AOP需要改的是FBI 这个类，而且它也不需要再实现某些接口<br>  3.三使用标注（<a href=\"https://github.com/AspectJ\" title=\"&#64;AspectJ\" class=\"at-link\">@AspectJ</a>）实现AOP<br>    AOP 和 OOP的区别：</p>\r\n<pre><code>```html\r\n 1. 面向方面编程 AOP 偏重业务处理过程的某个步骤或阶段，强调降低模块之间的耦合度，使代码拥有更好的移植性。  \r\n 2. 面向对象编程 (oop) 则是对业务分析中抽取的实体进行方法和属性的封装。\r\n ```\r\n</code></pre><p>也可以说 AOP 是面向业务中的动词领域， OOP 面向名词领域。<br>AOP 的一个很重要的特点是源代码无关性，也就是说如果我们的系统中引用了 AOP 组件，即使我们把该组件去掉，系统代码也应该能够编译通过。要实现这一点，可以使用动态 proxy 模式。</p>\r\n<h4 id=\"h4--jdbc-\"><a name=\"三、jdbc桥接模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、jdbc桥接模式</h4><p>桥接模式：<br>定义 ：将抽象部分与它的实现部分分离，使它们都可以独立地变化。<br>意图 ：将抽象与实现解耦。<br>桥接模式所涉及的角色</p>\r\n<ol>\r\n<li>Abstraction ：定义抽象接口，拥有一个Implementor类型的对象引用</li><li>RefinedAbstraction ：扩展Abstraction中的接口定义</li><li>Implementor ：是具体实现的接口，Implementor和RefinedAbstraction接口并不一定完全一致，实际上这两个接口可以完全不一样Implementor提供具体操作方法，而Abstraction提供更高层次的调用</li><li>ConcreteImplementor ：实现Implementor接口，给出具体实现<br>Jdk中的桥接模式：JDBC<br>JDBC连接 数据库 的时候，在各个数据库之间进行切换，基本不需要动太多的代码，甚至丝毫不动，原因就是JDBC提供了统一接口，每个数据库提供各自的实现，用一个叫做数据库驱动的程序来桥接就行了<h4 id=\"h4--\"><a name=\"四、抽象类\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>四、抽象类</h4>抽象类和普通类有三点区别：<br>1）抽象方法必须为public和protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public。<br>2）抽象类不能用来创建对象，但是它可以有构造方法，用来帮助子类实例化。<br>3）如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为abstract类。<h4 id=\"h4--\"><a name=\"五、接口\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>五、接口</h4>接口的主要特点<br>1）接口中的成员变量默认都是public、static、final类型的，必须被显示初始化。<br>2）接口中的方法默认都是public、abstract类型的。<br>3）接口中只能包含public、static、final类型的成员变量和public、abstract类型的成员方法。<br>4）接口没有构造方法，不能被实例化。<br>5）一个接口不能实现另一个接口，但它可以继承多个其他接口。<br>6）接口必须通过类来实现它的抽象方法。<br>7）与子类继承抽象父类相似，当类实现了某个接口时，它必须实现接口中所有的抽象方法，否则这个类必须被定义为抽象类。<br>8）一个类只能继承一个直接的父类，但能实现多个接口。<h4 id=\"h4--\"><a name=\"六、抽象类和接口的区别\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>六、抽象类和接口的区别</h4>1）抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract方法；<br>2）抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；<br>3）接口中不能含有静态代码块以及静态方法，而抽象类尅有静态代码块和静态方法；<br>4）一个类只能继承一个抽象类，而一个类却可以实现多个接口。<br>5）抽象类中的方法子类必须全部实现，不然子类也是抽象类，而接口中的抽象方法子类必须全部实现，是可选择实现的。<br>6）抽象类是一种模板设计模式，而接口时一种行为规范。</li></ol>','2017-03-02',1,35,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(286,'2017-03-03学习笔记','一、String StringBuffer.toString()源码： @Override\r\npublic synchronized String toString() {\r\n    if (toStringCache == null) {\r\n        toStringCache = Arrays.copyOfRange(value, 0, count);\r\n    }\r\n    retur','<h4 id=\"h4--string\"><a name=\"一、String\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、String</h4><p>StringBuffer.toString()源码：</p>\r\n<pre><code class=\"lang-java\">@Override\r\npublic synchronized String toString() {\r\n    if (toStringCache == null) {\r\n        toStringCache = Arrays.copyOfRange(value, 0, count);\r\n    }\r\n    return new String(toStringCache, true);\r\n}\r\n</code></pre>\r\n<p>Arrays.copyOfRange用的是System.arraycopy</p>\r\n<pre><code class=\"lang-java\">public static char[] copyOfRange(char[] original, int from, int to) {\r\n        int newLength = to - from;\r\n        if (newLength &lt; 0)\r\n            throw new IllegalArgumentException(from + &quot; &gt; &quot; + to);\r\n        char[] copy = new char[newLength];\r\n        System.arraycopy(original, from, copy, 0,\r\n                         Math.min(original.length - from, newLength));\r\n        return copy;\r\n    }\r\n</code></pre>\r\n<p>1.String是值传入，不是引用传入。<br>2.String对String  类型进行改变的时候其实都等同于生成了一个新的  String  对象，然后将指针指向新的  String  对象，而不是StringBuffer；StringBuffer每次结果都会对  StringBuffer  对象本身进行操作，而不是生成新的对象，再改变对象引用。<br>3.效率比较String&lt;StringBuffer&lt;StringBuilder，但是在 String S1 = “This is only a” + “ simple” + “ test”时，String效率最高。</p>\r\n<h4 id=\"h4--jvm-\"><a name=\"二、jvm知识图谱\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、jvm知识图谱</h4><p><a href=\"https://zhuanlan.zhihu.com/p/25511795\">引用自知乎</a><br><img src=\"https://pic2.zhimg.com/v2-701563ac1fe745fc8e1234c96e82ac99_r.jpg\" alt=\"\"></p>\r\n<h4 id=\"h4--treemap-linkhashmap\"><a name=\"三、Treemap、LinkHashMap\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、Treemap、LinkHashMap</h4><p>1.TreeMap取出来的是排序后的键值对。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。<br>2.LinkedHashMap 是HashMap的一个子类，如果需要输出的顺序和输入的相同,那么用LinkedHashMap可以实现,它还可以按读取顺序来排列。</p>\r\n<h4 id=\"h4--sql-\"><a name=\"四、sql模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>四、sql模式</h4><p>MySQL数据库中，变量分为 系统变量（以”@@”开头）和用户自定义变量。系统变量分为全局系统变量(global)和会话系统变量(session)。<br>@<a href=\"https://github.com/global\" title=\"&#64;global\" class=\"at-link\">@global</a>     仅用于访问全局系统变量的值；<br>@<a href=\"https://github.com/session\" title=\"&#64;session\" class=\"at-link\">@session</a>  仅用于访问会话系统变量的值；<br>@@              先访问会话系统变量的值，若不存在则去访问全局系统变量的值；<br>sql_mode 为系统变量，既是全局系统变量，又是会话系统变量。</p>\r\n<h4 id=\"h4--\"><a name=\"五、代码的执行顺序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>五、代码的执行顺序</h4><p>父类Ｂ静态代码块-&gt;子类Ａ静态代码块-&gt;父类Ｂ非静态代码块-&gt;父类Ｂ构造函数-&gt;子类Ａ非静态代码块-&gt;子类Ａ构造函数<br><img src=\"http://ohlrxdl4p.bkt.clouddn.com/images/QQ截图20170303165728.jpg\" alt=\"\"></p>','2017-03-03',1,37,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(287,'ifhifhajfe','hello','<h1 id=\"h1-hello\"><a name=\"hello\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>hello</h1>','2017-03-05',1,35,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(288,'2017-03-05学习笔记','java的堆，栈，静态代码区（常量区） 详解','<p><a href=\"http://blog.csdn.net/u012031380/article/details/54981472\"> java的堆，栈，静态代码区（常量区） 详解</a></p>','2017-03-05',1,34,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(289,'java归并排序','package datastruct;\r\n\r\n/**\r\n * Created by Zephery on 2017/3/3.\r\n */\r\npublic class Solution {\r\n    public static void printArray(int[] arr, int i, int j) {\r\n        System.out.print(\"[\");\r\n        for','<pre><code class=\"lang-java\">package datastruct;\r\n\r\n/**\r\n * Created by Zephery on 2017/3/3.\r\n */\r\npublic class Solution {\r\n    public static void printArray(int[] arr, int i, int j) {\r\n        System.out.print(&quot;[&quot;);\r\n        for (int k = i; k &lt; j; k++) {\r\n            System.out.print(arr[k] + &quot;,&quot;);\r\n        }\r\n        System.out.print(arr[j] + &quot;]&quot;);\r\n    }\r\n\r\n    private static void mergesort(int[] arr, int i, int j) {\r\n        int mid = 0;\r\n        if (i &lt; j) {\r\n            mid = (i + j) / 2;\r\n            mergesort(arr, i, mid);\r\n            mergesort(arr, mid + 1, j);\r\n            merge(arr, i, mid, j);\r\n        }\r\n    }\r\n\r\n    private static void merge(int[] arr, int i, int mid, int j) {\r\n        System.out.print(&quot;Left:&quot;);\r\n        printArray(arr, i, mid);\r\n        System.out.println(&quot;Right:&quot;);\r\n        printArray(arr, mid + 1, j);\r\n        System.out.println();\r\n        int temp[] = new int[arr.length];\r\n        int l = i;\r\n        int r = j;\r\n        int m = mid + 1;\r\n        int k = l;\r\n        while (l &lt;= mid &amp;&amp; m &lt;= r) {\r\n            if (arr[l] &lt;= arr[m]) {\r\n                temp[k++] = arr[l++];\r\n            } else {\r\n                temp[k++] = arr[m++];\r\n            }\r\n        }\r\n        while (l &lt;= mid) {\r\n            temp[k++] = arr[l++];\r\n        }\r\n        while (m &lt;= r) {\r\n            temp[k++] = arr[m++];\r\n        }\r\n        for (int i1 = i; i1 &lt;= j; i1++) {\r\n            arr[i1] = temp[i1];\r\n        }\r\n        System.out.print(&quot;After Merge:&quot;);\r\n        printArray(arr, i, j);\r\n        System.out.println();\r\n    }\r\n\r\n    public static void main(String args[]) {\r\n        int[] arr = {9, 4, 8, 3, 1, 2, 5};\r\n        System.out.print(&quot;Initial Array:&quot;);\r\n        printArray(arr, 0, arr.length - 1);\r\n        System.out.println();\r\n        mergesort(arr, 0, arr.length - 1);\r\n    }\r\n}\r\n</code></pre>\r\n<pre><code class=\"lang-js\">Initial Array:[9,4,8,3,1,2,5]\r\nLeft:[9]Right:\r\n[4]\r\nAfter Merge:[4,9]\r\nLeft:[8]Right:\r\n[3]\r\nAfter Merge:[3,8]\r\nLeft:[4,9]Right:\r\n[3,8]\r\nAfter Merge:[3,4,8,9]\r\nLeft:[1]Right:\r\n[2]\r\nAfter Merge:[1,2]\r\nLeft:[1,2]Right:\r\n[5]\r\nAfter Merge:[1,2,5]\r\nLeft:[3,4,8,9]Right:\r\n[1,2,5]\r\nAfter Merge:[1,2,3,4,5,8,9]\r\n</code></pre>','2017-03-06',1,33,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(290,'2017-03-10学习笔记','1.Integer和int，装箱拆箱 1、基本型和基本型封装型进行“==”运算符的比较，基本型封装型将会自动拆箱变为基本型后再进行比较，因此Integer(0)会自动拆箱为int类型再进行比较，显然返回true； 2、两个Integer类型进行“==”比较，如果其值在-128至127，那么返回true，否则返回false, 这跟Integer.valueOf()的缓冲对象有关，这里不进行赘述。 3','<h1 id=\"h1-1-integer-int-\"><a name=\"1.Integer和int，装箱拆箱\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.Integer和int，装箱拆箱</h1><p>1、基本型和基本型封装型进行“==”运算符的比较，基本型封装型将会自动拆箱变为基本型后再进行比较，因此Integer(0)会自动拆箱为int类型再进行比较，显然返回true；<br>2、两个Integer类型进行“==”比较，如果其值在-128至127，那么返回true，否则返回false, 这跟Integer.valueOf()的缓冲对象有关，这里不进行赘述。<br>3、两个基本型的封装型进行equals()比较，首先equals()会比较类型，如果类型相同，则继续比较值，如果值也相同，返回true<br>4、基本型封装类型调用equals(),但是参数是基本类型，这时候，先会进行自动装箱，基本型转换为其封装类型，再进行3中的比较。</p>\r\n<pre><code class=\"lang-java\">int a=257;\r\nInteger b=257;\r\nInteger c=257;\r\nInteger b2=57;\r\nInteger c2=57;\r\nSystem.out.println(a==b);\r\n//System.out.println(a.equals(b));  编译出错，基本型不能调用equals()\r\nSystem.out.println(b.equals(257.0));\r\nSystem.out.println(b==c);\r\nSystem.out.println(b2==c2);\r\n</code></pre>\r\n<p>因此上面的代码的结果因此为 true, false, false, true</p>\r\n<h1 id=\"h1-2-\"><a name=\"2.线程调度\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.线程调度</h1><p>分为协同式调度和抢占式调度，Java使用的是抢占式调度，也就是每个线程将由操作系统来分配执行时间，线程的切换不由线程本身来决定（协同式调度）。这就是平台独立的原因。</p>\r\n<h1 id=\"h1-3-\"><a name=\"3.重载，重写\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.重载，重写</h1><p>重写：<br>两同，两小，一大<br>两同：方法名，方法参数列表相同。<br>两小：抛出的异常类型要小于等于父类，返回值类型要小于等于父类<br>一大：访问权限大于等于父类。<br>重载：<br>在同一个类中，方法名和方法参数列表不同，其他的（访问权限、返回值）随意。</p>\r\n<h1 id=\"h1-4-jvm-\"><a name=\"4.  JVM面试题\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.<a href=\"http://blog.csdn.net/hsk256/article/details/49104955\">JVM面试题</a></h1>','2017-03-10',1,29,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(291,'2017-03-12学习笔记','1.继承的加载顺序 执行顺序大体上可以说是先父类后子类，父类static域 ==》子类static域 ==》父类数据成员域 ==》父类构造器 ==》子类数据成员域 ==》子类构造器 2.优化Hibernate所鼓励的7大措施： 1.尽量使用many-to-one，避免使用单项one-to-many 2.灵活使用单向one-to-many 3.不用一对一，使用多对一代替一对一 4.配置对象缓存，不使','<h4 id=\"h4-1-\"><a name=\"1.  继承的加载顺序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.<a href=\"http://www.cnblogs.com/SirSmith/p/5536288.html\">继承的加载顺序</a></h4><p><img src=\"http://images2015.cnblogs.com/blog/452847/201605/452847-20160527221410288-2119099273.png\" alt=\"\"></p>\r\n<p>执行顺序大体上可以说是先父类后子类，父类static域 ==》子类static域 ==》父类数据成员域 ==》父类构造器 ==》子类数据成员域 ==》子类构造器</p>\r\n<h4 id=\"h4-2-hibernate-7-\"><a name=\"2.优化Hibernate所鼓励的7大措施：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.优化Hibernate所鼓励的7大措施：</h4><p>1.尽量使用many-to-one，避免使用单项one-to-many<br>2.灵活使用单向one-to-many<br>3.不用一对一，使用多对一代替一对一<br>4.配置对象缓存，不使用集合缓存<br>5.一对多使用Bag 多对一使用Set<br>6.继承使用显示多态 HQL:from object polymorphism=”exlicit” 避免查处所有对象<br>7.消除大表，使用二级缓存</p>\r\n<h4 id=\"h4-3-java-\"><a name=\"3.java中的数据类型分类：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.java中的数据类型分类：</h4><p>基本数据类型（或叫做原生类、内置类型）8种：<br>    整数：byte，short，int，long（默认是int类型）<br>    浮点类型： float，double（默认是double类型）<br>    字符类型：char<br>    布尔类型：boolean<br>引用数据类型3种：数组，类，接口</p>\r\n<h4 id=\"h4-4-\"><a name=\"4.触发器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.触发器</h4><p>drop trigger 删除触发器<br>Drop用于删除数据表或数据库，或删除数据表字段。<br>remove：删除数据库文件<br>Truncate：删除数据表中的数据（仅数据表中的数据，不删除表）。</p>','2017-03-12',1,27,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(292,'2017-03-14学习笔记','1.Servlet的生命周期分为5个阶段：加载、创建、初始化、处理客户请求、卸载。 (1)加载：容器通过类加载器使用servlet类对应的文件加载servlet (2)创建：通过调用servlet构造函数创建一个servlet对象 (3)初始化：调用init方法初始化 (4)处理客户请求：每当有一个客户请求，容器会创建一个线程来处理客户请求 (5)卸载：调用destroy方法让servlet自己释','<h4 id=\"h4-1-servlet-5-\"><a name=\"1.Servlet的生命周期分为5个阶段：加载、创建、初始化、处理客户请求、卸载。\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.Servlet的生命周期分为5个阶段：加载、创建、初始化、处理客户请求、卸载。</h4><p>(1)加载：容器通过类加载器使用servlet类对应的文件加载servlet<br>(2)创建：通过调用servlet构造函数创建一个servlet对象<br>(3)初始化：调用init方法初始化<br>(4)处理客户请求：每当有一个客户请求，容器会创建一个线程来处理客户请求<br>(5)卸载：调用destroy方法让servlet自己释放其占用的资源</p>\r\n<h4 id=\"h4-2-jsp\"><a name=\"2.JSP\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.JSP</h4><p><img src=\"http://uploadfiles.nowcoder.com/images/20160308/595432_1457414324036_C3D4EB7F2D61708D0C0BE2921A45B74D\" alt=\"\"></p>','2017-03-14',1,20,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(293,'2017-03-17学习笔记','1.GC线程是否和守护线程 2.java堆排序','<h4 id=\"h4-1-gc-\"><a name=\"1.GC线程是否和守护线程\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.GC线程是否和守护线程</h4><h4 id=\"h4-2-java-\"><a name=\"2.java堆排序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.java堆排序</h4>','2017-03-17',1,18,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(294,'春招~好失落啊','自己的情况：广东人，大学跑到天津一所二本学校，网络工程专业，大一大二学ccna、ccnp，发现没有创造性，按着别人的死规定敲命令好无聊，大三彻底转向编程，c++看着不爽，调研一番后选择java，自学java和java web，对jsp、servlet略过，直接上手框架（Struts，hibernate，spring），看书，找视频，敲项目，非专业课（操作系统，数据库等）不听，捣鼓一番觉得还行，继续','<p>自己的情况：广东人，大学跑到天津一所二本学校，网络工程专业，大一大二学ccna、ccnp，发现没有创造性，按着别人的死规定敲命令好无聊，大三彻底转向编程，c++看着不爽，调研一番后选择java，自学java和java web，对jsp、servlet略过，直接上手框架（Struts，hibernate，spring），看书，找视频，敲项目，非专业课（操作系统，数据库等）不听，捣鼓一番觉得还行，继续学习spring mvc，mybatis，开始了解hadoop、spark，同时搭了自己的网站，跟了软件工程的同学比了比，还能算上前列吧，当然，基础和算法跟前列的人还没得比~~~</p>\r\n<p>去年秋招，腾讯、阿里等笔试全挂，京东的没怎么做却过了，不敢去面试（真心没怎么做题），最后去了北京一家创业公司实习了三个月多，感觉真心好，12月几乎整整一个月雾霾，受不了，还是回广东吧。在家过了春节，2月10号跟同学一起来深圳，就这样，开始了春招之旅~~~~</p>\r\n<p>第一家，面试的问的差不多全答对，手写了几个sql也对了，不过居然没有问hashmap，给的工资6000到9000，想了想，还是不去的好，太郊区，后来一查，是个培训兼外包的企业，还好没去。。。。</p>\r\n<p>第二家，某ERP公司，额，笔试，全是sql，做了，感觉还可以，面试直接说我们公司不用java，用的一个小众语言，薪资应届生只有3500，直接走人。。。。</p>\r\n<p>第三家，找工作，对广东真是彻底失望了，投的简历除了培训机构理你，其他的都不理人的，无奈之下投了北京的一家创业公司（A轮），薪资1万，电话面试，过了。。。。。后来想想，还是不去北京了，虽然工资高，但是没有朋友，过得像个死人一样。</p>\r\n<p>第四家，深圳一家创业公司，做东南亚社交软件的，可惜薪资没谈成，4K-6K，这可是深圳啊。。。。</p>\r\n<p>第五家，广州凡科，那天一早就从深圳跑过去，没吃饭，下午到就做笔试题，头晕，手抖，然后一面就是跟你讲笔试题，讲了两道，就叫我走了。。。仅仅半个小时，广深来回6个小时。。。</p>\r\n<p>第六家，广州某搞运维的公司，笔试差不多答对，面试问的问题也答对，但是没给offer。。。不理解</p>\r\n<p>第七家，然后晚上跑去了广工的久邦数码宣讲，试卷发到我这的时候，HR说我这方向的试卷没带够。。。。无奈向他要了大数据的题，全是数据库的题，过几天后得知居然过了，然后一面，问的问题没啥印象，除了left join的原理没答对。。。今天得知挂了。。。。</p>\r\n<p><img src=\"http://images2015.cnblogs.com/blog/755525/201703/755525-20170318000537838-305991370.png\" alt=\"\"></p>\r\n<p>第八家，极天信息（A轮），笔试的题目没看懂它问的啥，一面没啥印象了，然后是经理面，说广州没那么高的工资（7000），等消息，估计也没谈成。。。。</p>\r\n<p>第九家，中国移动，最气的了，一面就是HR面，问了两个问题，为什么不在北京留着，你觉得相比其他人你有什么优势。我只能说我真不会说话更不知怎么回答，就强调勤奋，然后直接被HR叫走人了，3分钟=w=</p>\r\n<p>第十家，珍爱网，找别人内推的，三个问题没答上来，就不跟你们说了，亲爱的竞争对手们=w=，谈了四十分钟吧，出来后感觉很不好，估计也是挂了。。。</p>\r\n<p>今天晚上，收到了久邦数码的拒绝信，瞬间觉得好无奈好迷茫，有时候就那么一个简简单单的问题，答不好就直接拒绝的，改怎么心平气和的面对下一个面试。有时候真不理解公司是怎么招人的，是不是真的“把部分简历扔进垃圾桶，不招那些运气不好的人”？也只能这么安慰自己。可是，事实呢？</p>\r\n<p><img src=\"http://images2015.cnblogs.com/blog/755525/201703/755525-20170318001336463-1583022291.jpg\" alt=\"\"></p>\r\n<p>这些天，有时间都是往深圳图书馆跑，看书，刷牛客网，补算法，看源码，做了这么多，该怎么告诉自己不要放弃。。。。。开始有点想念北京的雾霾</p>','2017-03-18',5,17,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(295,'数据库','1.SQL执行的顺序 2.NULL “空值” 和”NULL”的概念： 1：空值(‘’)是不占用空间的,判断空字符用 = ‘’ 或者 <> ‘’ 来进行处理; 2: NULL值是未知的，且占用空间，不走索引;判断 NULL 用 IS NULL 或者 is not null , SQL 语句函数中可以使用 ifnull ()函数来进行处理. 注：在进行 count ()统计某列的记录数的时候，如果采用','<h4 id=\"h4-1-sql-\"><a name=\"1.SQL执行的顺序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.SQL执行的顺序</h4><p><img src=\"http://uploadfiles.nowcoder.com/images/20150828/415611_1440751995009_3B3E1329A400F0022B20C4F32AEFC9EF\" alt=\"\"></p>\r\n<h4 id=\"h4-2-null\"><a name=\"2.NULL\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.NULL</h4><p>“空值” 和”NULL”的概念：<br>  1：空值(‘’)是不占用空间的,判断空字符用 = ‘’ 或者 &lt;&gt; ‘’ 来进行处理;<br> 2: NULL值是未知的，且占用空间，不走索引;判断 NULL 用 IS NULL 或者 is not null , SQL 语句函数中可以使用 ifnull ()函数来进行处理.<br>注：在进行 count ()统计某列的记录数的时候，如果采用的 NULL 值，会别系统自动忽略掉，但是空值是统计到其中</p>\r\n<h4 id=\"h4-3-\"><a name=\"3.\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.</h4><p>在MySQL数据库中，NULL对于一些特殊类型的列来说，其代表了一种特殊的含义，而不仅仅是一个空值。<br>IS NULL: 此运算符返回true，当列的值是NULL。<br>IS NOT NULL: 运算符返回true，当列的值不是NULL。<br>&lt;=&gt; 操作符比较值（不同于=运算符）为ture，即使两个NULL值<br>涉及NULL条件是特殊的。不能使用 =NULL 或 !=NULL 寻找NULL值的列</p>\r\n<h4 id=\"h4-4-nf\"><a name=\"4.NF\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.NF</h4><p>第一范式（   1NF   ）：   字段具有   原子性   ,   不可再分   。所有关系型数据库系统都满足第一范式）数据库表中的字段都是单一属性的，不可再分。例如，姓名字段，其中的姓和名必须作为一个整体，无法区分哪部分是姓，哪部分是名，如果要区分出姓和名，必须设计成两个独立的字段。<br>第二范式（   2NF   ）：   第二范式（   2NF   ）是在   第一范式（   1NF   ）的基础上   建立起来的，即满足第二范式（   2NF   ）必须先满足第一范式（   1NF   ）。要求   数据库表中的每个实例或行必须可以被惟一地区分   。通常需要为表加上一个列，以存储各个实例的惟一标识。这个惟一属性列被称为   主关键字或主键   。<br>        第二范式（   2NF   ）要求   实体的属性完全依赖于主关键字   。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。简而言之，第二范式就是非主属性非部分依赖于主关键字。<br>第三范式 （  3NF  ） ：   满足第三范式（   3NF   ）   必须先满足第二范式（   2NF   ）   。简而言之，第三范式（   3NF   ）要求一个数据库表中   不包含   已在其它表中   已包含的非主关键字信息   。所以第三范式具有如下特征：<br>1   ，每一列只有一个值<br>2   ，每一行都能区分。<br>3   ，每一个表都   不包含其他表已经包含   的非主关键字信息。<br>例如，帖子表中只能出现发帖人的   id   ，而不能出现发帖人的   id   ，还同时出现发帖人姓名，否则，只要出现同一发帖人   id   的所有记录，它们中的姓名部分都必须严格保持一致，这就是   数据冗余   。</p>','2017-03-18',3,20,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(296,'重载与重写','目前的问题：父类的功能无法满足子类的需求。 方法重写的前提： 必须要存在继承的关系。 方法的重写: 子父类出了同名的函数，这个我们就称作为方法的重写。 什么是时候要使用方法的重写：父类的功能无法满足子类的需求时。 方法重写要注意的事项： 1.方法重写时， 方法名与形参列表必须一致。 2.方法重写时，子类的权限修饰符必须要大于或者等于父类的权限修饰符。 3.方法重写时，子类的返回值类型必须要小于或者','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><p>目前的问题：父类的功能无法满足子类的需求。</p>\n<p>方法重写的前提： 必须要存在继承的关系。</p>\n<p>方法的重写: 子父类出了同名的函数，这个我们就称作为方法的重写。</p>\n<p>什么是时候要使用方法的重写：父类的功能无法满足子类的需求时。</p>\n<p>方法重写要注意的事项：<br>    1.方法重写时， 方法名与形参列表必须一致。<br>    2.方法重写时，子类的权限修饰符必须要大于或者等于父类的权限修饰符。<br>    3.方法重写时，子类的返回值类型必须要小于或者 等于父类的返回值类型。<br>    4.方法重写时， 子类抛出的异常类型要小于或者等于父类抛出的异常类型。<br>            Exception(最坏)<br>            RuntimeException(小坏)</p>\n<p>方法的重载：在一个类中 存在两个或者两个 以上的同名函数,称作为方法重载。</p>\n<p>方法重载的要求</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"lit\">1.</span><span class=\"pln\"> </span><span class=\"pun\">函数名要一致。</span></code></li><li class=\"L1\"><code><span class=\"lit\">2.</span><span class=\"pln\"> </span><span class=\"pun\">形参列表不一致（形参的个数或形参</span><span class=\"pln\"> </span><span class=\"pun\">的类型不一致）</span></code></li><li class=\"L2\"><code><span class=\"lit\">3.</span><span class=\"pln\"> </span><span class=\"pun\">与返回值类型无关。</span></code></li></ol></pre></div>','2017-03-21',1,18,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(297,'垃圾回收算法','垃圾回收算法 1、标记-清除算法 2、复制算法 3、标记-整理算法 一、标记-清除算法 标记-清除算法采用从根集合进行扫描，对存活的对象对象标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收，如上图所示。 标记-清除算法不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效，但由于标记-清除算法直接回收不存活的对象，因此会造成内存碎片！ 二、复制算法 复制算法','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h2 id=\"h2-u5783u573Eu56DEu6536u7B97u6CD5\"><a name=\"垃圾回收算法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>垃圾回收算法</h2><p>1、标记-清除算法<br>2、复制算法<br>3、标记-整理算法</p>\n<h4 id=\"h4--\"><a name=\"一、标记-清除算法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、标记-清除算法</h4><p><img src=\"http://dl2.iteye.com/upload/attachment/0075/0386/29ae17ad-f8af-38b4-9e25-28ef3550858f.jpg\" alt=\"\">标记-清除算法采用从根集合进行扫描，对存活的对象对象标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收，如上图所示。<br>标记-清除算法不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效，但由于标记-清除算法直接回收不存活的对象，因此会造成内存碎片！</p>\n<h4 id=\"h4--\"><a name=\"二、复制算法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、复制算法</h4><p><img src=\"http://dl2.iteye.com/upload/attachment/0075/0388/91a656d4-f08a-377b-8eea-5785c2932533.jpg\" alt=\"\"><br>复制算法采用从根集合扫描，并将存活对象复制到一块新的，没有使用过的空间中，这种算法当控件存活的对象比较少时，极为高效，但是带来的成本是需要一块内存交换空间用于进行对象的移动。也就是我们前面提到的s0 s1等空间。</p>\n<h4 id=\"h4--\"><a name=\"三、标记-整理算法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、标记-整理算法</h4><p><img src=\"http://dl2.iteye.com/upload/attachment/0075/0390/6ba95f80-c7bc-3d09-b927-ac09297e9920.jpg\" alt=\"\"><br> 标记-整理算法采用标记-清除算法一样的方式进行对象的标记，但在清除时不同，在回收不存活的对象占用的空间后，会将所有的存活对象往左端空闲空间移动，并更新对应的指针。标记-整理算法是在标记-清除算法的基础上，又进行了对象的移动，因此成本更高，但是却解决了内存碎片的问题。</p>\n</div>','2017-04-09',1,19,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(298,'java分代回收','一、新生代内存的回收（minor GC）主要采用复制算法，下图展示了minor GC的执行过程。 二、对于新生代和旧生代，JVM可使用很多种垃圾回收器进行垃圾回收，下图展示了不同生代不通垃圾回收器，其中两个回收器之间有连线表示这两个回收器可以同时使用。 而这些垃圾回收器又分为串行回收方式、并行回收方式合并发回收方式执行，分别运用于不同的场景。如下图所示 三、收集器 1.Serial收集器 看名字我','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h2 id=\"h2--minor-gc-minor-gc-\"><a name=\"一、新生代内存的回收（minor GC）主要采用复制算法，下图展示了minor GC的执行过程。\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、新生代内存的回收（minor GC）主要采用复制算法，下图展示了minor GC的执行过程。</h2><p><img src=\"http://dl2.iteye.com/upload/attachment/0075/0392/732c7557-aa9a-3551-b14d-f543c5b0c94b.jpg\" alt=\"\"></p>\n<h2 id=\"h2--jvm-\"><a name=\"二、对于新生代和旧生代，JVM可使用很多种垃圾回收器进行垃圾回收，下图展示了不同生代不通垃圾回收器，其中两个回收器之间有连线表示这两个回收器可以同时使用。\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、对于新生代和旧生代，JVM可使用很多种垃圾回收器进行垃圾回收，下图展示了不同生代不通垃圾回收器，其中两个回收器之间有连线表示这两个回收器可以同时使用。</h2><p><img src=\"http://dl2.iteye.com/upload/attachment/0075/0394/0172f624-9018-3642-bf26-05a2c3071639.jpg\" alt=\"\"><br>而这些垃圾回收器又分为串行回收方式、并行回收方式合并发回收方式执行，分别运用于不同的场景。如下图所示<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0396/c962c2ad-273f-3de4-b2e3-a4dd8b946215.jpg\" alt=\"\"></p>\n<h2 id=\"h2--\"><a name=\"三、收集器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、收集器</h2><h4 id=\"h4-1-serial-\"><a name=\"1.Serial收集器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.Serial收集器</h4><p>看名字我们都可以看的出来，这个属于串行收集器。其运行示意图如下<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0398/681da5ca-5eff-3984-bece-3d80dfe905be.jpg\" alt=\"\"><br>    收集器是历史最悠久的一个回收器，JDK1.3之前广泛使用这个收集器，目前也是ClientVM下 ServerVM 4核4GB以下机器的默认垃圾回收器。串行收集器并不是只能使用一个CPU进行收集，而是当JVM需要进行垃圾回收的时候，需要中断所有的用户线程，知道它回收结束为止，因此又号称“Stop The World” 的垃圾回收器。注意，JVM中文名称为java虚拟机，因此它就像一台虚拟的电脑一样在工作，而其中的每一个线程就被认为是JVM的一个处理器，因此大家看到图中的CPU0、CPU1实际为用户的线程，而不是真正机器的CPU，大家不要误解哦。<br>    串行回收方式适合低端机器，是Client模式下的默认收集器，对CPU和内存的消耗不高，适合用户交互比较少，后台任务较多的系统。<br>    Serial收集器默认新旧生代的回收器搭配为Serial+ SerialOld</p>\n<h4 id=\"h4-2-parnew-\"><a name=\"2.ParNew收集器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.ParNew收集器</h4><p>ParNew收集器其实就是多线程版本的Serial收集器，其运行示意图如下<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0400/6443b39c-ed33-3d93-a690-87e646439561.jpg\" alt=\"\"><br>同样有Stop The World的问题，他是多CPU模式下的首选回收器（该回收器在单CPU的环境下回收效率远远低于Serial收集器，所以一定要注意场景哦），也是Server模式下的默认收集器。</p>\n<h4 id=\"h4-3-parallelscavenge\"><a name=\"3.ParallelScavenge\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.ParallelScavenge</h4><p>ParallelScavenge又被称为是吞吐量优先的收集器，器运行示意图如下<br><img src=\"http://dl.iteye.com/upload/attachment/0075/0402/5007beba-0b0e-3cf4-b146-c28b6c0dd696.jpg\" alt=\"\"><br> ParallelScavenge<br>所提到的吞吐量=程序运行时间/(JVM执行回收的时间+程序运行时间),假设程序运行了100分钟，JVM的垃圾回收占用1分钟，那么吞吐量就是99%。在当今网络告诉发达的今天，良好的响应速度是提升用户体验的一个重要指标，多核并行云计算的发展要求程序尽可能的使用CPU和内存资源，尽快的计算出最终结果，因此在交互不多的云端，比较适合使用该回收器。</p>\n<h4 id=\"h4-4-parallelold\"><a name=\"4.ParallelOld\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.ParallelOld</h4><p>ParallelOld是老生代并行收集器的一种，使用标记整理算法、是老生代吞吐量优先的一个收集器。这个收集器是JDK1.6之后刚引入的一款收集器，我们看之前那个图之间的关联关系可以看到，早期没有ParallelOld之前，吞吐量优先的收集器老生代只能使用串行回收收集器，大大的拖累了吞吐量优先的性能，自从JDK1.6之后，才能真正做到较高效率的吞吐量优先。其运行示意图如下<br><img src=\"http://dl.iteye.com/upload/attachment/0075/0406/9a14da85-f943-3408-ba88-c6bb3842a792.jpg\" alt=\"\"></p>\n<h4 id=\"h4-5-serialold\"><a name=\"5.SerialOld\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.SerialOld</h4><p>SerialOld是旧生代Client模式下的默认收集器，单线程执行；在JDK1.6之前也是ParallelScvenge回收新生代模式下旧生代的默认收集器，同时也是并发收集器CMS回收失败后的备用收集器。其运行示意图如下<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0404/ce7aabd5-b0e0-3cda-9b6c-607cf6ebf689.jpg\" alt=\"\"></p>\n<h4 id=\"h4-5-cms\"><a name=\"5.CMS\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.CMS</h4><p>CMS又称响应时间优先(最短回收停顿)的回收器，使用并发模式回收垃圾，使用标记-清除算法，CMS对CPU是非常敏感的，它的回收线程数=（CPU+3）/4，因此当CPU是2核的实惠，回收线程将占用的CPU资源的50%，而当CPU核心数为4时仅占用25%。他的运行示意图如下<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0408/4239228b-879f-382f-81c6-5c32799886d6.jpg\" alt=\"\"><br>模式主要分为四个过程：<br>1.初始标记<br>2.并发标记<br>3.重新标记<br>4.并发清除<br>在初始标记的时候，需要中断所有用户线程，在并发标记阶段，用户线程和标记线程<br>并发执行，而在这个过程中，随着内存引用关系的变化，可能会发生原来标记的对象被释放，进而引发新的垃圾，因此可能会产生一系列的浮动垃圾，不能被回收。</p>\n<p>CMS 为了确保能够扫描到所有的对象，避免在Initial Marking 中还有未标识到的对象，采用的方法为找到标记了的对象，并将这些对象放入Stack 中，扫描时寻找此对象依赖的对象，如果依赖的对象的地址在其之前，则将此对象进行标记，并同时放入Stack 中，如依赖的对象地址在其之后，则仅标记该对象。<br>在进行Concurrent Marking 时minor GC 也可能会同时进行，这个时候很容易造成旧生代对象引用关系改变，CMS 为了应对这样的并发现象，提供了一个Mod Union Table 来进行记录，在这个Mod Union Table中记录每次minor GC 后修改了的Card 的信息。这也是ParallelScavenge不能和CMS一起使用的原因。<br>CMS产生浮动垃圾的情况请见如下示意图<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0410/60e7c659-790a-3405-af70-9ca4cfd9258d.jpg\" alt=\"\"><br>在运行回收过后，c就变成了浮动垃圾。<br>由于CMS会产生浮动垃圾，当回收过后，浮动垃圾如果产生过多，同时因为使用标记-清除算法会产生碎片，可能会导致回收过后的连续空间仍然不能容纳新生代移动过来或者新创建的大资源，因此会导致CMS回收失败，进而触发另外一次FULL GC，而这时候则采用SerialOld进行二次回收。<br>同时CMS因为可能产生浮动垃圾，而CMS在执行回收的同时新生代也有可能在进行回收操作，为了保证旧生代能够存放新生代转移过来的数据，CMS在旧生代内存到达全部容量的68%就触发了CMS的回收！</p>\n<h4 id=\"h4-7-garbagefirst-g1-\"><a name=\"7.GarbageFirst(G1)\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>7.GarbageFirst(G1)</h4><p>我们再来看垃圾回收器的总图，刚才我们可以看到，我在图上标记了一个？，其实这是一个新的垃圾回收器，既可以回收新生代也可以回收旧生代，SunHotSpot 1.6u14以上EarlyAccess版本加入了这个回收器，sun公司预期SunHotSpot1.7发布正式版，他是商用高性能垃圾回收器，通过重新划分内存区域，整合优化CMS，同时注重吞吐量和响应时间，但是杯具的是被Oracle收购之后这个收集器属于商用收费收集器，因此目前基本上没有人使用，我们在这里也就不多介绍，更多信息可以参考oracle新版本JDK说明。</p>\n</div>','2017-04-09',1,18,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(299,'java汇编','java 汇编 http://download.csdn.net/download/jiangfuqiang/8403497','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><p>java 汇编<br><a href=\"http://download.csdn.net/download/jiangfuqiang/8403497\">http://download.csdn.net/download/jiangfuqiang/8403497</a></p>\n</div>','2017-04-10',1,21,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(300,'jvm','-XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><p>-XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly</p>\n</div>','2017-04-10',1,23,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(301,'Adaboost','NaiveBayesSpamFilter 利用朴素贝叶斯算法实现垃圾邮件的过滤，并结合Adaboost改进该算法。 1 Naive Bayes spam filtering   假设邮件的内容中包含的词汇为Wi，垃圾邮件Spam，正常邮件ham。 判断一份邮件，内容包含的词汇为Wi，判断该邮件是否是垃圾邮件，即计算P（S|Wi）这个条件概率。根据Bayes’ theorem：   Bayes’ t','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h1 id=\"h1-naivebayesspamfilter\"><a name=\"NaiveBayesSpamFilter\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>NaiveBayesSpamFilter</h1><p>利用朴素贝叶斯算法实现垃圾邮件的过滤，并结合Adaboost改进该算法。</p>\n<h3 id=\"h3-1-naive-bayes-spam-filtering\"><a name=\"1 Naive Bayes spam filtering\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1 Naive Bayes spam filtering</h3><p>  假设邮件的内容中包含的词汇为Wi，垃圾邮件Spam，正常邮件ham。 判断一份邮件，内容包含的词汇为Wi，判断该邮件是否是垃圾邮件，即计算P（S|Wi）这个条件概率。根据Bayes’ theorem：</p>\n<p>  Bayes’ theorem</p>\n<p>  其中：</p>\n<p>Pr(S|Wi) 出现词汇Wi的邮件是垃圾邮件的条件概率（即后验概率）；<br>Pr(S) 训练阶段邮件数据集中垃圾邮件的概率，或实际调查的垃圾邮件的概率（即先验概率）；<br>Pr(Wi|S) 垃圾邮件中词汇Wi出现的概率；<br>Pr(H) 训练阶段邮件数据集中正常邮件的概率，或实际调查的正常邮件的概率；<br>Pr(Wi|H) 正常邮件中词汇Wi出现的概率；<br>  对于邮件中出现的所有词汇，考虑每个词汇出现事件的独立性，计算Pr(S|Wi)的联合概率Pr(S|W)，W={W1，W2，…Wn}：</p>\n<p>  Bayes’ theorem</p>\n<p>  其中：</p>\n<p>P 即Pr(S|W)，出现词汇W={W1，W2……Wn}的邮件是垃圾邮件的条件概率；<br>Pi 即Pr(S|Wi)，出现词汇Wi的邮件是垃圾邮件的条件概率；<br>  注： 程序中，通过计算出Pr(S|W)和Pr(H|W)，比较Pr(S|W)和Pr(H|W)的大小，判断是垃圾邮件还是正常邮件。我们发现Pr(S|W)和Pr(H|W)计算的分母相同，所以我们只需要比较分子即可。</p>\n<p>  但存在两个问题：</p>\n<p>当词汇不存在时，即ni=0，此时Pr(S|Wi) = 0，会造成P=0，无法比较<br>当Pr(S|Wi)较小时，连乘操作会造成下溢出问题<br>  解决方案：</p>\n<p>计算P(Wi|S)和P(Wi|H)时，将所有词汇初始化出现的次数为1，并将分母初始化为2（或根据样本/实际调查结果调整分母的值）。</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"com\"># 统计语料库中词汇在S和H中出现的次数</span></code></li><li class=\"L1\"><code><span class=\"pln\">wordsInSpamNum </span><span class=\"pun\">=</span><span class=\"pln\"> np</span><span class=\"pun\">.</span><span class=\"pln\">ones</span><span class=\"pun\">(</span><span class=\"pln\">numWords</span><span class=\"pun\">)</span></code></li><li class=\"L2\"><code><span class=\"pln\">wordsInHealthNum </span><span class=\"pun\">=</span><span class=\"pln\"> np</span><span class=\"pun\">.</span><span class=\"pln\">ones</span><span class=\"pun\">(</span><span class=\"pln\">numWords</span><span class=\"pun\">)</span></code></li><li class=\"L3\"><code><span class=\"pln\">spamWordsNum </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">2.0</span></code></li><li class=\"L4\"><code><span class=\"pln\">healthWordsNum </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">2.0</span></code></li></ol></pre><p>计算P(Wi|S)和P(Wi|H)时，对概率取对数<br>    pWordsSpamicity = np.log(wordsInSpamNum / spamWordsNum)<br>    pWordsHealthy = np.log(wordsInHealthNum / healthWordsNum)<br>  所以最终比较的是，P(W1|S)P(W2|S)….P(Wn|S)P(S)和P(W1|H)P(W2|H)….P(Wn|H)P(H)的大小。</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"pln\">ps </span><span class=\"pun\">=</span><span class=\"pln\"> sum</span><span class=\"pun\">(</span><span class=\"pln\">testWordsMarkedArray </span><span class=\"pun\">*</span><span class=\"pln\"> pWordsSpamicity</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">+</span><span class=\"pln\"> np</span><span class=\"pun\">.</span><span class=\"pln\">log</span><span class=\"pun\">(</span><span class=\"pln\">pSpam</span><span class=\"pun\">)</span></code></li><li class=\"L1\"><code><span class=\"pln\">ph </span><span class=\"pun\">=</span><span class=\"pln\"> sum</span><span class=\"pun\">(</span><span class=\"pln\">testWordsMarkedArray </span><span class=\"pun\">*</span><span class=\"pln\"> pWordsHealthy</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">+</span><span class=\"pln\"> np</span><span class=\"pun\">.</span><span class=\"pln\">log</span><span class=\"pun\">(</span><span class=\"lit\">1</span><span class=\"pln\"> </span><span class=\"pun\">-</span><span class=\"pln\"> pSpam</span><span class=\"pun\">)</span></code></li></ol></pre><p>  测试效果： 5574个样本，采用交叉验证，随机选取4574个作为训练样本，产生词汇列表（语料库），对1000个测试样本，分类的平均错误率约为：2.5%。</p>\n<h3 id=\"h3-2-running-adaboost-on-naive-bayes\"><a name=\"2 Running Adaboost on Naive Bayes\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2 Running Adaboost on Naive Bayes</h3><p>  我们在计算ps和ph联合后验概率时，可引入一个调整因子DS，其作用是调整词汇表中某一词汇的“垃圾程度”(spamicity)，</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"pln\">ps </span><span class=\"pun\">=</span><span class=\"pln\"> sum</span><span class=\"pun\">(</span><span class=\"pln\">testWordsMarkedArray </span><span class=\"pun\">*</span><span class=\"pln\"> pWordsSpamicity </span><span class=\"pun\">*</span><span class=\"pln\"> DS</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">+</span><span class=\"pln\"> np</span><span class=\"pun\">.</span><span class=\"pln\">log</span><span class=\"pun\">(</span><span class=\"pln\">pSpam</span><span class=\"pun\">)</span></code></li></ol></pre><p>  其中DS通过Adaboost算法迭代获取最佳值。原理如下：</p>\n<p>设定adaboost循环的次数count<br>交叉验证随机选择1000个样本<br>DS初始化为和词汇列表大小相等的全一向量<br>迭代循环count次：<br>    设定最小分类错误率为inf<br>    对于每一个样本：<br>        在当前DS下对样本分类<br>        如果分类出错：<br>            计算出错的程度，即比较ps和ph的相差alpha<br>            如果样本原本是spam，错分成ham：<br>                DS[样本包含的词汇] = np.abs(DS[样本包含的词汇] - np.exp(alpha) / DS[样本包含的词汇])<br>            如果样本原本是ham，错分成spam：<br>                DS[样本包含的词汇] = DS[样本包含的词汇] + np.exp(alpha) / DS[样本包含的词汇]<br>    计算错误率<br>    保存最小的错误率和此时的词汇列表、P(Wi|S)和P(Wi|H)、DS等信息，即保存训练好的最佳模型的信息<br>  测试效果： 5574个样本，获取Adaboost算法训练的最佳模型信息（包括词汇列表、P(Wi|S)和P(Wi|H)、DS等），对1000个测试样本，分类的平均错误率约为：0.5%。</p>\n</div>','2017-04-17',4,30,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(302,'Java堆.栈和常量池 笔记','Java堆.栈和常量池 笔记','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><p><a href=\"http://www.iteye.com/topic/634530\">Java堆.栈和常量池 笔记</a></p>\n</div>','2017-04-23',1,27,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(303,'redis','redis的数据结构 数据结构类型 结构存储的值 结构的读写能力 STRING 可以是字符串、整数、或者浮点数 对整个字符串或者字符串的其中一部分执行操作；对整数和浮点数执行自增或者自减 LIST 一个链表，链表上的每个节点都包含了一个字符串 从链表的两端推入或者弹出元素；根据偏移量对链表进行修剪；根据值查找或者移除元素 SET 包含字符串的无序收集器，并且被包含的每个字符串都是独一无二、各不相同','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h1 id=\"h1-redis-\"><a name=\"redis的数据结构\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>redis的数据结构</h1><table>\n<thead>\n<tr>\n<th>数据结构类型</th>\n<th>结构存储的值</th>\n<th>结构的读写能力</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>STRING</td>\n<td>可以是字符串、整数、或者浮点数</td>\n<td>对整个字符串或者字符串的其中一部分执行操作；对整数和浮点数执行自增或者自减</td>\n</tr>\n<tr>\n<td>LIST</td>\n<td>一个链表，链表上的每个节点都包含了一个字符串</td>\n<td>从链表的两端推入或者弹出元素；根据偏移量对链表进行修剪；根据值查找或者移除元素</td>\n</tr>\n<tr>\n<td>SET</td>\n<td>包含字符串的无序收集器，并且被包含的每个字符串都是独一无二、各不相同的</td>\n<td>添加、获取、移除单个元素；检查一个元素是否存在于集合中；计算交集、并集、差集；从集合里面随机获取元素</td>\n</tr>\n<tr>\n<td>HASH</td>\n<td>包含键值对的无语散列表</td>\n<td>添加、获取、移除单个键值对；获取所有键值对</td>\n</tr>\n<tr>\n<td>ZSET(有序集合)</td>\n<td>字符串成员与浮点数分值之间的有序映射，元素的排列顺序由分值的大小决定</td>\n<td>添加、获取、单个元素；根据分值范围或者成员来获取元素</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"h3--string-\"><a name=\"一、STRING基本操作\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、STRING基本操作</h3><p>（1）SET 设置存储在给定键中的值<br>（2）GET 获取存储在给定键中的值<br>（3）DEL 删除存储在给定键中的值</p>\n<h3 id=\"h3--list-\"><a name=\"二、LIST（列表）基本操作\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、LIST（列表）基本操作</h3><p>（1）RPUSH 将给定值推入列表的右端<br>（2）LRANGE 获取列表在给定范围上的所有值<br>（3）LINDEX 获取列表在给定位置上的单个元素<br>（4）LPOP 从列表的左端弹出一个值，并返回被弹出的值</p>\n<h3 id=\"h3--set-\"><a name=\"三、SET（集合）基本操作\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>　三、SET（集合）基本操作</h3><p>（1）SADD 将给定元素添加到集合<br>（2）SMEMBERS 返回集合包含的所有元素<br>（3）SISMEMBER 检查给定元素是否存在于集合中<br>（4）SREM 如果给定的元素存在于集合中，那么移除这个元素</p>\n<h3 id=\"h3--hash-\"><a name=\"四、HASH（散列）基本操作\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>四、HASH（散列）基本操作</h3><p>（1）HSET 在散列里面关联起给定的键值对<br>（2）HGET 获取指定散列键的值<br>（3）HGETALL 获取散列包含的所有键值对<br>（4）HDEL 如果给定键存在于散列里面，那么移除这个键</p>\n<h3 id=\"h3--zset-\"><a name=\"五、ZSET（有序集合）基本操作\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>五、ZSET（有序集合）基本操作</h3><p>（1）ZADD 将一个带有给定分值的成员添加到有序集合里面<br>（2）ZRANGE 根据元素在有序排列中所处的位置，从有序集合里面获取多个元素<br>（3）ZRANGEBYSCORE 获取有序集合在给定分值范围的所有元素<br>（4）ZREM 如果给定成员存在于有序集合，那么移除这个成员</p>\n</div>','2017-05-04',6,29,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(304,'工厂模式','工厂模式 目录 何为工厂模式 工厂方法与抽象工厂 如何在Java EE中通过@Producers与@Inject注解实现工厂模式 如何创建自定义注解以及通过@Qualifier消除具体实现之间的歧义 工厂模式有两种模式：工厂方法和抽象方法。它们的意图是一样的：提供一个接口，在不指定具体类的情况下创建相关或依赖的一系列对象。 一.何为工厂模式 工厂的目的在于创建对象。创建的逻辑被封装在工厂中，要么提','<h1 id=\"h1-u5DE5u5382u6A21u5F0F\"><a name=\"工厂模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>工厂模式</h1><p>目录</p>\r\n<ul>\r\n<li>何为工厂模式</li><li>工厂方法与抽象工厂</li><li>如何在Java EE中通过<a href=\"https://github.com/Producers\" title=\"&#64;Producers\" class=\"at-link\">@Producers</a>与<a href=\"https://github.com/Inject\" title=\"&#64;Inject\" class=\"at-link\">@Inject</a>注解实现工厂模式</li><li>如何创建自定义注解以及通过<a href=\"https://github.com/Qualifier\" title=\"&#64;Qualifier\" class=\"at-link\">@Qualifier</a>消除具体实现之间的歧义<br>工厂模式有两种模式：工厂方法和抽象方法。它们的意图是一样的：提供一个接口，在不指定具体类的情况下创建相关或依赖的一系列对象。</li></ul>\r\n<h3 id=\"h3--\"><a name=\"一.何为工厂模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一.何为工厂模式</h3><p>工厂的目的在于创建对象。创建的逻辑被封装在工厂中，要么提供一个方法来返回新创建的对象（工厂方法模式），要么将对象的创建委托给子类（抽象工厂模式）。<br>客户端不必考虑接口或类的不同实现，它只需通过工厂（工厂）获取接口实现的一个实例的即可，这样客户端与对象的创建就实现了解耦<br>解耦是应用依赖反转原则的结果，这带来了很多好处，其中最重要的好处就是实现了高层类与底层类之间的解耦。通过解耦，具体类实现的变化不会影响到客户端，这降低了类与类之间的耦合，并提升了灵活性。</p>\r\n<h3 id=\"h3--\"><a name=\"二.工厂方法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二.工厂方法</h3><p>GoF一书是这样描述工程方法模式的：“定义一个用于创建对象的接口，不过让子类决定实例化那个类”<br>工厂极大降低了new关键字的使用次数，并且将初始化过程与不同的具体实现封装起来。将这些需求中心化可以极大减少向系统中添加或删除具体类的影响以及具体的类依赖的影响。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src=\"http://ohlrxdl4p.bkt.clouddn.com/images/QQ截图20170506134421.jpg\" alt=\"\"><br><strong>1.使用普通代码实现工厂方法</strong><br>被具体实现继承的DrinksMachine抽象类</p>\r\n<pre><code class=\"lang-java\">public abstract class DrinksMachine {\r\n    public abstract Drink dispenseDrink();\r\n    public String displayMessage(){\r\n        return &quot;Thank for your custom.&quot;;\r\n    }\r\n}\r\n</code></pre>\r\n<p>DrinksMachine抽象类的CoffeeMachine实现</p>\r\n<pre><code class=\"lang-java\">public class CoffeeMachine extends DrinksMachine {\r\n    public Drink dispenseDrink() {\r\n        return new Coffee();\r\n    }\r\n}\r\n</code></pre>\r\n<p>DrinksMachine抽象类的SoftDrinksMachine实现</p>\r\n<pre><code class=\"lang-java\">public class SoftDrinksMachine extends DrinksMachine {\r\n    public Drink dispenseDrink() {\r\n        return new SoftDrink();\r\n    }\r\n}\r\n</code></pre>\r\n<p>Drink接口</p>\r\n<pre><code class=\"lang-java\">public interface Drink {}\r\n</code></pre>\r\n<p>Drink接口的SoftDrink实现</p>\r\n<pre><code class=\"lang-java\">public class SoftDrink implements Drink {\r\n    SoftDrink() {\r\n        System.out.println(&quot;Soft drink&quot;);\r\n    }\r\n}\r\n</code></pre>\r\n<p>Drink接口的Coffee实现</p>\r\n<pre><code class=\"lang-java\">public class Coffee implements Drink {\r\n    Coffee() {\r\n        System.out.println(&quot;Coffee&quot;);\r\n    }\r\n}\r\n</code></pre>\r\n<p>CoffeeType枚举<br>```java<br>public enum CoffeeType {EXPRESSO, LATTE}</p>\r\n<p>public Drink dispenseDrink(CoffeeType type) {<br>    Drink coffee = null;<br>    switch (type) {<br>        case EXPRESSO: coffee = new Expresso();<br>        case LATTE: coffee = new Latte();<br>    }<br>    return coffee;<br>}<br>```&lt;!--前面不能有空格--&gt;</p>','2017-05-06',1,59,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(305,'代理模式','代理模式(Proxy Pattern) GoF中给出的代理模式的定义为： 代理模式给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。 代理模式的英文叫做Proxy或Surrogate，它是一种对象结构型模式。 代理模式根据其目的和实现可分为很多种类，常用的代理模式包括如下几种： （1）远程代理（Remote Proxy）————为一个位于不同的地址空间的对象提供一个本地的代理对象','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h1 id=\"h1--proxy-pattern-\"><a name=\"代理模式(Proxy Pattern)\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代理模式(Proxy Pattern)</h1><p>GoF中给出的代理模式的定义为：<br>代理模式给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。<br>代理模式的英文叫做Proxy或Surrogate，它是一种对象结构型模式。<br>代理模式根据其目的和实现可分为很多种类，常用的代理模式包括如下几种：<br>（1）远程代理（Remote Proxy）————为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以是在同一台主机中，也可以是在另一台主机中，远程代理又称为大使（Ambassador）<br>（2）虚拟代理（Virtual Proxy）————如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。<br>（3）保护代理（Protect Proxy）————控制一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。<br>（4）缓冲代理（Cache Proxy）————为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。<br>（5）只能引用代理（Smart Reference Proxy）————当一个对象被引用时，提供一些额外的操作，例如将对象被调用的次数记录下来。<br><img src=\"http://ohlrxdl4p.bkt.clouddn.com/images/QQ截图20170507103646.jpg\" alt=\"\"></p>\n<p>代码实现：<br>1.抽象主题类——BuyTicket.java</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code class=\"lang-java\"><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">interface</span><span class=\"pln\"> </span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> showticket</span><span class=\"pun\">();</span></code></li><li class=\"L2\"><code class=\"lang-java\"><span class=\"pun\">}</span></code></li></ol></pre>\n<p>2.具体主题类——Train.java</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code class=\"lang-java\"><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Train</span><span class=\"pln\"> </span><span class=\"kwd\">implements</span><span class=\"pln\"> </span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"lit\">@Override</span></code></li><li class=\"L2\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> showticket</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L3\"><code class=\"lang-java\"><span class=\"pln\">        </span><span class=\"typ\">System</span><span class=\"pun\">.</span><span class=\"pln\">out</span><span class=\"pun\">.</span><span class=\"pln\">println</span><span class=\"pun\">(</span><span class=\"str\">\"one ticket\"</span><span class=\"pun\">);</span></code></li><li class=\"L4\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L5\"><code class=\"lang-java\"><span class=\"pun\">}</span></code></li></ol></pre>\n<p>3.代理角色类——TicketCenter.java</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code class=\"lang-java\"><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">TicketCenter</span><span class=\"pln\"> </span><span class=\"kwd\">implements</span><span class=\"pln\"> </span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> ticket</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code class=\"lang-java\"></code></li><li class=\"L3\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"typ\">TicketCenter</span><span class=\"pun\">(</span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> ticket</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code class=\"lang-java\"><span class=\"pln\">        </span><span class=\"kwd\">this</span><span class=\"pun\">.</span><span class=\"pln\">ticket </span><span class=\"pun\">=</span><span class=\"pln\"> ticket</span><span class=\"pun\">;</span></code></li><li class=\"L5\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code class=\"lang-java\"></code></li><li class=\"L7\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"lit\">@Override</span></code></li><li class=\"L8\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> showticket</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L9\"><code class=\"lang-java\"><span class=\"pln\">        ticket</span><span class=\"pun\">.</span><span class=\"pln\">showticket</span><span class=\"pun\">();</span></code></li><li class=\"L0\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code class=\"lang-java\"></code></li><li class=\"L2\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> buy</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L3\"><code class=\"lang-java\"><span class=\"pln\">        </span><span class=\"typ\">System</span><span class=\"pun\">.</span><span class=\"pln\">out</span><span class=\"pun\">.</span><span class=\"pln\">println</span><span class=\"pun\">(</span><span class=\"str\">\"by proxy\"</span><span class=\"pun\">);</span></code></li><li class=\"L4\"><code class=\"lang-java\"><span class=\"pln\">        showticket</span><span class=\"pun\">();</span></code></li><li class=\"L5\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code class=\"lang-java\"><span class=\"pun\">}</span></code></li></ol></pre>\n<p>4.客户端测试类</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code class=\"lang-java\"><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">ProxyPattern</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> main</span><span class=\"pun\">(</span><span class=\"typ\">String</span><span class=\"pln\"> args</span><span class=\"pun\">[])</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L2\"><code class=\"lang-java\"><span class=\"pln\">        </span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> x </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Train</span><span class=\"pun\">();</span></code></li><li class=\"L3\"><code class=\"lang-java\"><span class=\"pln\">        </span><span class=\"typ\">TicketCenter</span><span class=\"pln\"> y </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">TicketCenter</span><span class=\"pun\">(</span><span class=\"pln\">x</span><span class=\"pun\">);</span></code></li><li class=\"L4\"><code class=\"lang-java\"><span class=\"pln\">        y</span><span class=\"pun\">.</span><span class=\"pln\">buy</span><span class=\"pun\">();</span></code></li><li class=\"L5\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code class=\"lang-java\"><span class=\"pun\">}</span></code></li></ol></pre>\n<p>运行结果：</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code class=\"lang-html\"><span class=\"pln\">by proxy</span></code></li><li class=\"L1\"><code class=\"lang-html\"><span class=\"pln\">one ticket</span></code></li></ol></pre>\n</div>','2017-05-07',1,103,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(306,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,57,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(307,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,22,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(308,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,18,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(309,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,19,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(310,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,19,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(311,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,20,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(312,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,21,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(313,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,22,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(314,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,20,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(315,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,19,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(316,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,19,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(317,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,20,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(318,'BSbsbsbs','heloo 哦i已被肉','<h1 id=\"h1-heloo-i-\"><a name=\"heloo 哦i已被肉\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>heloo 哦i已被肉</h1>','2017-01-23',3,24,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(319,'2017-02-28学习笔记','','<p><img src=\"http://ohlrxdl4p.bkt.clouddn.com/images/826546_1482322555369_C5DABB18734059E89A45A0E9170722B0.png\" alt=\"\"></p>','2017-02-28',1,28,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(320,'2017-03-01学习笔记','知识点 1.java中只有值传递，没有引用传递http://guhanjie.iteye.com/blog/1683637 2.final关键字 final修饰变量，则等同于常量. final修饰方法中的参数，称为最终参数. final修饰类，则类不能被继承. final修饰方法，则方法不能被','<h1 id=\"h1-u77E5u8BC6u70B9\"><a name=\"知识点\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>知识点</h1><h4 id=\"h4-1-java-http-guhanjie-iteye-com-blog-1683637\"><a name=\"1.java中只有值传递，没有引用传递  http://guhanjie.iteye.com/blog/1683637\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.java中只有值传递，没有引用传递<a href=\"http://guhanjie.iteye.com/blog/1683637\">http://guhanjie.iteye.com/blog/1683637</a></h4><h4 id=\"h4-2-final-\"><a name=\"2.final关键字\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.final关键字</h4><ul>\r\n<li>final修饰变量，则等同于常量.</li><li>final修饰方法中的参数，称为最终参数.</li><li>final修饰类，则类不能被继承.</li><li>final修饰方法，则方法不能被重写.</li></ul>\r\n<h4 id=\"h4-3-integer-img-src-https-uploadfiles-nowcoder-com-images-20160717-6316247_1468761643205_9f7b85ab04292cf73778d98998a20ed1-alt-\"><a name=\"3.Integer<img src=\"https://uploadfiles.nowcoder.com/images/20160717/6316247_1468761643205_9F7B85AB04292CF73778D98998A20ED1\" alt=\"图片\">\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.Integer<img src=\"https://uploadfiles.nowcoder.com/images/20160717/6316247_1468761643205_9F7B85AB04292CF73778D98998A20ED1\" alt=\"图片\"></h4><h4 id=\"h4-4-java-\"><a name=\"4.java内存模型   点击原文\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.java内存模型 <a href=\"http://blog.csdn.net/ns_code/article/details/17565503\">点击原文</a></h4><p><img src=\"https://uploadfiles.nowcoder.com/images/20161223/415611_1482452184396_6FB53C51539B47559CF0D122A832CF63\" alt=\"\"></p>\r\n<h4 id=\"h4-5-java-reference\"><a name=\"5.java中是没有指针的，有reference\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.java中是没有指针的，有reference</h4><p>第一：指针变量是在栈内存中，它也是有值的，这个值存储的就是地址单元，这个地址就是来自于赋值操作。<br>第二：指针变量有类型，这个类型（如Person）的含义是指针指向的变量在栈内存（不是很确定）中的范围（大小），我理解为是占用的堆内存空间。<br>第三：声明一个对象时，是对“指针变量”的定义。<br>第四：用new关键字在堆内存创建了对象，在赋值时，是把这个对象的首地址传给了这个“指针变量”（即引用型变量）。</p>\r\n<h4 id=\"h4-6-string-\"><a name=\"6.String生成常量\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6.String生成常量</h4><pre><code class=\"lang-java\">String s1=&quot;abc&quot;+&quot;def&quot;;//生成的是一个常量，放在堆内存中\r\nString s2=new String（s1);//s2是一个变量\r\nif(s1.equals(s2))//比较的是字符串的内容\r\n    System.out.println(&quot;.equals succeeded&quot;);//输出\r\nif(s1==s2)//比较的是内存地址，但s1是常量，所以不相等\r\n    System.out.println(&quot;==succeeded&quot;);\r\n</code></pre>\r\n<h4 id=\"h4-7-jsp-\"><a name=\"7.jsp内置对象和属性\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>7.jsp内置对象和属性</h4><p>（１）request对象<br>客户端的请求信息被封装在request对象中，通过它才能了解到客户的需求，然后做出响应。它是HttpServletRequest类的实例。<br>（２）response对象<br>response对象包含了响应客户请求的有关信息，但在JSP中很少直接用到它。它是HttpServletResponse类的实例。<br>（３）session对象<br>session对象指的是客户端与服务器的一次会话，从客户连到服务器的一个WebApplication开始，直到客户端与服务器断开连接为止。它是HttpSession类的实例.<br>（４）out对象<br>out对象是JspWriter类的实例,是向客户端输出内容常用的对象<br>（５）page对象<br>page对象就是指向当前JSP页面本身，有点象类中的this指针，它是java.lang.Object类的实例<br>（６）application对象<br>application对象实现了用户间数据的共享，可存放全局变量。它开始于服务器的启动，直到服务器的关闭，在此期间，此对象将一直存在；这样在用户的前后连接或不同用户之间的连接中，可以对此对象的同一属性进行操作；在任何地方对此对象属性的操作，都将影响到其他用户对此的访问。服务器的启动和关闭决定了application对象的生命。它是ServletContext类的实例。<br>（７）exception对象<br>exception对象是一个例外对象，当一个页面在运行过程中发生了例外，就产生这个对象。如果一个JSP页面要应用此对象，就必须把isErrorPage设为true，否则无法编译。他实际上是java.lang.Throwable的对象<br>（８）pageContext对象<br>pageContext对象提供了对JSP页面内所有的对象及名字空间的访问，也就是说他可以访问到本页所在的SESSION，也可以取本页面所在的application的某一属性值，他相当于页面中所有功能的集大成者，它的本 类名也叫pageContext。<br>（９）config对象<br>config对象是在一个Servlet初始化时，JSP引擎向它传递信息用的，此信息包括Servlet初始化时所要用到的参数（通过属性名和属性值构成）以及服务器的有关信息（通过传递一个ServletContext对象）</p>','2017-03-01',1,32,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(321,'2017-03-02学习笔记','知识点 一、static public class Spike\r\n{\r\n    public static void main(String[] args)\r\n    {\r\n        Counter a = new Counter();\r\n        System.out.println(a.increment());\r\n        System.out.println(a.anot','<h1 id=\"h1-u77E5u8BC6u70B9\"><a name=\"知识点\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>知识点</h1><h4 id=\"h4--static\"><a name=\"一、static\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、static</h4><pre><code class=\"lang-java\">public class Spike\r\n{\r\n    public static void main(String[] args)\r\n    {\r\n        Counter a = new Counter();\r\n        System.out.println(a.increment());\r\n        System.out.println(a.anotherIncrement());\r\n        Counter b = new Counter();\r\n        System.out.println(b.increment());\r\n    }\r\n}\r\nclass Counter\r\n{\r\n    private static int count = 0;\r\n    public int increment()\r\n    {\r\n        return count++;\r\n    }\r\n    public int anotherIncrement()\r\n    {\r\n        return ++count;\r\n    }\r\n}\r\n</code></pre>\r\n<p>count是静态变量，为所有对象所共享，因此不管a.increment()还是b.increment()都会使count持续增加。<br>increment()方法返回当前count值，然后count增加1<br>antoherIncrement()方法让count增加1，然后返回count值<br>第一次a.increment()返回值为0，此时count值为1<br>第二次a.anotherIncrement()先让count+1再返回，返回值为2<br>第三次b.increment()先返回count当前值2，然后count+1</p>\r\n<h4 id=\"h4--aop-\"><a name=\"二、AOP面向切面\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、AOP面向切面</h4><p>AOP的概念是Aspected Oriented Programming 面向方面编程。<br>  好处：AOP将程序分解成各个方面或者说关注点。这使得可以模块化，相当横向上分切了。它可以解决OOP和过程化方法不能够很好解决的横切（crosscut）问题，如：事务、安全、日志等横切关注。<br>  实现AOP有几种方式:<br>  1.Spring 1.2版本中通过ProxyFactoryBean来实现aop,即通过动态代理来实现的,Aspect必须继承MethodBeforeAdvice,MethodAfterAdvice等<br>  2.Spring 2.0 AOP需要改的是FBI 这个类，而且它也不需要再实现某些接口<br>  3.三使用标注（<a href=\"https://github.com/AspectJ\" title=\"&#64;AspectJ\" class=\"at-link\">@AspectJ</a>）实现AOP<br>    AOP 和 OOP的区别：</p>\r\n<pre><code>```html\r\n 1. 面向方面编程 AOP 偏重业务处理过程的某个步骤或阶段，强调降低模块之间的耦合度，使代码拥有更好的移植性。  \r\n 2. 面向对象编程 (oop) 则是对业务分析中抽取的实体进行方法和属性的封装。\r\n ```\r\n</code></pre><p>也可以说 AOP 是面向业务中的动词领域， OOP 面向名词领域。<br>AOP 的一个很重要的特点是源代码无关性，也就是说如果我们的系统中引用了 AOP 组件，即使我们把该组件去掉，系统代码也应该能够编译通过。要实现这一点，可以使用动态 proxy 模式。</p>\r\n<h4 id=\"h4--jdbc-\"><a name=\"三、jdbc桥接模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、jdbc桥接模式</h4><p>桥接模式：<br>定义 ：将抽象部分与它的实现部分分离，使它们都可以独立地变化。<br>意图 ：将抽象与实现解耦。<br>桥接模式所涉及的角色</p>\r\n<ol>\r\n<li>Abstraction ：定义抽象接口，拥有一个Implementor类型的对象引用</li><li>RefinedAbstraction ：扩展Abstraction中的接口定义</li><li>Implementor ：是具体实现的接口，Implementor和RefinedAbstraction接口并不一定完全一致，实际上这两个接口可以完全不一样Implementor提供具体操作方法，而Abstraction提供更高层次的调用</li><li>ConcreteImplementor ：实现Implementor接口，给出具体实现<br>Jdk中的桥接模式：JDBC<br>JDBC连接 数据库 的时候，在各个数据库之间进行切换，基本不需要动太多的代码，甚至丝毫不动，原因就是JDBC提供了统一接口，每个数据库提供各自的实现，用一个叫做数据库驱动的程序来桥接就行了<h4 id=\"h4--\"><a name=\"四、抽象类\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>四、抽象类</h4>抽象类和普通类有三点区别：<br>1）抽象方法必须为public和protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public。<br>2）抽象类不能用来创建对象，但是它可以有构造方法，用来帮助子类实例化。<br>3）如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为abstract类。<h4 id=\"h4--\"><a name=\"五、接口\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>五、接口</h4>接口的主要特点<br>1）接口中的成员变量默认都是public、static、final类型的，必须被显示初始化。<br>2）接口中的方法默认都是public、abstract类型的。<br>3）接口中只能包含public、static、final类型的成员变量和public、abstract类型的成员方法。<br>4）接口没有构造方法，不能被实例化。<br>5）一个接口不能实现另一个接口，但它可以继承多个其他接口。<br>6）接口必须通过类来实现它的抽象方法。<br>7）与子类继承抽象父类相似，当类实现了某个接口时，它必须实现接口中所有的抽象方法，否则这个类必须被定义为抽象类。<br>8）一个类只能继承一个直接的父类，但能实现多个接口。<h4 id=\"h4--\"><a name=\"六、抽象类和接口的区别\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>六、抽象类和接口的区别</h4>1）抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract方法；<br>2）抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；<br>3）接口中不能含有静态代码块以及静态方法，而抽象类尅有静态代码块和静态方法；<br>4）一个类只能继承一个抽象类，而一个类却可以实现多个接口。<br>5）抽象类中的方法子类必须全部实现，不然子类也是抽象类，而接口中的抽象方法子类必须全部实现，是可选择实现的。<br>6）抽象类是一种模板设计模式，而接口时一种行为规范。</li></ol>','2017-03-02',1,38,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(322,'2017-03-03学习笔记','一、String StringBuffer.toString()源码： @Override\r\npublic synchronized String toString() {\r\n    if (toStringCache == null) {\r\n        toStringCache = Arrays.copyOfRange(value, 0, count);\r\n    }\r\n    retur','<h4 id=\"h4--string\"><a name=\"一、String\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、String</h4><p>StringBuffer.toString()源码：</p>\r\n<pre><code class=\"lang-java\">@Override\r\npublic synchronized String toString() {\r\n    if (toStringCache == null) {\r\n        toStringCache = Arrays.copyOfRange(value, 0, count);\r\n    }\r\n    return new String(toStringCache, true);\r\n}\r\n</code></pre>\r\n<p>Arrays.copyOfRange用的是System.arraycopy</p>\r\n<pre><code class=\"lang-java\">public static char[] copyOfRange(char[] original, int from, int to) {\r\n        int newLength = to - from;\r\n        if (newLength &lt; 0)\r\n            throw new IllegalArgumentException(from + &quot; &gt; &quot; + to);\r\n        char[] copy = new char[newLength];\r\n        System.arraycopy(original, from, copy, 0,\r\n                         Math.min(original.length - from, newLength));\r\n        return copy;\r\n    }\r\n</code></pre>\r\n<p>1.String是值传入，不是引用传入。<br>2.String对String  类型进行改变的时候其实都等同于生成了一个新的  String  对象，然后将指针指向新的  String  对象，而不是StringBuffer；StringBuffer每次结果都会对  StringBuffer  对象本身进行操作，而不是生成新的对象，再改变对象引用。<br>3.效率比较String&lt;StringBuffer&lt;StringBuilder，但是在 String S1 = “This is only a” + “ simple” + “ test”时，String效率最高。</p>\r\n<h4 id=\"h4--jvm-\"><a name=\"二、jvm知识图谱\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、jvm知识图谱</h4><p><a href=\"https://zhuanlan.zhihu.com/p/25511795\">引用自知乎</a><br><img src=\"https://pic2.zhimg.com/v2-701563ac1fe745fc8e1234c96e82ac99_r.jpg\" alt=\"\"></p>\r\n<h4 id=\"h4--treemap-linkhashmap\"><a name=\"三、Treemap、LinkHashMap\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、Treemap、LinkHashMap</h4><p>1.TreeMap取出来的是排序后的键值对。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。<br>2.LinkedHashMap 是HashMap的一个子类，如果需要输出的顺序和输入的相同,那么用LinkedHashMap可以实现,它还可以按读取顺序来排列。</p>\r\n<h4 id=\"h4--sql-\"><a name=\"四、sql模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>四、sql模式</h4><p>MySQL数据库中，变量分为 系统变量（以”@@”开头）和用户自定义变量。系统变量分为全局系统变量(global)和会话系统变量(session)。<br>@<a href=\"https://github.com/global\" title=\"&#64;global\" class=\"at-link\">@global</a>     仅用于访问全局系统变量的值；<br>@<a href=\"https://github.com/session\" title=\"&#64;session\" class=\"at-link\">@session</a>  仅用于访问会话系统变量的值；<br>@@              先访问会话系统变量的值，若不存在则去访问全局系统变量的值；<br>sql_mode 为系统变量，既是全局系统变量，又是会话系统变量。</p>\r\n<h4 id=\"h4--\"><a name=\"五、代码的执行顺序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>五、代码的执行顺序</h4><p>父类Ｂ静态代码块-&gt;子类Ａ静态代码块-&gt;父类Ｂ非静态代码块-&gt;父类Ｂ构造函数-&gt;子类Ａ非静态代码块-&gt;子类Ａ构造函数<br><img src=\"http://ohlrxdl4p.bkt.clouddn.com/images/QQ截图20170303165728.jpg\" alt=\"\"></p>','2017-03-03',1,37,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(323,'ifhifhajfe','hello','<h1 id=\"h1-hello\"><a name=\"hello\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>hello</h1>','2017-03-05',1,38,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(324,'2017-03-05学习笔记','java的堆，栈，静态代码区（常量区） 详解','<p><a href=\"http://blog.csdn.net/u012031380/article/details/54981472\"> java的堆，栈，静态代码区（常量区） 详解</a></p>','2017-03-05',1,33,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(325,'java归并排序','package datastruct;\r\n\r\n/**\r\n * Created by Zephery on 2017/3/3.\r\n */\r\npublic class Solution {\r\n    public static void printArray(int[] arr, int i, int j) {\r\n        System.out.print(\"[\");\r\n        for','<pre><code class=\"lang-java\">package datastruct;\r\n\r\n/**\r\n * Created by Zephery on 2017/3/3.\r\n */\r\npublic class Solution {\r\n    public static void printArray(int[] arr, int i, int j) {\r\n        System.out.print(&quot;[&quot;);\r\n        for (int k = i; k &lt; j; k++) {\r\n            System.out.print(arr[k] + &quot;,&quot;);\r\n        }\r\n        System.out.print(arr[j] + &quot;]&quot;);\r\n    }\r\n\r\n    private static void mergesort(int[] arr, int i, int j) {\r\n        int mid = 0;\r\n        if (i &lt; j) {\r\n            mid = (i + j) / 2;\r\n            mergesort(arr, i, mid);\r\n            mergesort(arr, mid + 1, j);\r\n            merge(arr, i, mid, j);\r\n        }\r\n    }\r\n\r\n    private static void merge(int[] arr, int i, int mid, int j) {\r\n        System.out.print(&quot;Left:&quot;);\r\n        printArray(arr, i, mid);\r\n        System.out.println(&quot;Right:&quot;);\r\n        printArray(arr, mid + 1, j);\r\n        System.out.println();\r\n        int temp[] = new int[arr.length];\r\n        int l = i;\r\n        int r = j;\r\n        int m = mid + 1;\r\n        int k = l;\r\n        while (l &lt;= mid &amp;&amp; m &lt;= r) {\r\n            if (arr[l] &lt;= arr[m]) {\r\n                temp[k++] = arr[l++];\r\n            } else {\r\n                temp[k++] = arr[m++];\r\n            }\r\n        }\r\n        while (l &lt;= mid) {\r\n            temp[k++] = arr[l++];\r\n        }\r\n        while (m &lt;= r) {\r\n            temp[k++] = arr[m++];\r\n        }\r\n        for (int i1 = i; i1 &lt;= j; i1++) {\r\n            arr[i1] = temp[i1];\r\n        }\r\n        System.out.print(&quot;After Merge:&quot;);\r\n        printArray(arr, i, j);\r\n        System.out.println();\r\n    }\r\n\r\n    public static void main(String args[]) {\r\n        int[] arr = {9, 4, 8, 3, 1, 2, 5};\r\n        System.out.print(&quot;Initial Array:&quot;);\r\n        printArray(arr, 0, arr.length - 1);\r\n        System.out.println();\r\n        mergesort(arr, 0, arr.length - 1);\r\n    }\r\n}\r\n</code></pre>\r\n<pre><code class=\"lang-js\">Initial Array:[9,4,8,3,1,2,5]\r\nLeft:[9]Right:\r\n[4]\r\nAfter Merge:[4,9]\r\nLeft:[8]Right:\r\n[3]\r\nAfter Merge:[3,8]\r\nLeft:[4,9]Right:\r\n[3,8]\r\nAfter Merge:[3,4,8,9]\r\nLeft:[1]Right:\r\n[2]\r\nAfter Merge:[1,2]\r\nLeft:[1,2]Right:\r\n[5]\r\nAfter Merge:[1,2,5]\r\nLeft:[3,4,8,9]Right:\r\n[1,2,5]\r\nAfter Merge:[1,2,3,4,5,8,9]\r\n</code></pre>','2017-03-06',1,36,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(326,'2017-03-10学习笔记','1.Integer和int，装箱拆箱 1、基本型和基本型封装型进行“==”运算符的比较，基本型封装型将会自动拆箱变为基本型后再进行比较，因此Integer(0)会自动拆箱为int类型再进行比较，显然返回true； 2、两个Integer类型进行“==”比较，如果其值在-128至127，那么返回true，否则返回false, 这跟Integer.valueOf()的缓冲对象有关，这里不进行赘述。 3','<h1 id=\"h1-1-integer-int-\"><a name=\"1.Integer和int，装箱拆箱\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.Integer和int，装箱拆箱</h1><p>1、基本型和基本型封装型进行“==”运算符的比较，基本型封装型将会自动拆箱变为基本型后再进行比较，因此Integer(0)会自动拆箱为int类型再进行比较，显然返回true；<br>2、两个Integer类型进行“==”比较，如果其值在-128至127，那么返回true，否则返回false, 这跟Integer.valueOf()的缓冲对象有关，这里不进行赘述。<br>3、两个基本型的封装型进行equals()比较，首先equals()会比较类型，如果类型相同，则继续比较值，如果值也相同，返回true<br>4、基本型封装类型调用equals(),但是参数是基本类型，这时候，先会进行自动装箱，基本型转换为其封装类型，再进行3中的比较。</p>\r\n<pre><code class=\"lang-java\">int a=257;\r\nInteger b=257;\r\nInteger c=257;\r\nInteger b2=57;\r\nInteger c2=57;\r\nSystem.out.println(a==b);\r\n//System.out.println(a.equals(b));  编译出错，基本型不能调用equals()\r\nSystem.out.println(b.equals(257.0));\r\nSystem.out.println(b==c);\r\nSystem.out.println(b2==c2);\r\n</code></pre>\r\n<p>因此上面的代码的结果因此为 true, false, false, true</p>\r\n<h1 id=\"h1-2-\"><a name=\"2.线程调度\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.线程调度</h1><p>分为协同式调度和抢占式调度，Java使用的是抢占式调度，也就是每个线程将由操作系统来分配执行时间，线程的切换不由线程本身来决定（协同式调度）。这就是平台独立的原因。</p>\r\n<h1 id=\"h1-3-\"><a name=\"3.重载，重写\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.重载，重写</h1><p>重写：<br>两同，两小，一大<br>两同：方法名，方法参数列表相同。<br>两小：抛出的异常类型要小于等于父类，返回值类型要小于等于父类<br>一大：访问权限大于等于父类。<br>重载：<br>在同一个类中，方法名和方法参数列表不同，其他的（访问权限、返回值）随意。</p>\r\n<h1 id=\"h1-4-jvm-\"><a name=\"4.  JVM面试题\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.<a href=\"http://blog.csdn.net/hsk256/article/details/49104955\">JVM面试题</a></h1>','2017-03-10',1,30,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(327,'2017-03-12学习笔记','1.继承的加载顺序 执行顺序大体上可以说是先父类后子类，父类static域 ==》子类static域 ==》父类数据成员域 ==》父类构造器 ==》子类数据成员域 ==》子类构造器 2.优化Hibernate所鼓励的7大措施： 1.尽量使用many-to-one，避免使用单项one-to-many 2.灵活使用单向one-to-many 3.不用一对一，使用多对一代替一对一 4.配置对象缓存，不使','<h4 id=\"h4-1-\"><a name=\"1.  继承的加载顺序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.<a href=\"http://www.cnblogs.com/SirSmith/p/5536288.html\">继承的加载顺序</a></h4><p><img src=\"http://images2015.cnblogs.com/blog/452847/201605/452847-20160527221410288-2119099273.png\" alt=\"\"></p>\r\n<p>执行顺序大体上可以说是先父类后子类，父类static域 ==》子类static域 ==》父类数据成员域 ==》父类构造器 ==》子类数据成员域 ==》子类构造器</p>\r\n<h4 id=\"h4-2-hibernate-7-\"><a name=\"2.优化Hibernate所鼓励的7大措施：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.优化Hibernate所鼓励的7大措施：</h4><p>1.尽量使用many-to-one，避免使用单项one-to-many<br>2.灵活使用单向one-to-many<br>3.不用一对一，使用多对一代替一对一<br>4.配置对象缓存，不使用集合缓存<br>5.一对多使用Bag 多对一使用Set<br>6.继承使用显示多态 HQL:from object polymorphism=”exlicit” 避免查处所有对象<br>7.消除大表，使用二级缓存</p>\r\n<h4 id=\"h4-3-java-\"><a name=\"3.java中的数据类型分类：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.java中的数据类型分类：</h4><p>基本数据类型（或叫做原生类、内置类型）8种：<br>    整数：byte，short，int，long（默认是int类型）<br>    浮点类型： float，double（默认是double类型）<br>    字符类型：char<br>    布尔类型：boolean<br>引用数据类型3种：数组，类，接口</p>\r\n<h4 id=\"h4-4-\"><a name=\"4.触发器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.触发器</h4><p>drop trigger 删除触发器<br>Drop用于删除数据表或数据库，或删除数据表字段。<br>remove：删除数据库文件<br>Truncate：删除数据表中的数据（仅数据表中的数据，不删除表）。</p>','2017-03-12',1,27,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(328,'2017-03-14学习笔记','1.Servlet的生命周期分为5个阶段：加载、创建、初始化、处理客户请求、卸载。 (1)加载：容器通过类加载器使用servlet类对应的文件加载servlet (2)创建：通过调用servlet构造函数创建一个servlet对象 (3)初始化：调用init方法初始化 (4)处理客户请求：每当有一个客户请求，容器会创建一个线程来处理客户请求 (5)卸载：调用destroy方法让servlet自己释','<h4 id=\"h4-1-servlet-5-\"><a name=\"1.Servlet的生命周期分为5个阶段：加载、创建、初始化、处理客户请求、卸载。\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.Servlet的生命周期分为5个阶段：加载、创建、初始化、处理客户请求、卸载。</h4><p>(1)加载：容器通过类加载器使用servlet类对应的文件加载servlet<br>(2)创建：通过调用servlet构造函数创建一个servlet对象<br>(3)初始化：调用init方法初始化<br>(4)处理客户请求：每当有一个客户请求，容器会创建一个线程来处理客户请求<br>(5)卸载：调用destroy方法让servlet自己释放其占用的资源</p>\r\n<h4 id=\"h4-2-jsp\"><a name=\"2.JSP\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.JSP</h4><p><img src=\"http://uploadfiles.nowcoder.com/images/20160308/595432_1457414324036_C3D4EB7F2D61708D0C0BE2921A45B74D\" alt=\"\"></p>','2017-03-14',1,22,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(329,'2017-03-17学习笔记','1.GC线程是否和守护线程 2.java堆排序','<h4 id=\"h4-1-gc-\"><a name=\"1.GC线程是否和守护线程\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.GC线程是否和守护线程</h4><h4 id=\"h4-2-java-\"><a name=\"2.java堆排序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.java堆排序</h4>','2017-03-17',1,20,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(330,'春招~好失落啊','自己的情况：广东人，大学跑到天津一所二本学校，网络工程专业，大一大二学ccna、ccnp，发现没有创造性，按着别人的死规定敲命令好无聊，大三彻底转向编程，c++看着不爽，调研一番后选择java，自学java和java web，对jsp、servlet略过，直接上手框架（Struts，hibernate，spring），看书，找视频，敲项目，非专业课（操作系统，数据库等）不听，捣鼓一番觉得还行，继续','<p>自己的情况：广东人，大学跑到天津一所二本学校，网络工程专业，大一大二学ccna、ccnp，发现没有创造性，按着别人的死规定敲命令好无聊，大三彻底转向编程，c++看着不爽，调研一番后选择java，自学java和java web，对jsp、servlet略过，直接上手框架（Struts，hibernate，spring），看书，找视频，敲项目，非专业课（操作系统，数据库等）不听，捣鼓一番觉得还行，继续学习spring mvc，mybatis，开始了解hadoop、spark，同时搭了自己的网站，跟了软件工程的同学比了比，还能算上前列吧，当然，基础和算法跟前列的人还没得比~~~</p>\r\n<p>去年秋招，腾讯、阿里等笔试全挂，京东的没怎么做却过了，不敢去面试（真心没怎么做题），最后去了北京一家创业公司实习了三个月多，感觉真心好，12月几乎整整一个月雾霾，受不了，还是回广东吧。在家过了春节，2月10号跟同学一起来深圳，就这样，开始了春招之旅~~~~</p>\r\n<p>第一家，面试的问的差不多全答对，手写了几个sql也对了，不过居然没有问hashmap，给的工资6000到9000，想了想，还是不去的好，太郊区，后来一查，是个培训兼外包的企业，还好没去。。。。</p>\r\n<p>第二家，某ERP公司，额，笔试，全是sql，做了，感觉还可以，面试直接说我们公司不用java，用的一个小众语言，薪资应届生只有3500，直接走人。。。。</p>\r\n<p>第三家，找工作，对广东真是彻底失望了，投的简历除了培训机构理你，其他的都不理人的，无奈之下投了北京的一家创业公司（A轮），薪资1万，电话面试，过了。。。。。后来想想，还是不去北京了，虽然工资高，但是没有朋友，过得像个死人一样。</p>\r\n<p>第四家，深圳一家创业公司，做东南亚社交软件的，可惜薪资没谈成，4K-6K，这可是深圳啊。。。。</p>\r\n<p>第五家，广州凡科，那天一早就从深圳跑过去，没吃饭，下午到就做笔试题，头晕，手抖，然后一面就是跟你讲笔试题，讲了两道，就叫我走了。。。仅仅半个小时，广深来回6个小时。。。</p>\r\n<p>第六家，广州某搞运维的公司，笔试差不多答对，面试问的问题也答对，但是没给offer。。。不理解</p>\r\n<p>第七家，然后晚上跑去了广工的久邦数码宣讲，试卷发到我这的时候，HR说我这方向的试卷没带够。。。。无奈向他要了大数据的题，全是数据库的题，过几天后得知居然过了，然后一面，问的问题没啥印象，除了left join的原理没答对。。。今天得知挂了。。。。</p>\r\n<p><img src=\"http://images2015.cnblogs.com/blog/755525/201703/755525-20170318000537838-305991370.png\" alt=\"\"></p>\r\n<p>第八家，极天信息（A轮），笔试的题目没看懂它问的啥，一面没啥印象了，然后是经理面，说广州没那么高的工资（7000），等消息，估计也没谈成。。。。</p>\r\n<p>第九家，中国移动，最气的了，一面就是HR面，问了两个问题，为什么不在北京留着，你觉得相比其他人你有什么优势。我只能说我真不会说话更不知怎么回答，就强调勤奋，然后直接被HR叫走人了，3分钟=w=</p>\r\n<p>第十家，珍爱网，找别人内推的，三个问题没答上来，就不跟你们说了，亲爱的竞争对手们=w=，谈了四十分钟吧，出来后感觉很不好，估计也是挂了。。。</p>\r\n<p>今天晚上，收到了久邦数码的拒绝信，瞬间觉得好无奈好迷茫，有时候就那么一个简简单单的问题，答不好就直接拒绝的，改怎么心平气和的面对下一个面试。有时候真不理解公司是怎么招人的，是不是真的“把部分简历扔进垃圾桶，不招那些运气不好的人”？也只能这么安慰自己。可是，事实呢？</p>\r\n<p><img src=\"http://images2015.cnblogs.com/blog/755525/201703/755525-20170318001336463-1583022291.jpg\" alt=\"\"></p>\r\n<p>这些天，有时间都是往深圳图书馆跑，看书，刷牛客网，补算法，看源码，做了这么多，该怎么告诉自己不要放弃。。。。。开始有点想念北京的雾霾</p>','2017-03-18',5,20,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(331,'数据库','1.SQL执行的顺序 2.NULL “空值” 和”NULL”的概念： 1：空值(‘’)是不占用空间的,判断空字符用 = ‘’ 或者 <> ‘’ 来进行处理; 2: NULL值是未知的，且占用空间，不走索引;判断 NULL 用 IS NULL 或者 is not null , SQL 语句函数中可以使用 ifnull ()函数来进行处理. 注：在进行 count ()统计某列的记录数的时候，如果采用','<h4 id=\"h4-1-sql-\"><a name=\"1.SQL执行的顺序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.SQL执行的顺序</h4><p><img src=\"http://uploadfiles.nowcoder.com/images/20150828/415611_1440751995009_3B3E1329A400F0022B20C4F32AEFC9EF\" alt=\"\"></p>\r\n<h4 id=\"h4-2-null\"><a name=\"2.NULL\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.NULL</h4><p>“空值” 和”NULL”的概念：<br>  1：空值(‘’)是不占用空间的,判断空字符用 = ‘’ 或者 &lt;&gt; ‘’ 来进行处理;<br> 2: NULL值是未知的，且占用空间，不走索引;判断 NULL 用 IS NULL 或者 is not null , SQL 语句函数中可以使用 ifnull ()函数来进行处理.<br>注：在进行 count ()统计某列的记录数的时候，如果采用的 NULL 值，会别系统自动忽略掉，但是空值是统计到其中</p>\r\n<h4 id=\"h4-3-\"><a name=\"3.\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.</h4><p>在MySQL数据库中，NULL对于一些特殊类型的列来说，其代表了一种特殊的含义，而不仅仅是一个空值。<br>IS NULL: 此运算符返回true，当列的值是NULL。<br>IS NOT NULL: 运算符返回true，当列的值不是NULL。<br>&lt;=&gt; 操作符比较值（不同于=运算符）为ture，即使两个NULL值<br>涉及NULL条件是特殊的。不能使用 =NULL 或 !=NULL 寻找NULL值的列</p>\r\n<h4 id=\"h4-4-nf\"><a name=\"4.NF\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.NF</h4><p>第一范式（   1NF   ）：   字段具有   原子性   ,   不可再分   。所有关系型数据库系统都满足第一范式）数据库表中的字段都是单一属性的，不可再分。例如，姓名字段，其中的姓和名必须作为一个整体，无法区分哪部分是姓，哪部分是名，如果要区分出姓和名，必须设计成两个独立的字段。<br>第二范式（   2NF   ）：   第二范式（   2NF   ）是在   第一范式（   1NF   ）的基础上   建立起来的，即满足第二范式（   2NF   ）必须先满足第一范式（   1NF   ）。要求   数据库表中的每个实例或行必须可以被惟一地区分   。通常需要为表加上一个列，以存储各个实例的惟一标识。这个惟一属性列被称为   主关键字或主键   。<br>        第二范式（   2NF   ）要求   实体的属性完全依赖于主关键字   。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。简而言之，第二范式就是非主属性非部分依赖于主关键字。<br>第三范式 （  3NF  ） ：   满足第三范式（   3NF   ）   必须先满足第二范式（   2NF   ）   。简而言之，第三范式（   3NF   ）要求一个数据库表中   不包含   已在其它表中   已包含的非主关键字信息   。所以第三范式具有如下特征：<br>1   ，每一列只有一个值<br>2   ，每一行都能区分。<br>3   ，每一个表都   不包含其他表已经包含   的非主关键字信息。<br>例如，帖子表中只能出现发帖人的   id   ，而不能出现发帖人的   id   ，还同时出现发帖人姓名，否则，只要出现同一发帖人   id   的所有记录，它们中的姓名部分都必须严格保持一致，这就是   数据冗余   。</p>','2017-03-18',3,19,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(332,'重载与重写','目前的问题：父类的功能无法满足子类的需求。 方法重写的前提： 必须要存在继承的关系。 方法的重写: 子父类出了同名的函数，这个我们就称作为方法的重写。 什么是时候要使用方法的重写：父类的功能无法满足子类的需求时。 方法重写要注意的事项： 1.方法重写时， 方法名与形参列表必须一致。 2.方法重写时，子类的权限修饰符必须要大于或者等于父类的权限修饰符。 3.方法重写时，子类的返回值类型必须要小于或者','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><p>目前的问题：父类的功能无法满足子类的需求。</p>\n<p>方法重写的前提： 必须要存在继承的关系。</p>\n<p>方法的重写: 子父类出了同名的函数，这个我们就称作为方法的重写。</p>\n<p>什么是时候要使用方法的重写：父类的功能无法满足子类的需求时。</p>\n<p>方法重写要注意的事项：<br>    1.方法重写时， 方法名与形参列表必须一致。<br>    2.方法重写时，子类的权限修饰符必须要大于或者等于父类的权限修饰符。<br>    3.方法重写时，子类的返回值类型必须要小于或者 等于父类的返回值类型。<br>    4.方法重写时， 子类抛出的异常类型要小于或者等于父类抛出的异常类型。<br>            Exception(最坏)<br>            RuntimeException(小坏)</p>\n<p>方法的重载：在一个类中 存在两个或者两个 以上的同名函数,称作为方法重载。</p>\n<p>方法重载的要求</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"lit\">1.</span><span class=\"pln\"> </span><span class=\"pun\">函数名要一致。</span></code></li><li class=\"L1\"><code><span class=\"lit\">2.</span><span class=\"pln\"> </span><span class=\"pun\">形参列表不一致（形参的个数或形参</span><span class=\"pln\"> </span><span class=\"pun\">的类型不一致）</span></code></li><li class=\"L2\"><code><span class=\"lit\">3.</span><span class=\"pln\"> </span><span class=\"pun\">与返回值类型无关。</span></code></li></ol></pre></div>','2017-03-21',1,19,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(333,'垃圾回收算法','垃圾回收算法 1、标记-清除算法 2、复制算法 3、标记-整理算法 一、标记-清除算法 标记-清除算法采用从根集合进行扫描，对存活的对象对象标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收，如上图所示。 标记-清除算法不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效，但由于标记-清除算法直接回收不存活的对象，因此会造成内存碎片！ 二、复制算法 复制算法','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h2 id=\"h2-u5783u573Eu56DEu6536u7B97u6CD5\"><a name=\"垃圾回收算法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>垃圾回收算法</h2><p>1、标记-清除算法<br>2、复制算法<br>3、标记-整理算法</p>\n<h4 id=\"h4--\"><a name=\"一、标记-清除算法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、标记-清除算法</h4><p><img src=\"http://dl2.iteye.com/upload/attachment/0075/0386/29ae17ad-f8af-38b4-9e25-28ef3550858f.jpg\" alt=\"\">标记-清除算法采用从根集合进行扫描，对存活的对象对象标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收，如上图所示。<br>标记-清除算法不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效，但由于标记-清除算法直接回收不存活的对象，因此会造成内存碎片！</p>\n<h4 id=\"h4--\"><a name=\"二、复制算法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、复制算法</h4><p><img src=\"http://dl2.iteye.com/upload/attachment/0075/0388/91a656d4-f08a-377b-8eea-5785c2932533.jpg\" alt=\"\"><br>复制算法采用从根集合扫描，并将存活对象复制到一块新的，没有使用过的空间中，这种算法当控件存活的对象比较少时，极为高效，但是带来的成本是需要一块内存交换空间用于进行对象的移动。也就是我们前面提到的s0 s1等空间。</p>\n<h4 id=\"h4--\"><a name=\"三、标记-整理算法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、标记-整理算法</h4><p><img src=\"http://dl2.iteye.com/upload/attachment/0075/0390/6ba95f80-c7bc-3d09-b927-ac09297e9920.jpg\" alt=\"\"><br> 标记-整理算法采用标记-清除算法一样的方式进行对象的标记，但在清除时不同，在回收不存活的对象占用的空间后，会将所有的存活对象往左端空闲空间移动，并更新对应的指针。标记-整理算法是在标记-清除算法的基础上，又进行了对象的移动，因此成本更高，但是却解决了内存碎片的问题。</p>\n</div>','2017-04-09',1,20,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(334,'java分代回收','一、新生代内存的回收（minor GC）主要采用复制算法，下图展示了minor GC的执行过程。 二、对于新生代和旧生代，JVM可使用很多种垃圾回收器进行垃圾回收，下图展示了不同生代不通垃圾回收器，其中两个回收器之间有连线表示这两个回收器可以同时使用。 而这些垃圾回收器又分为串行回收方式、并行回收方式合并发回收方式执行，分别运用于不同的场景。如下图所示 三、收集器 1.Serial收集器 看名字我','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h2 id=\"h2--minor-gc-minor-gc-\"><a name=\"一、新生代内存的回收（minor GC）主要采用复制算法，下图展示了minor GC的执行过程。\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、新生代内存的回收（minor GC）主要采用复制算法，下图展示了minor GC的执行过程。</h2><p><img src=\"http://dl2.iteye.com/upload/attachment/0075/0392/732c7557-aa9a-3551-b14d-f543c5b0c94b.jpg\" alt=\"\"></p>\n<h2 id=\"h2--jvm-\"><a name=\"二、对于新生代和旧生代，JVM可使用很多种垃圾回收器进行垃圾回收，下图展示了不同生代不通垃圾回收器，其中两个回收器之间有连线表示这两个回收器可以同时使用。\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、对于新生代和旧生代，JVM可使用很多种垃圾回收器进行垃圾回收，下图展示了不同生代不通垃圾回收器，其中两个回收器之间有连线表示这两个回收器可以同时使用。</h2><p><img src=\"http://dl2.iteye.com/upload/attachment/0075/0394/0172f624-9018-3642-bf26-05a2c3071639.jpg\" alt=\"\"><br>而这些垃圾回收器又分为串行回收方式、并行回收方式合并发回收方式执行，分别运用于不同的场景。如下图所示<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0396/c962c2ad-273f-3de4-b2e3-a4dd8b946215.jpg\" alt=\"\"></p>\n<h2 id=\"h2--\"><a name=\"三、收集器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、收集器</h2><h4 id=\"h4-1-serial-\"><a name=\"1.Serial收集器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.Serial收集器</h4><p>看名字我们都可以看的出来，这个属于串行收集器。其运行示意图如下<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0398/681da5ca-5eff-3984-bece-3d80dfe905be.jpg\" alt=\"\"><br>    收集器是历史最悠久的一个回收器，JDK1.3之前广泛使用这个收集器，目前也是ClientVM下 ServerVM 4核4GB以下机器的默认垃圾回收器。串行收集器并不是只能使用一个CPU进行收集，而是当JVM需要进行垃圾回收的时候，需要中断所有的用户线程，知道它回收结束为止，因此又号称“Stop The World” 的垃圾回收器。注意，JVM中文名称为java虚拟机，因此它就像一台虚拟的电脑一样在工作，而其中的每一个线程就被认为是JVM的一个处理器，因此大家看到图中的CPU0、CPU1实际为用户的线程，而不是真正机器的CPU，大家不要误解哦。<br>    串行回收方式适合低端机器，是Client模式下的默认收集器，对CPU和内存的消耗不高，适合用户交互比较少，后台任务较多的系统。<br>    Serial收集器默认新旧生代的回收器搭配为Serial+ SerialOld</p>\n<h4 id=\"h4-2-parnew-\"><a name=\"2.ParNew收集器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.ParNew收集器</h4><p>ParNew收集器其实就是多线程版本的Serial收集器，其运行示意图如下<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0400/6443b39c-ed33-3d93-a690-87e646439561.jpg\" alt=\"\"><br>同样有Stop The World的问题，他是多CPU模式下的首选回收器（该回收器在单CPU的环境下回收效率远远低于Serial收集器，所以一定要注意场景哦），也是Server模式下的默认收集器。</p>\n<h4 id=\"h4-3-parallelscavenge\"><a name=\"3.ParallelScavenge\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.ParallelScavenge</h4><p>ParallelScavenge又被称为是吞吐量优先的收集器，器运行示意图如下<br><img src=\"http://dl.iteye.com/upload/attachment/0075/0402/5007beba-0b0e-3cf4-b146-c28b6c0dd696.jpg\" alt=\"\"><br> ParallelScavenge<br>所提到的吞吐量=程序运行时间/(JVM执行回收的时间+程序运行时间),假设程序运行了100分钟，JVM的垃圾回收占用1分钟，那么吞吐量就是99%。在当今网络告诉发达的今天，良好的响应速度是提升用户体验的一个重要指标，多核并行云计算的发展要求程序尽可能的使用CPU和内存资源，尽快的计算出最终结果，因此在交互不多的云端，比较适合使用该回收器。</p>\n<h4 id=\"h4-4-parallelold\"><a name=\"4.ParallelOld\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.ParallelOld</h4><p>ParallelOld是老生代并行收集器的一种，使用标记整理算法、是老生代吞吐量优先的一个收集器。这个收集器是JDK1.6之后刚引入的一款收集器，我们看之前那个图之间的关联关系可以看到，早期没有ParallelOld之前，吞吐量优先的收集器老生代只能使用串行回收收集器，大大的拖累了吞吐量优先的性能，自从JDK1.6之后，才能真正做到较高效率的吞吐量优先。其运行示意图如下<br><img src=\"http://dl.iteye.com/upload/attachment/0075/0406/9a14da85-f943-3408-ba88-c6bb3842a792.jpg\" alt=\"\"></p>\n<h4 id=\"h4-5-serialold\"><a name=\"5.SerialOld\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.SerialOld</h4><p>SerialOld是旧生代Client模式下的默认收集器，单线程执行；在JDK1.6之前也是ParallelScvenge回收新生代模式下旧生代的默认收集器，同时也是并发收集器CMS回收失败后的备用收集器。其运行示意图如下<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0404/ce7aabd5-b0e0-3cda-9b6c-607cf6ebf689.jpg\" alt=\"\"></p>\n<h4 id=\"h4-5-cms\"><a name=\"5.CMS\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.CMS</h4><p>CMS又称响应时间优先(最短回收停顿)的回收器，使用并发模式回收垃圾，使用标记-清除算法，CMS对CPU是非常敏感的，它的回收线程数=（CPU+3）/4，因此当CPU是2核的实惠，回收线程将占用的CPU资源的50%，而当CPU核心数为4时仅占用25%。他的运行示意图如下<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0408/4239228b-879f-382f-81c6-5c32799886d6.jpg\" alt=\"\"><br>模式主要分为四个过程：<br>1.初始标记<br>2.并发标记<br>3.重新标记<br>4.并发清除<br>在初始标记的时候，需要中断所有用户线程，在并发标记阶段，用户线程和标记线程<br>并发执行，而在这个过程中，随着内存引用关系的变化，可能会发生原来标记的对象被释放，进而引发新的垃圾，因此可能会产生一系列的浮动垃圾，不能被回收。</p>\n<p>CMS 为了确保能够扫描到所有的对象，避免在Initial Marking 中还有未标识到的对象，采用的方法为找到标记了的对象，并将这些对象放入Stack 中，扫描时寻找此对象依赖的对象，如果依赖的对象的地址在其之前，则将此对象进行标记，并同时放入Stack 中，如依赖的对象地址在其之后，则仅标记该对象。<br>在进行Concurrent Marking 时minor GC 也可能会同时进行，这个时候很容易造成旧生代对象引用关系改变，CMS 为了应对这样的并发现象，提供了一个Mod Union Table 来进行记录，在这个Mod Union Table中记录每次minor GC 后修改了的Card 的信息。这也是ParallelScavenge不能和CMS一起使用的原因。<br>CMS产生浮动垃圾的情况请见如下示意图<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0410/60e7c659-790a-3405-af70-9ca4cfd9258d.jpg\" alt=\"\"><br>在运行回收过后，c就变成了浮动垃圾。<br>由于CMS会产生浮动垃圾，当回收过后，浮动垃圾如果产生过多，同时因为使用标记-清除算法会产生碎片，可能会导致回收过后的连续空间仍然不能容纳新生代移动过来或者新创建的大资源，因此会导致CMS回收失败，进而触发另外一次FULL GC，而这时候则采用SerialOld进行二次回收。<br>同时CMS因为可能产生浮动垃圾，而CMS在执行回收的同时新生代也有可能在进行回收操作，为了保证旧生代能够存放新生代转移过来的数据，CMS在旧生代内存到达全部容量的68%就触发了CMS的回收！</p>\n<h4 id=\"h4-7-garbagefirst-g1-\"><a name=\"7.GarbageFirst(G1)\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>7.GarbageFirst(G1)</h4><p>我们再来看垃圾回收器的总图，刚才我们可以看到，我在图上标记了一个？，其实这是一个新的垃圾回收器，既可以回收新生代也可以回收旧生代，SunHotSpot 1.6u14以上EarlyAccess版本加入了这个回收器，sun公司预期SunHotSpot1.7发布正式版，他是商用高性能垃圾回收器，通过重新划分内存区域，整合优化CMS，同时注重吞吐量和响应时间，但是杯具的是被Oracle收购之后这个收集器属于商用收费收集器，因此目前基本上没有人使用，我们在这里也就不多介绍，更多信息可以参考oracle新版本JDK说明。</p>\n</div>','2017-04-09',1,20,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(335,'java汇编','java 汇编 http://download.csdn.net/download/jiangfuqiang/8403497','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><p>java 汇编<br><a href=\"http://download.csdn.net/download/jiangfuqiang/8403497\">http://download.csdn.net/download/jiangfuqiang/8403497</a></p>\n</div>','2017-04-10',1,19,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(336,'jvm','-XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><p>-XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly</p>\n</div>','2017-04-10',1,20,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(337,'Adaboost','NaiveBayesSpamFilter 利用朴素贝叶斯算法实现垃圾邮件的过滤，并结合Adaboost改进该算法。 1 Naive Bayes spam filtering   假设邮件的内容中包含的词汇为Wi，垃圾邮件Spam，正常邮件ham。 判断一份邮件，内容包含的词汇为Wi，判断该邮件是否是垃圾邮件，即计算P（S|Wi）这个条件概率。根据Bayes’ theorem：   Bayes’ t','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h1 id=\"h1-naivebayesspamfilter\"><a name=\"NaiveBayesSpamFilter\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>NaiveBayesSpamFilter</h1><p>利用朴素贝叶斯算法实现垃圾邮件的过滤，并结合Adaboost改进该算法。</p>\n<h3 id=\"h3-1-naive-bayes-spam-filtering\"><a name=\"1 Naive Bayes spam filtering\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1 Naive Bayes spam filtering</h3><p>  假设邮件的内容中包含的词汇为Wi，垃圾邮件Spam，正常邮件ham。 判断一份邮件，内容包含的词汇为Wi，判断该邮件是否是垃圾邮件，即计算P（S|Wi）这个条件概率。根据Bayes’ theorem：</p>\n<p>  Bayes’ theorem</p>\n<p>  其中：</p>\n<p>Pr(S|Wi) 出现词汇Wi的邮件是垃圾邮件的条件概率（即后验概率）；<br>Pr(S) 训练阶段邮件数据集中垃圾邮件的概率，或实际调查的垃圾邮件的概率（即先验概率）；<br>Pr(Wi|S) 垃圾邮件中词汇Wi出现的概率；<br>Pr(H) 训练阶段邮件数据集中正常邮件的概率，或实际调查的正常邮件的概率；<br>Pr(Wi|H) 正常邮件中词汇Wi出现的概率；<br>  对于邮件中出现的所有词汇，考虑每个词汇出现事件的独立性，计算Pr(S|Wi)的联合概率Pr(S|W)，W={W1，W2，…Wn}：</p>\n<p>  Bayes’ theorem</p>\n<p>  其中：</p>\n<p>P 即Pr(S|W)，出现词汇W={W1，W2……Wn}的邮件是垃圾邮件的条件概率；<br>Pi 即Pr(S|Wi)，出现词汇Wi的邮件是垃圾邮件的条件概率；<br>  注： 程序中，通过计算出Pr(S|W)和Pr(H|W)，比较Pr(S|W)和Pr(H|W)的大小，判断是垃圾邮件还是正常邮件。我们发现Pr(S|W)和Pr(H|W)计算的分母相同，所以我们只需要比较分子即可。</p>\n<p>  但存在两个问题：</p>\n<p>当词汇不存在时，即ni=0，此时Pr(S|Wi) = 0，会造成P=0，无法比较<br>当Pr(S|Wi)较小时，连乘操作会造成下溢出问题<br>  解决方案：</p>\n<p>计算P(Wi|S)和P(Wi|H)时，将所有词汇初始化出现的次数为1，并将分母初始化为2（或根据样本/实际调查结果调整分母的值）。</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"com\"># 统计语料库中词汇在S和H中出现的次数</span></code></li><li class=\"L1\"><code><span class=\"pln\">wordsInSpamNum </span><span class=\"pun\">=</span><span class=\"pln\"> np</span><span class=\"pun\">.</span><span class=\"pln\">ones</span><span class=\"pun\">(</span><span class=\"pln\">numWords</span><span class=\"pun\">)</span></code></li><li class=\"L2\"><code><span class=\"pln\">wordsInHealthNum </span><span class=\"pun\">=</span><span class=\"pln\"> np</span><span class=\"pun\">.</span><span class=\"pln\">ones</span><span class=\"pun\">(</span><span class=\"pln\">numWords</span><span class=\"pun\">)</span></code></li><li class=\"L3\"><code><span class=\"pln\">spamWordsNum </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">2.0</span></code></li><li class=\"L4\"><code><span class=\"pln\">healthWordsNum </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">2.0</span></code></li></ol></pre><p>计算P(Wi|S)和P(Wi|H)时，对概率取对数<br>    pWordsSpamicity = np.log(wordsInSpamNum / spamWordsNum)<br>    pWordsHealthy = np.log(wordsInHealthNum / healthWordsNum)<br>  所以最终比较的是，P(W1|S)P(W2|S)….P(Wn|S)P(S)和P(W1|H)P(W2|H)….P(Wn|H)P(H)的大小。</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"pln\">ps </span><span class=\"pun\">=</span><span class=\"pln\"> sum</span><span class=\"pun\">(</span><span class=\"pln\">testWordsMarkedArray </span><span class=\"pun\">*</span><span class=\"pln\"> pWordsSpamicity</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">+</span><span class=\"pln\"> np</span><span class=\"pun\">.</span><span class=\"pln\">log</span><span class=\"pun\">(</span><span class=\"pln\">pSpam</span><span class=\"pun\">)</span></code></li><li class=\"L1\"><code><span class=\"pln\">ph </span><span class=\"pun\">=</span><span class=\"pln\"> sum</span><span class=\"pun\">(</span><span class=\"pln\">testWordsMarkedArray </span><span class=\"pun\">*</span><span class=\"pln\"> pWordsHealthy</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">+</span><span class=\"pln\"> np</span><span class=\"pun\">.</span><span class=\"pln\">log</span><span class=\"pun\">(</span><span class=\"lit\">1</span><span class=\"pln\"> </span><span class=\"pun\">-</span><span class=\"pln\"> pSpam</span><span class=\"pun\">)</span></code></li></ol></pre><p>  测试效果： 5574个样本，采用交叉验证，随机选取4574个作为训练样本，产生词汇列表（语料库），对1000个测试样本，分类的平均错误率约为：2.5%。</p>\n<h3 id=\"h3-2-running-adaboost-on-naive-bayes\"><a name=\"2 Running Adaboost on Naive Bayes\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2 Running Adaboost on Naive Bayes</h3><p>  我们在计算ps和ph联合后验概率时，可引入一个调整因子DS，其作用是调整词汇表中某一词汇的“垃圾程度”(spamicity)，</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"pln\">ps </span><span class=\"pun\">=</span><span class=\"pln\"> sum</span><span class=\"pun\">(</span><span class=\"pln\">testWordsMarkedArray </span><span class=\"pun\">*</span><span class=\"pln\"> pWordsSpamicity </span><span class=\"pun\">*</span><span class=\"pln\"> DS</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">+</span><span class=\"pln\"> np</span><span class=\"pun\">.</span><span class=\"pln\">log</span><span class=\"pun\">(</span><span class=\"pln\">pSpam</span><span class=\"pun\">)</span></code></li></ol></pre><p>  其中DS通过Adaboost算法迭代获取最佳值。原理如下：</p>\n<p>设定adaboost循环的次数count<br>交叉验证随机选择1000个样本<br>DS初始化为和词汇列表大小相等的全一向量<br>迭代循环count次：<br>    设定最小分类错误率为inf<br>    对于每一个样本：<br>        在当前DS下对样本分类<br>        如果分类出错：<br>            计算出错的程度，即比较ps和ph的相差alpha<br>            如果样本原本是spam，错分成ham：<br>                DS[样本包含的词汇] = np.abs(DS[样本包含的词汇] - np.exp(alpha) / DS[样本包含的词汇])<br>            如果样本原本是ham，错分成spam：<br>                DS[样本包含的词汇] = DS[样本包含的词汇] + np.exp(alpha) / DS[样本包含的词汇]<br>    计算错误率<br>    保存最小的错误率和此时的词汇列表、P(Wi|S)和P(Wi|H)、DS等信息，即保存训练好的最佳模型的信息<br>  测试效果： 5574个样本，获取Adaboost算法训练的最佳模型信息（包括词汇列表、P(Wi|S)和P(Wi|H)、DS等），对1000个测试样本，分类的平均错误率约为：0.5%。</p>\n</div>','2017-04-17',4,25,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(338,'Java堆.栈和常量池 笔记','Java堆.栈和常量池 笔记','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><p><a href=\"http://www.iteye.com/topic/634530\">Java堆.栈和常量池 笔记</a></p>\n</div>','2017-04-23',1,28,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(339,'redis','redis的数据结构 数据结构类型 结构存储的值 结构的读写能力 STRING 可以是字符串、整数、或者浮点数 对整个字符串或者字符串的其中一部分执行操作；对整数和浮点数执行自增或者自减 LIST 一个链表，链表上的每个节点都包含了一个字符串 从链表的两端推入或者弹出元素；根据偏移量对链表进行修剪；根据值查找或者移除元素 SET 包含字符串的无序收集器，并且被包含的每个字符串都是独一无二、各不相同','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h1 id=\"h1-redis-\"><a name=\"redis的数据结构\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>redis的数据结构</h1><table>\n<thead>\n<tr>\n<th>数据结构类型</th>\n<th>结构存储的值</th>\n<th>结构的读写能力</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>STRING</td>\n<td>可以是字符串、整数、或者浮点数</td>\n<td>对整个字符串或者字符串的其中一部分执行操作；对整数和浮点数执行自增或者自减</td>\n</tr>\n<tr>\n<td>LIST</td>\n<td>一个链表，链表上的每个节点都包含了一个字符串</td>\n<td>从链表的两端推入或者弹出元素；根据偏移量对链表进行修剪；根据值查找或者移除元素</td>\n</tr>\n<tr>\n<td>SET</td>\n<td>包含字符串的无序收集器，并且被包含的每个字符串都是独一无二、各不相同的</td>\n<td>添加、获取、移除单个元素；检查一个元素是否存在于集合中；计算交集、并集、差集；从集合里面随机获取元素</td>\n</tr>\n<tr>\n<td>HASH</td>\n<td>包含键值对的无语散列表</td>\n<td>添加、获取、移除单个键值对；获取所有键值对</td>\n</tr>\n<tr>\n<td>ZSET(有序集合)</td>\n<td>字符串成员与浮点数分值之间的有序映射，元素的排列顺序由分值的大小决定</td>\n<td>添加、获取、单个元素；根据分值范围或者成员来获取元素</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"h3--string-\"><a name=\"一、STRING基本操作\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、STRING基本操作</h3><p>（1）SET 设置存储在给定键中的值<br>（2）GET 获取存储在给定键中的值<br>（3）DEL 删除存储在给定键中的值</p>\n<h3 id=\"h3--list-\"><a name=\"二、LIST（列表）基本操作\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、LIST（列表）基本操作</h3><p>（1）RPUSH 将给定值推入列表的右端<br>（2）LRANGE 获取列表在给定范围上的所有值<br>（3）LINDEX 获取列表在给定位置上的单个元素<br>（4）LPOP 从列表的左端弹出一个值，并返回被弹出的值</p>\n<h3 id=\"h3--set-\"><a name=\"三、SET（集合）基本操作\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>　三、SET（集合）基本操作</h3><p>（1）SADD 将给定元素添加到集合<br>（2）SMEMBERS 返回集合包含的所有元素<br>（3）SISMEMBER 检查给定元素是否存在于集合中<br>（4）SREM 如果给定的元素存在于集合中，那么移除这个元素</p>\n<h3 id=\"h3--hash-\"><a name=\"四、HASH（散列）基本操作\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>四、HASH（散列）基本操作</h3><p>（1）HSET 在散列里面关联起给定的键值对<br>（2）HGET 获取指定散列键的值<br>（3）HGETALL 获取散列包含的所有键值对<br>（4）HDEL 如果给定键存在于散列里面，那么移除这个键</p>\n<h3 id=\"h3--zset-\"><a name=\"五、ZSET（有序集合）基本操作\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>五、ZSET（有序集合）基本操作</h3><p>（1）ZADD 将一个带有给定分值的成员添加到有序集合里面<br>（2）ZRANGE 根据元素在有序排列中所处的位置，从有序集合里面获取多个元素<br>（3）ZRANGEBYSCORE 获取有序集合在给定分值范围的所有元素<br>（4）ZREM 如果给定成员存在于有序集合，那么移除这个成员</p>\n</div>','2017-05-04',6,33,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(340,'工厂模式','工厂模式 目录 何为工厂模式 工厂方法与抽象工厂 如何在Java EE中通过@Producers与@Inject注解实现工厂模式 如何创建自定义注解以及通过@Qualifier消除具体实现之间的歧义 工厂模式有两种模式：工厂方法和抽象方法。它们的意图是一样的：提供一个接口，在不指定具体类的情况下创建相关或依赖的一系列对象。 一.何为工厂模式 工厂的目的在于创建对象。创建的逻辑被封装在工厂中，要么提','<h1 id=\"h1-u5DE5u5382u6A21u5F0F\"><a name=\"工厂模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>工厂模式</h1><p>目录</p>\r\n<ul>\r\n<li>何为工厂模式</li><li>工厂方法与抽象工厂</li><li>如何在Java EE中通过<a href=\"https://github.com/Producers\" title=\"&#64;Producers\" class=\"at-link\">@Producers</a>与<a href=\"https://github.com/Inject\" title=\"&#64;Inject\" class=\"at-link\">@Inject</a>注解实现工厂模式</li><li>如何创建自定义注解以及通过<a href=\"https://github.com/Qualifier\" title=\"&#64;Qualifier\" class=\"at-link\">@Qualifier</a>消除具体实现之间的歧义<br>工厂模式有两种模式：工厂方法和抽象方法。它们的意图是一样的：提供一个接口，在不指定具体类的情况下创建相关或依赖的一系列对象。</li></ul>\r\n<h3 id=\"h3--\"><a name=\"一.何为工厂模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一.何为工厂模式</h3><p>工厂的目的在于创建对象。创建的逻辑被封装在工厂中，要么提供一个方法来返回新创建的对象（工厂方法模式），要么将对象的创建委托给子类（抽象工厂模式）。<br>客户端不必考虑接口或类的不同实现，它只需通过工厂（工厂）获取接口实现的一个实例的即可，这样客户端与对象的创建就实现了解耦<br>解耦是应用依赖反转原则的结果，这带来了很多好处，其中最重要的好处就是实现了高层类与底层类之间的解耦。通过解耦，具体类实现的变化不会影响到客户端，这降低了类与类之间的耦合，并提升了灵活性。</p>\r\n<h3 id=\"h3--\"><a name=\"二.工厂方法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二.工厂方法</h3><p>GoF一书是这样描述工程方法模式的：“定义一个用于创建对象的接口，不过让子类决定实例化那个类”<br>工厂极大降低了new关键字的使用次数，并且将初始化过程与不同的具体实现封装起来。将这些需求中心化可以极大减少向系统中添加或删除具体类的影响以及具体的类依赖的影响。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src=\"http://ohlrxdl4p.bkt.clouddn.com/images/QQ截图20170506134421.jpg\" alt=\"\"><br><strong>1.使用普通代码实现工厂方法</strong><br>被具体实现继承的DrinksMachine抽象类</p>\r\n<pre><code class=\"lang-java\">public abstract class DrinksMachine {\r\n    public abstract Drink dispenseDrink();\r\n    public String displayMessage(){\r\n        return &quot;Thank for your custom.&quot;;\r\n    }\r\n}\r\n</code></pre>\r\n<p>DrinksMachine抽象类的CoffeeMachine实现</p>\r\n<pre><code class=\"lang-java\">public class CoffeeMachine extends DrinksMachine {\r\n    public Drink dispenseDrink() {\r\n        return new Coffee();\r\n    }\r\n}\r\n</code></pre>\r\n<p>DrinksMachine抽象类的SoftDrinksMachine实现</p>\r\n<pre><code class=\"lang-java\">public class SoftDrinksMachine extends DrinksMachine {\r\n    public Drink dispenseDrink() {\r\n        return new SoftDrink();\r\n    }\r\n}\r\n</code></pre>\r\n<p>Drink接口</p>\r\n<pre><code class=\"lang-java\">public interface Drink {}\r\n</code></pre>\r\n<p>Drink接口的SoftDrink实现</p>\r\n<pre><code class=\"lang-java\">public class SoftDrink implements Drink {\r\n    SoftDrink() {\r\n        System.out.println(&quot;Soft drink&quot;);\r\n    }\r\n}\r\n</code></pre>\r\n<p>Drink接口的Coffee实现</p>\r\n<pre><code class=\"lang-java\">public class Coffee implements Drink {\r\n    Coffee() {\r\n        System.out.println(&quot;Coffee&quot;);\r\n    }\r\n}\r\n</code></pre>\r\n<p>CoffeeType枚举<br>```java<br>public enum CoffeeType {EXPRESSO, LATTE}</p>\r\n<p>public Drink dispenseDrink(CoffeeType type) {<br>    Drink coffee = null;<br>    switch (type) {<br>        case EXPRESSO: coffee = new Expresso();<br>        case LATTE: coffee = new Latte();<br>    }<br>    return coffee;<br>}<br>```&lt;!--前面不能有空格--&gt;</p>','2017-05-06',1,36,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(341,'代理模式','代理模式(Proxy Pattern) GoF中给出的代理模式的定义为： 代理模式给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。 代理模式的英文叫做Proxy或Surrogate，它是一种对象结构型模式。 代理模式根据其目的和实现可分为很多种类，常用的代理模式包括如下几种： （1）远程代理（Remote Proxy）————为一个位于不同的地址空间的对象提供一个本地的代理对象','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h1 id=\"h1--proxy-pattern-\"><a name=\"代理模式(Proxy Pattern)\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代理模式(Proxy Pattern)</h1><p>GoF中给出的代理模式的定义为：<br>代理模式给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。<br>代理模式的英文叫做Proxy或Surrogate，它是一种对象结构型模式。<br>代理模式根据其目的和实现可分为很多种类，常用的代理模式包括如下几种：<br>（1）远程代理（Remote Proxy）————为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以是在同一台主机中，也可以是在另一台主机中，远程代理又称为大使（Ambassador）<br>（2）虚拟代理（Virtual Proxy）————如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。<br>（3）保护代理（Protect Proxy）————控制一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。<br>（4）缓冲代理（Cache Proxy）————为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。<br>（5）只能引用代理（Smart Reference Proxy）————当一个对象被引用时，提供一些额外的操作，例如将对象被调用的次数记录下来。<br><img src=\"http://ohlrxdl4p.bkt.clouddn.com/images/QQ截图20170507103646.jpg\" alt=\"\"></p>\n<p>代码实现：<br>1.抽象主题类——BuyTicket.java</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code class=\"lang-java\"><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">interface</span><span class=\"pln\"> </span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> showticket</span><span class=\"pun\">();</span></code></li><li class=\"L2\"><code class=\"lang-java\"><span class=\"pun\">}</span></code></li></ol></pre>\n<p>2.具体主题类——Train.java</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code class=\"lang-java\"><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Train</span><span class=\"pln\"> </span><span class=\"kwd\">implements</span><span class=\"pln\"> </span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"lit\">@Override</span></code></li><li class=\"L2\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> showticket</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L3\"><code class=\"lang-java\"><span class=\"pln\">        </span><span class=\"typ\">System</span><span class=\"pun\">.</span><span class=\"pln\">out</span><span class=\"pun\">.</span><span class=\"pln\">println</span><span class=\"pun\">(</span><span class=\"str\">\"one ticket\"</span><span class=\"pun\">);</span></code></li><li class=\"L4\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L5\"><code class=\"lang-java\"><span class=\"pun\">}</span></code></li></ol></pre>\n<p>3.代理角色类——TicketCenter.java</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code class=\"lang-java\"><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">TicketCenter</span><span class=\"pln\"> </span><span class=\"kwd\">implements</span><span class=\"pln\"> </span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> ticket</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code class=\"lang-java\"></code></li><li class=\"L3\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"typ\">TicketCenter</span><span class=\"pun\">(</span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> ticket</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code class=\"lang-java\"><span class=\"pln\">        </span><span class=\"kwd\">this</span><span class=\"pun\">.</span><span class=\"pln\">ticket </span><span class=\"pun\">=</span><span class=\"pln\"> ticket</span><span class=\"pun\">;</span></code></li><li class=\"L5\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code class=\"lang-java\"></code></li><li class=\"L7\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"lit\">@Override</span></code></li><li class=\"L8\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> showticket</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L9\"><code class=\"lang-java\"><span class=\"pln\">        ticket</span><span class=\"pun\">.</span><span class=\"pln\">showticket</span><span class=\"pun\">();</span></code></li><li class=\"L0\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code class=\"lang-java\"></code></li><li class=\"L2\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> buy</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L3\"><code class=\"lang-java\"><span class=\"pln\">        </span><span class=\"typ\">System</span><span class=\"pun\">.</span><span class=\"pln\">out</span><span class=\"pun\">.</span><span class=\"pln\">println</span><span class=\"pun\">(</span><span class=\"str\">\"by proxy\"</span><span class=\"pun\">);</span></code></li><li class=\"L4\"><code class=\"lang-java\"><span class=\"pln\">        showticket</span><span class=\"pun\">();</span></code></li><li class=\"L5\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code class=\"lang-java\"><span class=\"pun\">}</span></code></li></ol></pre>\n<p>4.客户端测试类</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code class=\"lang-java\"><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">ProxyPattern</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> main</span><span class=\"pun\">(</span><span class=\"typ\">String</span><span class=\"pln\"> args</span><span class=\"pun\">[])</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L2\"><code class=\"lang-java\"><span class=\"pln\">        </span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> x </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Train</span><span class=\"pun\">();</span></code></li><li class=\"L3\"><code class=\"lang-java\"><span class=\"pln\">        </span><span class=\"typ\">TicketCenter</span><span class=\"pln\"> y </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">TicketCenter</span><span class=\"pun\">(</span><span class=\"pln\">x</span><span class=\"pun\">);</span></code></li><li class=\"L4\"><code class=\"lang-java\"><span class=\"pln\">        y</span><span class=\"pun\">.</span><span class=\"pln\">buy</span><span class=\"pun\">();</span></code></li><li class=\"L5\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code class=\"lang-java\"><span class=\"pun\">}</span></code></li></ol></pre>\n<p>运行结果：</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code class=\"lang-html\"><span class=\"pln\">by proxy</span></code></li><li class=\"L1\"><code class=\"lang-html\"><span class=\"pln\">one ticket</span></code></li></ol></pre>\n</div>','2017-05-07',1,41,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(342,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,25,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(343,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,18,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(344,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,17,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(345,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,18,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(346,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,19,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(347,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,19,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(348,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,19,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(349,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,19,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(350,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,18,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(351,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,18,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(352,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,20,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(353,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,21,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(354,'BSbsbsbs','heloo 哦i已被肉','<h1 id=\"h1-heloo-i-\"><a name=\"heloo 哦i已被肉\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>heloo 哦i已被肉</h1>','2017-01-23',3,25,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(355,'2017-02-28学习笔记','','<p><img src=\"http://ohlrxdl4p.bkt.clouddn.com/images/826546_1482322555369_C5DABB18734059E89A45A0E9170722B0.png\" alt=\"\"></p>','2017-02-28',1,28,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(356,'2017-03-01学习笔记','知识点 1.java中只有值传递，没有引用传递http://guhanjie.iteye.com/blog/1683637 2.final关键字 final修饰变量，则等同于常量. final修饰方法中的参数，称为最终参数. final修饰类，则类不能被继承. final修饰方法，则方法不能被','<h1 id=\"h1-u77E5u8BC6u70B9\"><a name=\"知识点\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>知识点</h1><h4 id=\"h4-1-java-http-guhanjie-iteye-com-blog-1683637\"><a name=\"1.java中只有值传递，没有引用传递  http://guhanjie.iteye.com/blog/1683637\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.java中只有值传递，没有引用传递<a href=\"http://guhanjie.iteye.com/blog/1683637\">http://guhanjie.iteye.com/blog/1683637</a></h4><h4 id=\"h4-2-final-\"><a name=\"2.final关键字\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.final关键字</h4><ul>\r\n<li>final修饰变量，则等同于常量.</li><li>final修饰方法中的参数，称为最终参数.</li><li>final修饰类，则类不能被继承.</li><li>final修饰方法，则方法不能被重写.</li></ul>\r\n<h4 id=\"h4-3-integer-img-src-https-uploadfiles-nowcoder-com-images-20160717-6316247_1468761643205_9f7b85ab04292cf73778d98998a20ed1-alt-\"><a name=\"3.Integer<img src=\"https://uploadfiles.nowcoder.com/images/20160717/6316247_1468761643205_9F7B85AB04292CF73778D98998A20ED1\" alt=\"图片\">\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.Integer<img src=\"https://uploadfiles.nowcoder.com/images/20160717/6316247_1468761643205_9F7B85AB04292CF73778D98998A20ED1\" alt=\"图片\"></h4><h4 id=\"h4-4-java-\"><a name=\"4.java内存模型   点击原文\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.java内存模型 <a href=\"http://blog.csdn.net/ns_code/article/details/17565503\">点击原文</a></h4><p><img src=\"https://uploadfiles.nowcoder.com/images/20161223/415611_1482452184396_6FB53C51539B47559CF0D122A832CF63\" alt=\"\"></p>\r\n<h4 id=\"h4-5-java-reference\"><a name=\"5.java中是没有指针的，有reference\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.java中是没有指针的，有reference</h4><p>第一：指针变量是在栈内存中，它也是有值的，这个值存储的就是地址单元，这个地址就是来自于赋值操作。<br>第二：指针变量有类型，这个类型（如Person）的含义是指针指向的变量在栈内存（不是很确定）中的范围（大小），我理解为是占用的堆内存空间。<br>第三：声明一个对象时，是对“指针变量”的定义。<br>第四：用new关键字在堆内存创建了对象，在赋值时，是把这个对象的首地址传给了这个“指针变量”（即引用型变量）。</p>\r\n<h4 id=\"h4-6-string-\"><a name=\"6.String生成常量\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6.String生成常量</h4><pre><code class=\"lang-java\">String s1=&quot;abc&quot;+&quot;def&quot;;//生成的是一个常量，放在堆内存中\r\nString s2=new String（s1);//s2是一个变量\r\nif(s1.equals(s2))//比较的是字符串的内容\r\n    System.out.println(&quot;.equals succeeded&quot;);//输出\r\nif(s1==s2)//比较的是内存地址，但s1是常量，所以不相等\r\n    System.out.println(&quot;==succeeded&quot;);\r\n</code></pre>\r\n<h4 id=\"h4-7-jsp-\"><a name=\"7.jsp内置对象和属性\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>7.jsp内置对象和属性</h4><p>（１）request对象<br>客户端的请求信息被封装在request对象中，通过它才能了解到客户的需求，然后做出响应。它是HttpServletRequest类的实例。<br>（２）response对象<br>response对象包含了响应客户请求的有关信息，但在JSP中很少直接用到它。它是HttpServletResponse类的实例。<br>（３）session对象<br>session对象指的是客户端与服务器的一次会话，从客户连到服务器的一个WebApplication开始，直到客户端与服务器断开连接为止。它是HttpSession类的实例.<br>（４）out对象<br>out对象是JspWriter类的实例,是向客户端输出内容常用的对象<br>（５）page对象<br>page对象就是指向当前JSP页面本身，有点象类中的this指针，它是java.lang.Object类的实例<br>（６）application对象<br>application对象实现了用户间数据的共享，可存放全局变量。它开始于服务器的启动，直到服务器的关闭，在此期间，此对象将一直存在；这样在用户的前后连接或不同用户之间的连接中，可以对此对象的同一属性进行操作；在任何地方对此对象属性的操作，都将影响到其他用户对此的访问。服务器的启动和关闭决定了application对象的生命。它是ServletContext类的实例。<br>（７）exception对象<br>exception对象是一个例外对象，当一个页面在运行过程中发生了例外，就产生这个对象。如果一个JSP页面要应用此对象，就必须把isErrorPage设为true，否则无法编译。他实际上是java.lang.Throwable的对象<br>（８）pageContext对象<br>pageContext对象提供了对JSP页面内所有的对象及名字空间的访问，也就是说他可以访问到本页所在的SESSION，也可以取本页面所在的application的某一属性值，他相当于页面中所有功能的集大成者，它的本 类名也叫pageContext。<br>（９）config对象<br>config对象是在一个Servlet初始化时，JSP引擎向它传递信息用的，此信息包括Servlet初始化时所要用到的参数（通过属性名和属性值构成）以及服务器的有关信息（通过传递一个ServletContext对象）</p>','2017-03-01',1,32,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(357,'2017-03-02学习笔记','知识点 一、static public class Spike\r\n{\r\n    public static void main(String[] args)\r\n    {\r\n        Counter a = new Counter();\r\n        System.out.println(a.increment());\r\n        System.out.println(a.anot','<h1 id=\"h1-u77E5u8BC6u70B9\"><a name=\"知识点\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>知识点</h1><h4 id=\"h4--static\"><a name=\"一、static\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、static</h4><pre><code class=\"lang-java\">public class Spike\r\n{\r\n    public static void main(String[] args)\r\n    {\r\n        Counter a = new Counter();\r\n        System.out.println(a.increment());\r\n        System.out.println(a.anotherIncrement());\r\n        Counter b = new Counter();\r\n        System.out.println(b.increment());\r\n    }\r\n}\r\nclass Counter\r\n{\r\n    private static int count = 0;\r\n    public int increment()\r\n    {\r\n        return count++;\r\n    }\r\n    public int anotherIncrement()\r\n    {\r\n        return ++count;\r\n    }\r\n}\r\n</code></pre>\r\n<p>count是静态变量，为所有对象所共享，因此不管a.increment()还是b.increment()都会使count持续增加。<br>increment()方法返回当前count值，然后count增加1<br>antoherIncrement()方法让count增加1，然后返回count值<br>第一次a.increment()返回值为0，此时count值为1<br>第二次a.anotherIncrement()先让count+1再返回，返回值为2<br>第三次b.increment()先返回count当前值2，然后count+1</p>\r\n<h4 id=\"h4--aop-\"><a name=\"二、AOP面向切面\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、AOP面向切面</h4><p>AOP的概念是Aspected Oriented Programming 面向方面编程。<br>  好处：AOP将程序分解成各个方面或者说关注点。这使得可以模块化，相当横向上分切了。它可以解决OOP和过程化方法不能够很好解决的横切（crosscut）问题，如：事务、安全、日志等横切关注。<br>  实现AOP有几种方式:<br>  1.Spring 1.2版本中通过ProxyFactoryBean来实现aop,即通过动态代理来实现的,Aspect必须继承MethodBeforeAdvice,MethodAfterAdvice等<br>  2.Spring 2.0 AOP需要改的是FBI 这个类，而且它也不需要再实现某些接口<br>  3.三使用标注（<a href=\"https://github.com/AspectJ\" title=\"&#64;AspectJ\" class=\"at-link\">@AspectJ</a>）实现AOP<br>    AOP 和 OOP的区别：</p>\r\n<pre><code>```html\r\n 1. 面向方面编程 AOP 偏重业务处理过程的某个步骤或阶段，强调降低模块之间的耦合度，使代码拥有更好的移植性。  \r\n 2. 面向对象编程 (oop) 则是对业务分析中抽取的实体进行方法和属性的封装。\r\n ```\r\n</code></pre><p>也可以说 AOP 是面向业务中的动词领域， OOP 面向名词领域。<br>AOP 的一个很重要的特点是源代码无关性，也就是说如果我们的系统中引用了 AOP 组件，即使我们把该组件去掉，系统代码也应该能够编译通过。要实现这一点，可以使用动态 proxy 模式。</p>\r\n<h4 id=\"h4--jdbc-\"><a name=\"三、jdbc桥接模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、jdbc桥接模式</h4><p>桥接模式：<br>定义 ：将抽象部分与它的实现部分分离，使它们都可以独立地变化。<br>意图 ：将抽象与实现解耦。<br>桥接模式所涉及的角色</p>\r\n<ol>\r\n<li>Abstraction ：定义抽象接口，拥有一个Implementor类型的对象引用</li><li>RefinedAbstraction ：扩展Abstraction中的接口定义</li><li>Implementor ：是具体实现的接口，Implementor和RefinedAbstraction接口并不一定完全一致，实际上这两个接口可以完全不一样Implementor提供具体操作方法，而Abstraction提供更高层次的调用</li><li>ConcreteImplementor ：实现Implementor接口，给出具体实现<br>Jdk中的桥接模式：JDBC<br>JDBC连接 数据库 的时候，在各个数据库之间进行切换，基本不需要动太多的代码，甚至丝毫不动，原因就是JDBC提供了统一接口，每个数据库提供各自的实现，用一个叫做数据库驱动的程序来桥接就行了<h4 id=\"h4--\"><a name=\"四、抽象类\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>四、抽象类</h4>抽象类和普通类有三点区别：<br>1）抽象方法必须为public和protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public。<br>2）抽象类不能用来创建对象，但是它可以有构造方法，用来帮助子类实例化。<br>3）如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为abstract类。<h4 id=\"h4--\"><a name=\"五、接口\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>五、接口</h4>接口的主要特点<br>1）接口中的成员变量默认都是public、static、final类型的，必须被显示初始化。<br>2）接口中的方法默认都是public、abstract类型的。<br>3）接口中只能包含public、static、final类型的成员变量和public、abstract类型的成员方法。<br>4）接口没有构造方法，不能被实例化。<br>5）一个接口不能实现另一个接口，但它可以继承多个其他接口。<br>6）接口必须通过类来实现它的抽象方法。<br>7）与子类继承抽象父类相似，当类实现了某个接口时，它必须实现接口中所有的抽象方法，否则这个类必须被定义为抽象类。<br>8）一个类只能继承一个直接的父类，但能实现多个接口。<h4 id=\"h4--\"><a name=\"六、抽象类和接口的区别\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>六、抽象类和接口的区别</h4>1）抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract方法；<br>2）抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；<br>3）接口中不能含有静态代码块以及静态方法，而抽象类尅有静态代码块和静态方法；<br>4）一个类只能继承一个抽象类，而一个类却可以实现多个接口。<br>5）抽象类中的方法子类必须全部实现，不然子类也是抽象类，而接口中的抽象方法子类必须全部实现，是可选择实现的。<br>6）抽象类是一种模板设计模式，而接口时一种行为规范。</li></ol>','2017-03-02',1,32,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(358,'2017-03-03学习笔记','一、String StringBuffer.toString()源码： @Override\r\npublic synchronized String toString() {\r\n    if (toStringCache == null) {\r\n        toStringCache = Arrays.copyOfRange(value, 0, count);\r\n    }\r\n    retur','<h4 id=\"h4--string\"><a name=\"一、String\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、String</h4><p>StringBuffer.toString()源码：</p>\r\n<pre><code class=\"lang-java\">@Override\r\npublic synchronized String toString() {\r\n    if (toStringCache == null) {\r\n        toStringCache = Arrays.copyOfRange(value, 0, count);\r\n    }\r\n    return new String(toStringCache, true);\r\n}\r\n</code></pre>\r\n<p>Arrays.copyOfRange用的是System.arraycopy</p>\r\n<pre><code class=\"lang-java\">public static char[] copyOfRange(char[] original, int from, int to) {\r\n        int newLength = to - from;\r\n        if (newLength &lt; 0)\r\n            throw new IllegalArgumentException(from + &quot; &gt; &quot; + to);\r\n        char[] copy = new char[newLength];\r\n        System.arraycopy(original, from, copy, 0,\r\n                         Math.min(original.length - from, newLength));\r\n        return copy;\r\n    }\r\n</code></pre>\r\n<p>1.String是值传入，不是引用传入。<br>2.String对String  类型进行改变的时候其实都等同于生成了一个新的  String  对象，然后将指针指向新的  String  对象，而不是StringBuffer；StringBuffer每次结果都会对  StringBuffer  对象本身进行操作，而不是生成新的对象，再改变对象引用。<br>3.效率比较String&lt;StringBuffer&lt;StringBuilder，但是在 String S1 = “This is only a” + “ simple” + “ test”时，String效率最高。</p>\r\n<h4 id=\"h4--jvm-\"><a name=\"二、jvm知识图谱\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、jvm知识图谱</h4><p><a href=\"https://zhuanlan.zhihu.com/p/25511795\">引用自知乎</a><br><img src=\"https://pic2.zhimg.com/v2-701563ac1fe745fc8e1234c96e82ac99_r.jpg\" alt=\"\"></p>\r\n<h4 id=\"h4--treemap-linkhashmap\"><a name=\"三、Treemap、LinkHashMap\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、Treemap、LinkHashMap</h4><p>1.TreeMap取出来的是排序后的键值对。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。<br>2.LinkedHashMap 是HashMap的一个子类，如果需要输出的顺序和输入的相同,那么用LinkedHashMap可以实现,它还可以按读取顺序来排列。</p>\r\n<h4 id=\"h4--sql-\"><a name=\"四、sql模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>四、sql模式</h4><p>MySQL数据库中，变量分为 系统变量（以”@@”开头）和用户自定义变量。系统变量分为全局系统变量(global)和会话系统变量(session)。<br>@<a href=\"https://github.com/global\" title=\"&#64;global\" class=\"at-link\">@global</a>     仅用于访问全局系统变量的值；<br>@<a href=\"https://github.com/session\" title=\"&#64;session\" class=\"at-link\">@session</a>  仅用于访问会话系统变量的值；<br>@@              先访问会话系统变量的值，若不存在则去访问全局系统变量的值；<br>sql_mode 为系统变量，既是全局系统变量，又是会话系统变量。</p>\r\n<h4 id=\"h4--\"><a name=\"五、代码的执行顺序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>五、代码的执行顺序</h4><p>父类Ｂ静态代码块-&gt;子类Ａ静态代码块-&gt;父类Ｂ非静态代码块-&gt;父类Ｂ构造函数-&gt;子类Ａ非静态代码块-&gt;子类Ａ构造函数<br><img src=\"http://ohlrxdl4p.bkt.clouddn.com/images/QQ截图20170303165728.jpg\" alt=\"\"></p>','2017-03-03',1,33,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(359,'ifhifhajfe','hello','<h1 id=\"h1-hello\"><a name=\"hello\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>hello</h1>','2017-03-05',1,31,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(360,'2017-03-05学习笔记','java的堆，栈，静态代码区（常量区） 详解','<p><a href=\"http://blog.csdn.net/u012031380/article/details/54981472\"> java的堆，栈，静态代码区（常量区） 详解</a></p>','2017-03-05',1,31,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(361,'java归并排序','package datastruct;\r\n\r\n/**\r\n * Created by Zephery on 2017/3/3.\r\n */\r\npublic class Solution {\r\n    public static void printArray(int[] arr, int i, int j) {\r\n        System.out.print(\"[\");\r\n        for','<pre><code class=\"lang-java\">package datastruct;\r\n\r\n/**\r\n * Created by Zephery on 2017/3/3.\r\n */\r\npublic class Solution {\r\n    public static void printArray(int[] arr, int i, int j) {\r\n        System.out.print(&quot;[&quot;);\r\n        for (int k = i; k &lt; j; k++) {\r\n            System.out.print(arr[k] + &quot;,&quot;);\r\n        }\r\n        System.out.print(arr[j] + &quot;]&quot;);\r\n    }\r\n\r\n    private static void mergesort(int[] arr, int i, int j) {\r\n        int mid = 0;\r\n        if (i &lt; j) {\r\n            mid = (i + j) / 2;\r\n            mergesort(arr, i, mid);\r\n            mergesort(arr, mid + 1, j);\r\n            merge(arr, i, mid, j);\r\n        }\r\n    }\r\n\r\n    private static void merge(int[] arr, int i, int mid, int j) {\r\n        System.out.print(&quot;Left:&quot;);\r\n        printArray(arr, i, mid);\r\n        System.out.println(&quot;Right:&quot;);\r\n        printArray(arr, mid + 1, j);\r\n        System.out.println();\r\n        int temp[] = new int[arr.length];\r\n        int l = i;\r\n        int r = j;\r\n        int m = mid + 1;\r\n        int k = l;\r\n        while (l &lt;= mid &amp;&amp; m &lt;= r) {\r\n            if (arr[l] &lt;= arr[m]) {\r\n                temp[k++] = arr[l++];\r\n            } else {\r\n                temp[k++] = arr[m++];\r\n            }\r\n        }\r\n        while (l &lt;= mid) {\r\n            temp[k++] = arr[l++];\r\n        }\r\n        while (m &lt;= r) {\r\n            temp[k++] = arr[m++];\r\n        }\r\n        for (int i1 = i; i1 &lt;= j; i1++) {\r\n            arr[i1] = temp[i1];\r\n        }\r\n        System.out.print(&quot;After Merge:&quot;);\r\n        printArray(arr, i, j);\r\n        System.out.println();\r\n    }\r\n\r\n    public static void main(String args[]) {\r\n        int[] arr = {9, 4, 8, 3, 1, 2, 5};\r\n        System.out.print(&quot;Initial Array:&quot;);\r\n        printArray(arr, 0, arr.length - 1);\r\n        System.out.println();\r\n        mergesort(arr, 0, arr.length - 1);\r\n    }\r\n}\r\n</code></pre>\r\n<pre><code class=\"lang-js\">Initial Array:[9,4,8,3,1,2,5]\r\nLeft:[9]Right:\r\n[4]\r\nAfter Merge:[4,9]\r\nLeft:[8]Right:\r\n[3]\r\nAfter Merge:[3,8]\r\nLeft:[4,9]Right:\r\n[3,8]\r\nAfter Merge:[3,4,8,9]\r\nLeft:[1]Right:\r\n[2]\r\nAfter Merge:[1,2]\r\nLeft:[1,2]Right:\r\n[5]\r\nAfter Merge:[1,2,5]\r\nLeft:[3,4,8,9]Right:\r\n[1,2,5]\r\nAfter Merge:[1,2,3,4,5,8,9]\r\n</code></pre>','2017-03-06',1,32,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(362,'2017-03-10学习笔记','1.Integer和int，装箱拆箱 1、基本型和基本型封装型进行“==”运算符的比较，基本型封装型将会自动拆箱变为基本型后再进行比较，因此Integer(0)会自动拆箱为int类型再进行比较，显然返回true； 2、两个Integer类型进行“==”比较，如果其值在-128至127，那么返回true，否则返回false, 这跟Integer.valueOf()的缓冲对象有关，这里不进行赘述。 3','<h1 id=\"h1-1-integer-int-\"><a name=\"1.Integer和int，装箱拆箱\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.Integer和int，装箱拆箱</h1><p>1、基本型和基本型封装型进行“==”运算符的比较，基本型封装型将会自动拆箱变为基本型后再进行比较，因此Integer(0)会自动拆箱为int类型再进行比较，显然返回true；<br>2、两个Integer类型进行“==”比较，如果其值在-128至127，那么返回true，否则返回false, 这跟Integer.valueOf()的缓冲对象有关，这里不进行赘述。<br>3、两个基本型的封装型进行equals()比较，首先equals()会比较类型，如果类型相同，则继续比较值，如果值也相同，返回true<br>4、基本型封装类型调用equals(),但是参数是基本类型，这时候，先会进行自动装箱，基本型转换为其封装类型，再进行3中的比较。</p>\r\n<pre><code class=\"lang-java\">int a=257;\r\nInteger b=257;\r\nInteger c=257;\r\nInteger b2=57;\r\nInteger c2=57;\r\nSystem.out.println(a==b);\r\n//System.out.println(a.equals(b));  编译出错，基本型不能调用equals()\r\nSystem.out.println(b.equals(257.0));\r\nSystem.out.println(b==c);\r\nSystem.out.println(b2==c2);\r\n</code></pre>\r\n<p>因此上面的代码的结果因此为 true, false, false, true</p>\r\n<h1 id=\"h1-2-\"><a name=\"2.线程调度\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.线程调度</h1><p>分为协同式调度和抢占式调度，Java使用的是抢占式调度，也就是每个线程将由操作系统来分配执行时间，线程的切换不由线程本身来决定（协同式调度）。这就是平台独立的原因。</p>\r\n<h1 id=\"h1-3-\"><a name=\"3.重载，重写\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.重载，重写</h1><p>重写：<br>两同，两小，一大<br>两同：方法名，方法参数列表相同。<br>两小：抛出的异常类型要小于等于父类，返回值类型要小于等于父类<br>一大：访问权限大于等于父类。<br>重载：<br>在同一个类中，方法名和方法参数列表不同，其他的（访问权限、返回值）随意。</p>\r\n<h1 id=\"h1-4-jvm-\"><a name=\"4.  JVM面试题\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.<a href=\"http://blog.csdn.net/hsk256/article/details/49104955\">JVM面试题</a></h1>','2017-03-10',1,29,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(363,'2017-03-12学习笔记','1.继承的加载顺序 执行顺序大体上可以说是先父类后子类，父类static域 ==》子类static域 ==》父类数据成员域 ==》父类构造器 ==》子类数据成员域 ==》子类构造器 2.优化Hibernate所鼓励的7大措施： 1.尽量使用many-to-one，避免使用单项one-to-many 2.灵活使用单向one-to-many 3.不用一对一，使用多对一代替一对一 4.配置对象缓存，不使','<h4 id=\"h4-1-\"><a name=\"1.  继承的加载顺序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.<a href=\"http://www.cnblogs.com/SirSmith/p/5536288.html\">继承的加载顺序</a></h4><p><img src=\"http://images2015.cnblogs.com/blog/452847/201605/452847-20160527221410288-2119099273.png\" alt=\"\"></p>\r\n<p>执行顺序大体上可以说是先父类后子类，父类static域 ==》子类static域 ==》父类数据成员域 ==》父类构造器 ==》子类数据成员域 ==》子类构造器</p>\r\n<h4 id=\"h4-2-hibernate-7-\"><a name=\"2.优化Hibernate所鼓励的7大措施：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.优化Hibernate所鼓励的7大措施：</h4><p>1.尽量使用many-to-one，避免使用单项one-to-many<br>2.灵活使用单向one-to-many<br>3.不用一对一，使用多对一代替一对一<br>4.配置对象缓存，不使用集合缓存<br>5.一对多使用Bag 多对一使用Set<br>6.继承使用显示多态 HQL:from object polymorphism=”exlicit” 避免查处所有对象<br>7.消除大表，使用二级缓存</p>\r\n<h4 id=\"h4-3-java-\"><a name=\"3.java中的数据类型分类：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.java中的数据类型分类：</h4><p>基本数据类型（或叫做原生类、内置类型）8种：<br>    整数：byte，short，int，long（默认是int类型）<br>    浮点类型： float，double（默认是double类型）<br>    字符类型：char<br>    布尔类型：boolean<br>引用数据类型3种：数组，类，接口</p>\r\n<h4 id=\"h4-4-\"><a name=\"4.触发器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.触发器</h4><p>drop trigger 删除触发器<br>Drop用于删除数据表或数据库，或删除数据表字段。<br>remove：删除数据库文件<br>Truncate：删除数据表中的数据（仅数据表中的数据，不删除表）。</p>','2017-03-12',1,26,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(364,'2017-03-14学习笔记','1.Servlet的生命周期分为5个阶段：加载、创建、初始化、处理客户请求、卸载。 (1)加载：容器通过类加载器使用servlet类对应的文件加载servlet (2)创建：通过调用servlet构造函数创建一个servlet对象 (3)初始化：调用init方法初始化 (4)处理客户请求：每当有一个客户请求，容器会创建一个线程来处理客户请求 (5)卸载：调用destroy方法让servlet自己释','<h4 id=\"h4-1-servlet-5-\"><a name=\"1.Servlet的生命周期分为5个阶段：加载、创建、初始化、处理客户请求、卸载。\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.Servlet的生命周期分为5个阶段：加载、创建、初始化、处理客户请求、卸载。</h4><p>(1)加载：容器通过类加载器使用servlet类对应的文件加载servlet<br>(2)创建：通过调用servlet构造函数创建一个servlet对象<br>(3)初始化：调用init方法初始化<br>(4)处理客户请求：每当有一个客户请求，容器会创建一个线程来处理客户请求<br>(5)卸载：调用destroy方法让servlet自己释放其占用的资源</p>\r\n<h4 id=\"h4-2-jsp\"><a name=\"2.JSP\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.JSP</h4><p><img src=\"http://uploadfiles.nowcoder.com/images/20160308/595432_1457414324036_C3D4EB7F2D61708D0C0BE2921A45B74D\" alt=\"\"></p>','2017-03-14',1,21,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(365,'2017-03-17学习笔记','1.GC线程是否和守护线程 2.java堆排序','<h4 id=\"h4-1-gc-\"><a name=\"1.GC线程是否和守护线程\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.GC线程是否和守护线程</h4><h4 id=\"h4-2-java-\"><a name=\"2.java堆排序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.java堆排序</h4>','2017-03-17',1,18,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(366,'春招~好失落啊','自己的情况：广东人，大学跑到天津一所二本学校，网络工程专业，大一大二学ccna、ccnp，发现没有创造性，按着别人的死规定敲命令好无聊，大三彻底转向编程，c++看着不爽，调研一番后选择java，自学java和java web，对jsp、servlet略过，直接上手框架（Struts，hibernate，spring），看书，找视频，敲项目，非专业课（操作系统，数据库等）不听，捣鼓一番觉得还行，继续','<p>自己的情况：广东人，大学跑到天津一所二本学校，网络工程专业，大一大二学ccna、ccnp，发现没有创造性，按着别人的死规定敲命令好无聊，大三彻底转向编程，c++看着不爽，调研一番后选择java，自学java和java web，对jsp、servlet略过，直接上手框架（Struts，hibernate，spring），看书，找视频，敲项目，非专业课（操作系统，数据库等）不听，捣鼓一番觉得还行，继续学习spring mvc，mybatis，开始了解hadoop、spark，同时搭了自己的网站，跟了软件工程的同学比了比，还能算上前列吧，当然，基础和算法跟前列的人还没得比~~~</p>\r\n<p>去年秋招，腾讯、阿里等笔试全挂，京东的没怎么做却过了，不敢去面试（真心没怎么做题），最后去了北京一家创业公司实习了三个月多，感觉真心好，12月几乎整整一个月雾霾，受不了，还是回广东吧。在家过了春节，2月10号跟同学一起来深圳，就这样，开始了春招之旅~~~~</p>\r\n<p>第一家，面试的问的差不多全答对，手写了几个sql也对了，不过居然没有问hashmap，给的工资6000到9000，想了想，还是不去的好，太郊区，后来一查，是个培训兼外包的企业，还好没去。。。。</p>\r\n<p>第二家，某ERP公司，额，笔试，全是sql，做了，感觉还可以，面试直接说我们公司不用java，用的一个小众语言，薪资应届生只有3500，直接走人。。。。</p>\r\n<p>第三家，找工作，对广东真是彻底失望了，投的简历除了培训机构理你，其他的都不理人的，无奈之下投了北京的一家创业公司（A轮），薪资1万，电话面试，过了。。。。。后来想想，还是不去北京了，虽然工资高，但是没有朋友，过得像个死人一样。</p>\r\n<p>第四家，深圳一家创业公司，做东南亚社交软件的，可惜薪资没谈成，4K-6K，这可是深圳啊。。。。</p>\r\n<p>第五家，广州凡科，那天一早就从深圳跑过去，没吃饭，下午到就做笔试题，头晕，手抖，然后一面就是跟你讲笔试题，讲了两道，就叫我走了。。。仅仅半个小时，广深来回6个小时。。。</p>\r\n<p>第六家，广州某搞运维的公司，笔试差不多答对，面试问的问题也答对，但是没给offer。。。不理解</p>\r\n<p>第七家，然后晚上跑去了广工的久邦数码宣讲，试卷发到我这的时候，HR说我这方向的试卷没带够。。。。无奈向他要了大数据的题，全是数据库的题，过几天后得知居然过了，然后一面，问的问题没啥印象，除了left join的原理没答对。。。今天得知挂了。。。。</p>\r\n<p><img src=\"http://images2015.cnblogs.com/blog/755525/201703/755525-20170318000537838-305991370.png\" alt=\"\"></p>\r\n<p>第八家，极天信息（A轮），笔试的题目没看懂它问的啥，一面没啥印象了，然后是经理面，说广州没那么高的工资（7000），等消息，估计也没谈成。。。。</p>\r\n<p>第九家，中国移动，最气的了，一面就是HR面，问了两个问题，为什么不在北京留着，你觉得相比其他人你有什么优势。我只能说我真不会说话更不知怎么回答，就强调勤奋，然后直接被HR叫走人了，3分钟=w=</p>\r\n<p>第十家，珍爱网，找别人内推的，三个问题没答上来，就不跟你们说了，亲爱的竞争对手们=w=，谈了四十分钟吧，出来后感觉很不好，估计也是挂了。。。</p>\r\n<p>今天晚上，收到了久邦数码的拒绝信，瞬间觉得好无奈好迷茫，有时候就那么一个简简单单的问题，答不好就直接拒绝的，改怎么心平气和的面对下一个面试。有时候真不理解公司是怎么招人的，是不是真的“把部分简历扔进垃圾桶，不招那些运气不好的人”？也只能这么安慰自己。可是，事实呢？</p>\r\n<p><img src=\"http://images2015.cnblogs.com/blog/755525/201703/755525-20170318001336463-1583022291.jpg\" alt=\"\"></p>\r\n<p>这些天，有时间都是往深圳图书馆跑，看书，刷牛客网，补算法，看源码，做了这么多，该怎么告诉自己不要放弃。。。。。开始有点想念北京的雾霾</p>','2017-03-18',5,19,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(367,'数据库','1.SQL执行的顺序 2.NULL “空值” 和”NULL”的概念： 1：空值(‘’)是不占用空间的,判断空字符用 = ‘’ 或者 <> ‘’ 来进行处理; 2: NULL值是未知的，且占用空间，不走索引;判断 NULL 用 IS NULL 或者 is not null , SQL 语句函数中可以使用 ifnull ()函数来进行处理. 注：在进行 count ()统计某列的记录数的时候，如果采用','<h4 id=\"h4-1-sql-\"><a name=\"1.SQL执行的顺序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.SQL执行的顺序</h4><p><img src=\"http://uploadfiles.nowcoder.com/images/20150828/415611_1440751995009_3B3E1329A400F0022B20C4F32AEFC9EF\" alt=\"\"></p>\r\n<h4 id=\"h4-2-null\"><a name=\"2.NULL\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.NULL</h4><p>“空值” 和”NULL”的概念：<br>  1：空值(‘’)是不占用空间的,判断空字符用 = ‘’ 或者 &lt;&gt; ‘’ 来进行处理;<br> 2: NULL值是未知的，且占用空间，不走索引;判断 NULL 用 IS NULL 或者 is not null , SQL 语句函数中可以使用 ifnull ()函数来进行处理.<br>注：在进行 count ()统计某列的记录数的时候，如果采用的 NULL 值，会别系统自动忽略掉，但是空值是统计到其中</p>\r\n<h4 id=\"h4-3-\"><a name=\"3.\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.</h4><p>在MySQL数据库中，NULL对于一些特殊类型的列来说，其代表了一种特殊的含义，而不仅仅是一个空值。<br>IS NULL: 此运算符返回true，当列的值是NULL。<br>IS NOT NULL: 运算符返回true，当列的值不是NULL。<br>&lt;=&gt; 操作符比较值（不同于=运算符）为ture，即使两个NULL值<br>涉及NULL条件是特殊的。不能使用 =NULL 或 !=NULL 寻找NULL值的列</p>\r\n<h4 id=\"h4-4-nf\"><a name=\"4.NF\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.NF</h4><p>第一范式（   1NF   ）：   字段具有   原子性   ,   不可再分   。所有关系型数据库系统都满足第一范式）数据库表中的字段都是单一属性的，不可再分。例如，姓名字段，其中的姓和名必须作为一个整体，无法区分哪部分是姓，哪部分是名，如果要区分出姓和名，必须设计成两个独立的字段。<br>第二范式（   2NF   ）：   第二范式（   2NF   ）是在   第一范式（   1NF   ）的基础上   建立起来的，即满足第二范式（   2NF   ）必须先满足第一范式（   1NF   ）。要求   数据库表中的每个实例或行必须可以被惟一地区分   。通常需要为表加上一个列，以存储各个实例的惟一标识。这个惟一属性列被称为   主关键字或主键   。<br>        第二范式（   2NF   ）要求   实体的属性完全依赖于主关键字   。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。简而言之，第二范式就是非主属性非部分依赖于主关键字。<br>第三范式 （  3NF  ） ：   满足第三范式（   3NF   ）   必须先满足第二范式（   2NF   ）   。简而言之，第三范式（   3NF   ）要求一个数据库表中   不包含   已在其它表中   已包含的非主关键字信息   。所以第三范式具有如下特征：<br>1   ，每一列只有一个值<br>2   ，每一行都能区分。<br>3   ，每一个表都   不包含其他表已经包含   的非主关键字信息。<br>例如，帖子表中只能出现发帖人的   id   ，而不能出现发帖人的   id   ，还同时出现发帖人姓名，否则，只要出现同一发帖人   id   的所有记录，它们中的姓名部分都必须严格保持一致，这就是   数据冗余   。</p>','2017-03-18',3,18,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(368,'重载与重写','目前的问题：父类的功能无法满足子类的需求。 方法重写的前提： 必须要存在继承的关系。 方法的重写: 子父类出了同名的函数，这个我们就称作为方法的重写。 什么是时候要使用方法的重写：父类的功能无法满足子类的需求时。 方法重写要注意的事项： 1.方法重写时， 方法名与形参列表必须一致。 2.方法重写时，子类的权限修饰符必须要大于或者等于父类的权限修饰符。 3.方法重写时，子类的返回值类型必须要小于或者','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><p>目前的问题：父类的功能无法满足子类的需求。</p>\n<p>方法重写的前提： 必须要存在继承的关系。</p>\n<p>方法的重写: 子父类出了同名的函数，这个我们就称作为方法的重写。</p>\n<p>什么是时候要使用方法的重写：父类的功能无法满足子类的需求时。</p>\n<p>方法重写要注意的事项：<br>    1.方法重写时， 方法名与形参列表必须一致。<br>    2.方法重写时，子类的权限修饰符必须要大于或者等于父类的权限修饰符。<br>    3.方法重写时，子类的返回值类型必须要小于或者 等于父类的返回值类型。<br>    4.方法重写时， 子类抛出的异常类型要小于或者等于父类抛出的异常类型。<br>            Exception(最坏)<br>            RuntimeException(小坏)</p>\n<p>方法的重载：在一个类中 存在两个或者两个 以上的同名函数,称作为方法重载。</p>\n<p>方法重载的要求</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"lit\">1.</span><span class=\"pln\"> </span><span class=\"pun\">函数名要一致。</span></code></li><li class=\"L1\"><code><span class=\"lit\">2.</span><span class=\"pln\"> </span><span class=\"pun\">形参列表不一致（形参的个数或形参</span><span class=\"pln\"> </span><span class=\"pun\">的类型不一致）</span></code></li><li class=\"L2\"><code><span class=\"lit\">3.</span><span class=\"pln\"> </span><span class=\"pun\">与返回值类型无关。</span></code></li></ol></pre></div>','2017-03-21',1,19,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(369,'垃圾回收算法','垃圾回收算法 1、标记-清除算法 2、复制算法 3、标记-整理算法 一、标记-清除算法 标记-清除算法采用从根集合进行扫描，对存活的对象对象标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收，如上图所示。 标记-清除算法不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效，但由于标记-清除算法直接回收不存活的对象，因此会造成内存碎片！ 二、复制算法 复制算法','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h2 id=\"h2-u5783u573Eu56DEu6536u7B97u6CD5\"><a name=\"垃圾回收算法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>垃圾回收算法</h2><p>1、标记-清除算法<br>2、复制算法<br>3、标记-整理算法</p>\n<h4 id=\"h4--\"><a name=\"一、标记-清除算法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、标记-清除算法</h4><p><img src=\"http://dl2.iteye.com/upload/attachment/0075/0386/29ae17ad-f8af-38b4-9e25-28ef3550858f.jpg\" alt=\"\">标记-清除算法采用从根集合进行扫描，对存活的对象对象标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收，如上图所示。<br>标记-清除算法不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效，但由于标记-清除算法直接回收不存活的对象，因此会造成内存碎片！</p>\n<h4 id=\"h4--\"><a name=\"二、复制算法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、复制算法</h4><p><img src=\"http://dl2.iteye.com/upload/attachment/0075/0388/91a656d4-f08a-377b-8eea-5785c2932533.jpg\" alt=\"\"><br>复制算法采用从根集合扫描，并将存活对象复制到一块新的，没有使用过的空间中，这种算法当控件存活的对象比较少时，极为高效，但是带来的成本是需要一块内存交换空间用于进行对象的移动。也就是我们前面提到的s0 s1等空间。</p>\n<h4 id=\"h4--\"><a name=\"三、标记-整理算法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、标记-整理算法</h4><p><img src=\"http://dl2.iteye.com/upload/attachment/0075/0390/6ba95f80-c7bc-3d09-b927-ac09297e9920.jpg\" alt=\"\"><br> 标记-整理算法采用标记-清除算法一样的方式进行对象的标记，但在清除时不同，在回收不存活的对象占用的空间后，会将所有的存活对象往左端空闲空间移动，并更新对应的指针。标记-整理算法是在标记-清除算法的基础上，又进行了对象的移动，因此成本更高，但是却解决了内存碎片的问题。</p>\n</div>','2017-04-09',1,20,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(370,'java分代回收','一、新生代内存的回收（minor GC）主要采用复制算法，下图展示了minor GC的执行过程。 二、对于新生代和旧生代，JVM可使用很多种垃圾回收器进行垃圾回收，下图展示了不同生代不通垃圾回收器，其中两个回收器之间有连线表示这两个回收器可以同时使用。 而这些垃圾回收器又分为串行回收方式、并行回收方式合并发回收方式执行，分别运用于不同的场景。如下图所示 三、收集器 1.Serial收集器 看名字我','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h2 id=\"h2--minor-gc-minor-gc-\"><a name=\"一、新生代内存的回收（minor GC）主要采用复制算法，下图展示了minor GC的执行过程。\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、新生代内存的回收（minor GC）主要采用复制算法，下图展示了minor GC的执行过程。</h2><p><img src=\"http://dl2.iteye.com/upload/attachment/0075/0392/732c7557-aa9a-3551-b14d-f543c5b0c94b.jpg\" alt=\"\"></p>\n<h2 id=\"h2--jvm-\"><a name=\"二、对于新生代和旧生代，JVM可使用很多种垃圾回收器进行垃圾回收，下图展示了不同生代不通垃圾回收器，其中两个回收器之间有连线表示这两个回收器可以同时使用。\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、对于新生代和旧生代，JVM可使用很多种垃圾回收器进行垃圾回收，下图展示了不同生代不通垃圾回收器，其中两个回收器之间有连线表示这两个回收器可以同时使用。</h2><p><img src=\"http://dl2.iteye.com/upload/attachment/0075/0394/0172f624-9018-3642-bf26-05a2c3071639.jpg\" alt=\"\"><br>而这些垃圾回收器又分为串行回收方式、并行回收方式合并发回收方式执行，分别运用于不同的场景。如下图所示<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0396/c962c2ad-273f-3de4-b2e3-a4dd8b946215.jpg\" alt=\"\"></p>\n<h2 id=\"h2--\"><a name=\"三、收集器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、收集器</h2><h4 id=\"h4-1-serial-\"><a name=\"1.Serial收集器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.Serial收集器</h4><p>看名字我们都可以看的出来，这个属于串行收集器。其运行示意图如下<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0398/681da5ca-5eff-3984-bece-3d80dfe905be.jpg\" alt=\"\"><br>    收集器是历史最悠久的一个回收器，JDK1.3之前广泛使用这个收集器，目前也是ClientVM下 ServerVM 4核4GB以下机器的默认垃圾回收器。串行收集器并不是只能使用一个CPU进行收集，而是当JVM需要进行垃圾回收的时候，需要中断所有的用户线程，知道它回收结束为止，因此又号称“Stop The World” 的垃圾回收器。注意，JVM中文名称为java虚拟机，因此它就像一台虚拟的电脑一样在工作，而其中的每一个线程就被认为是JVM的一个处理器，因此大家看到图中的CPU0、CPU1实际为用户的线程，而不是真正机器的CPU，大家不要误解哦。<br>    串行回收方式适合低端机器，是Client模式下的默认收集器，对CPU和内存的消耗不高，适合用户交互比较少，后台任务较多的系统。<br>    Serial收集器默认新旧生代的回收器搭配为Serial+ SerialOld</p>\n<h4 id=\"h4-2-parnew-\"><a name=\"2.ParNew收集器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.ParNew收集器</h4><p>ParNew收集器其实就是多线程版本的Serial收集器，其运行示意图如下<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0400/6443b39c-ed33-3d93-a690-87e646439561.jpg\" alt=\"\"><br>同样有Stop The World的问题，他是多CPU模式下的首选回收器（该回收器在单CPU的环境下回收效率远远低于Serial收集器，所以一定要注意场景哦），也是Server模式下的默认收集器。</p>\n<h4 id=\"h4-3-parallelscavenge\"><a name=\"3.ParallelScavenge\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.ParallelScavenge</h4><p>ParallelScavenge又被称为是吞吐量优先的收集器，器运行示意图如下<br><img src=\"http://dl.iteye.com/upload/attachment/0075/0402/5007beba-0b0e-3cf4-b146-c28b6c0dd696.jpg\" alt=\"\"><br> ParallelScavenge<br>所提到的吞吐量=程序运行时间/(JVM执行回收的时间+程序运行时间),假设程序运行了100分钟，JVM的垃圾回收占用1分钟，那么吞吐量就是99%。在当今网络告诉发达的今天，良好的响应速度是提升用户体验的一个重要指标，多核并行云计算的发展要求程序尽可能的使用CPU和内存资源，尽快的计算出最终结果，因此在交互不多的云端，比较适合使用该回收器。</p>\n<h4 id=\"h4-4-parallelold\"><a name=\"4.ParallelOld\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.ParallelOld</h4><p>ParallelOld是老生代并行收集器的一种，使用标记整理算法、是老生代吞吐量优先的一个收集器。这个收集器是JDK1.6之后刚引入的一款收集器，我们看之前那个图之间的关联关系可以看到，早期没有ParallelOld之前，吞吐量优先的收集器老生代只能使用串行回收收集器，大大的拖累了吞吐量优先的性能，自从JDK1.6之后，才能真正做到较高效率的吞吐量优先。其运行示意图如下<br><img src=\"http://dl.iteye.com/upload/attachment/0075/0406/9a14da85-f943-3408-ba88-c6bb3842a792.jpg\" alt=\"\"></p>\n<h4 id=\"h4-5-serialold\"><a name=\"5.SerialOld\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.SerialOld</h4><p>SerialOld是旧生代Client模式下的默认收集器，单线程执行；在JDK1.6之前也是ParallelScvenge回收新生代模式下旧生代的默认收集器，同时也是并发收集器CMS回收失败后的备用收集器。其运行示意图如下<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0404/ce7aabd5-b0e0-3cda-9b6c-607cf6ebf689.jpg\" alt=\"\"></p>\n<h4 id=\"h4-5-cms\"><a name=\"5.CMS\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.CMS</h4><p>CMS又称响应时间优先(最短回收停顿)的回收器，使用并发模式回收垃圾，使用标记-清除算法，CMS对CPU是非常敏感的，它的回收线程数=（CPU+3）/4，因此当CPU是2核的实惠，回收线程将占用的CPU资源的50%，而当CPU核心数为4时仅占用25%。他的运行示意图如下<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0408/4239228b-879f-382f-81c6-5c32799886d6.jpg\" alt=\"\"><br>模式主要分为四个过程：<br>1.初始标记<br>2.并发标记<br>3.重新标记<br>4.并发清除<br>在初始标记的时候，需要中断所有用户线程，在并发标记阶段，用户线程和标记线程<br>并发执行，而在这个过程中，随着内存引用关系的变化，可能会发生原来标记的对象被释放，进而引发新的垃圾，因此可能会产生一系列的浮动垃圾，不能被回收。</p>\n<p>CMS 为了确保能够扫描到所有的对象，避免在Initial Marking 中还有未标识到的对象，采用的方法为找到标记了的对象，并将这些对象放入Stack 中，扫描时寻找此对象依赖的对象，如果依赖的对象的地址在其之前，则将此对象进行标记，并同时放入Stack 中，如依赖的对象地址在其之后，则仅标记该对象。<br>在进行Concurrent Marking 时minor GC 也可能会同时进行，这个时候很容易造成旧生代对象引用关系改变，CMS 为了应对这样的并发现象，提供了一个Mod Union Table 来进行记录，在这个Mod Union Table中记录每次minor GC 后修改了的Card 的信息。这也是ParallelScavenge不能和CMS一起使用的原因。<br>CMS产生浮动垃圾的情况请见如下示意图<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0410/60e7c659-790a-3405-af70-9ca4cfd9258d.jpg\" alt=\"\"><br>在运行回收过后，c就变成了浮动垃圾。<br>由于CMS会产生浮动垃圾，当回收过后，浮动垃圾如果产生过多，同时因为使用标记-清除算法会产生碎片，可能会导致回收过后的连续空间仍然不能容纳新生代移动过来或者新创建的大资源，因此会导致CMS回收失败，进而触发另外一次FULL GC，而这时候则采用SerialOld进行二次回收。<br>同时CMS因为可能产生浮动垃圾，而CMS在执行回收的同时新生代也有可能在进行回收操作，为了保证旧生代能够存放新生代转移过来的数据，CMS在旧生代内存到达全部容量的68%就触发了CMS的回收！</p>\n<h4 id=\"h4-7-garbagefirst-g1-\"><a name=\"7.GarbageFirst(G1)\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>7.GarbageFirst(G1)</h4><p>我们再来看垃圾回收器的总图，刚才我们可以看到，我在图上标记了一个？，其实这是一个新的垃圾回收器，既可以回收新生代也可以回收旧生代，SunHotSpot 1.6u14以上EarlyAccess版本加入了这个回收器，sun公司预期SunHotSpot1.7发布正式版，他是商用高性能垃圾回收器，通过重新划分内存区域，整合优化CMS，同时注重吞吐量和响应时间，但是杯具的是被Oracle收购之后这个收集器属于商用收费收集器，因此目前基本上没有人使用，我们在这里也就不多介绍，更多信息可以参考oracle新版本JDK说明。</p>\n</div>','2017-04-09',1,22,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(371,'java汇编','java 汇编 http://download.csdn.net/download/jiangfuqiang/8403497','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><p>java 汇编<br><a href=\"http://download.csdn.net/download/jiangfuqiang/8403497\">http://download.csdn.net/download/jiangfuqiang/8403497</a></p>\n</div>','2017-04-10',1,26,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(372,'jvm','-XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><p>-XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly</p>\n</div>','2017-04-10',1,28,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(373,'Adaboost','NaiveBayesSpamFilter 利用朴素贝叶斯算法实现垃圾邮件的过滤，并结合Adaboost改进该算法。 1 Naive Bayes spam filtering   假设邮件的内容中包含的词汇为Wi，垃圾邮件Spam，正常邮件ham。 判断一份邮件，内容包含的词汇为Wi，判断该邮件是否是垃圾邮件，即计算P（S|Wi）这个条件概率。根据Bayes’ theorem：   Bayes’ t','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h1 id=\"h1-naivebayesspamfilter\"><a name=\"NaiveBayesSpamFilter\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>NaiveBayesSpamFilter</h1><p>利用朴素贝叶斯算法实现垃圾邮件的过滤，并结合Adaboost改进该算法。</p>\n<h3 id=\"h3-1-naive-bayes-spam-filtering\"><a name=\"1 Naive Bayes spam filtering\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1 Naive Bayes spam filtering</h3><p>  假设邮件的内容中包含的词汇为Wi，垃圾邮件Spam，正常邮件ham。 判断一份邮件，内容包含的词汇为Wi，判断该邮件是否是垃圾邮件，即计算P（S|Wi）这个条件概率。根据Bayes’ theorem：</p>\n<p>  Bayes’ theorem</p>\n<p>  其中：</p>\n<p>Pr(S|Wi) 出现词汇Wi的邮件是垃圾邮件的条件概率（即后验概率）；<br>Pr(S) 训练阶段邮件数据集中垃圾邮件的概率，或实际调查的垃圾邮件的概率（即先验概率）；<br>Pr(Wi|S) 垃圾邮件中词汇Wi出现的概率；<br>Pr(H) 训练阶段邮件数据集中正常邮件的概率，或实际调查的正常邮件的概率；<br>Pr(Wi|H) 正常邮件中词汇Wi出现的概率；<br>  对于邮件中出现的所有词汇，考虑每个词汇出现事件的独立性，计算Pr(S|Wi)的联合概率Pr(S|W)，W={W1，W2，…Wn}：</p>\n<p>  Bayes’ theorem</p>\n<p>  其中：</p>\n<p>P 即Pr(S|W)，出现词汇W={W1，W2……Wn}的邮件是垃圾邮件的条件概率；<br>Pi 即Pr(S|Wi)，出现词汇Wi的邮件是垃圾邮件的条件概率；<br>  注： 程序中，通过计算出Pr(S|W)和Pr(H|W)，比较Pr(S|W)和Pr(H|W)的大小，判断是垃圾邮件还是正常邮件。我们发现Pr(S|W)和Pr(H|W)计算的分母相同，所以我们只需要比较分子即可。</p>\n<p>  但存在两个问题：</p>\n<p>当词汇不存在时，即ni=0，此时Pr(S|Wi) = 0，会造成P=0，无法比较<br>当Pr(S|Wi)较小时，连乘操作会造成下溢出问题<br>  解决方案：</p>\n<p>计算P(Wi|S)和P(Wi|H)时，将所有词汇初始化出现的次数为1，并将分母初始化为2（或根据样本/实际调查结果调整分母的值）。</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"com\"># 统计语料库中词汇在S和H中出现的次数</span></code></li><li class=\"L1\"><code><span class=\"pln\">wordsInSpamNum </span><span class=\"pun\">=</span><span class=\"pln\"> np</span><span class=\"pun\">.</span><span class=\"pln\">ones</span><span class=\"pun\">(</span><span class=\"pln\">numWords</span><span class=\"pun\">)</span></code></li><li class=\"L2\"><code><span class=\"pln\">wordsInHealthNum </span><span class=\"pun\">=</span><span class=\"pln\"> np</span><span class=\"pun\">.</span><span class=\"pln\">ones</span><span class=\"pun\">(</span><span class=\"pln\">numWords</span><span class=\"pun\">)</span></code></li><li class=\"L3\"><code><span class=\"pln\">spamWordsNum </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">2.0</span></code></li><li class=\"L4\"><code><span class=\"pln\">healthWordsNum </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">2.0</span></code></li></ol></pre><p>计算P(Wi|S)和P(Wi|H)时，对概率取对数<br>    pWordsSpamicity = np.log(wordsInSpamNum / spamWordsNum)<br>    pWordsHealthy = np.log(wordsInHealthNum / healthWordsNum)<br>  所以最终比较的是，P(W1|S)P(W2|S)….P(Wn|S)P(S)和P(W1|H)P(W2|H)….P(Wn|H)P(H)的大小。</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"pln\">ps </span><span class=\"pun\">=</span><span class=\"pln\"> sum</span><span class=\"pun\">(</span><span class=\"pln\">testWordsMarkedArray </span><span class=\"pun\">*</span><span class=\"pln\"> pWordsSpamicity</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">+</span><span class=\"pln\"> np</span><span class=\"pun\">.</span><span class=\"pln\">log</span><span class=\"pun\">(</span><span class=\"pln\">pSpam</span><span class=\"pun\">)</span></code></li><li class=\"L1\"><code><span class=\"pln\">ph </span><span class=\"pun\">=</span><span class=\"pln\"> sum</span><span class=\"pun\">(</span><span class=\"pln\">testWordsMarkedArray </span><span class=\"pun\">*</span><span class=\"pln\"> pWordsHealthy</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">+</span><span class=\"pln\"> np</span><span class=\"pun\">.</span><span class=\"pln\">log</span><span class=\"pun\">(</span><span class=\"lit\">1</span><span class=\"pln\"> </span><span class=\"pun\">-</span><span class=\"pln\"> pSpam</span><span class=\"pun\">)</span></code></li></ol></pre><p>  测试效果： 5574个样本，采用交叉验证，随机选取4574个作为训练样本，产生词汇列表（语料库），对1000个测试样本，分类的平均错误率约为：2.5%。</p>\n<h3 id=\"h3-2-running-adaboost-on-naive-bayes\"><a name=\"2 Running Adaboost on Naive Bayes\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2 Running Adaboost on Naive Bayes</h3><p>  我们在计算ps和ph联合后验概率时，可引入一个调整因子DS，其作用是调整词汇表中某一词汇的“垃圾程度”(spamicity)，</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"pln\">ps </span><span class=\"pun\">=</span><span class=\"pln\"> sum</span><span class=\"pun\">(</span><span class=\"pln\">testWordsMarkedArray </span><span class=\"pun\">*</span><span class=\"pln\"> pWordsSpamicity </span><span class=\"pun\">*</span><span class=\"pln\"> DS</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">+</span><span class=\"pln\"> np</span><span class=\"pun\">.</span><span class=\"pln\">log</span><span class=\"pun\">(</span><span class=\"pln\">pSpam</span><span class=\"pun\">)</span></code></li></ol></pre><p>  其中DS通过Adaboost算法迭代获取最佳值。原理如下：</p>\n<p>设定adaboost循环的次数count<br>交叉验证随机选择1000个样本<br>DS初始化为和词汇列表大小相等的全一向量<br>迭代循环count次：<br>    设定最小分类错误率为inf<br>    对于每一个样本：<br>        在当前DS下对样本分类<br>        如果分类出错：<br>            计算出错的程度，即比较ps和ph的相差alpha<br>            如果样本原本是spam，错分成ham：<br>                DS[样本包含的词汇] = np.abs(DS[样本包含的词汇] - np.exp(alpha) / DS[样本包含的词汇])<br>            如果样本原本是ham，错分成spam：<br>                DS[样本包含的词汇] = DS[样本包含的词汇] + np.exp(alpha) / DS[样本包含的词汇]<br>    计算错误率<br>    保存最小的错误率和此时的词汇列表、P(Wi|S)和P(Wi|H)、DS等信息，即保存训练好的最佳模型的信息<br>  测试效果： 5574个样本，获取Adaboost算法训练的最佳模型信息（包括词汇列表、P(Wi|S)和P(Wi|H)、DS等），对1000个测试样本，分类的平均错误率约为：0.5%。</p>\n</div>','2017-04-17',4,25,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(374,'Java堆.栈和常量池 笔记','Java堆.栈和常量池 笔记','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><p><a href=\"http://www.iteye.com/topic/634530\">Java堆.栈和常量池 笔记</a></p>\n</div>','2017-04-23',1,18,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(375,'redis','redis的数据结构 数据结构类型 结构存储的值 结构的读写能力 STRING 可以是字符串、整数、或者浮点数 对整个字符串或者字符串的其中一部分执行操作；对整数和浮点数执行自增或者自减 LIST 一个链表，链表上的每个节点都包含了一个字符串 从链表的两端推入或者弹出元素；根据偏移量对链表进行修剪；根据值查找或者移除元素 SET 包含字符串的无序收集器，并且被包含的每个字符串都是独一无二、各不相同','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h1 id=\"h1-redis-\"><a name=\"redis的数据结构\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>redis的数据结构</h1><table>\n<thead>\n<tr>\n<th>数据结构类型</th>\n<th>结构存储的值</th>\n<th>结构的读写能力</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>STRING</td>\n<td>可以是字符串、整数、或者浮点数</td>\n<td>对整个字符串或者字符串的其中一部分执行操作；对整数和浮点数执行自增或者自减</td>\n</tr>\n<tr>\n<td>LIST</td>\n<td>一个链表，链表上的每个节点都包含了一个字符串</td>\n<td>从链表的两端推入或者弹出元素；根据偏移量对链表进行修剪；根据值查找或者移除元素</td>\n</tr>\n<tr>\n<td>SET</td>\n<td>包含字符串的无序收集器，并且被包含的每个字符串都是独一无二、各不相同的</td>\n<td>添加、获取、移除单个元素；检查一个元素是否存在于集合中；计算交集、并集、差集；从集合里面随机获取元素</td>\n</tr>\n<tr>\n<td>HASH</td>\n<td>包含键值对的无语散列表</td>\n<td>添加、获取、移除单个键值对；获取所有键值对</td>\n</tr>\n<tr>\n<td>ZSET(有序集合)</td>\n<td>字符串成员与浮点数分值之间的有序映射，元素的排列顺序由分值的大小决定</td>\n<td>添加、获取、单个元素；根据分值范围或者成员来获取元素</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"h3--string-\"><a name=\"一、STRING基本操作\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、STRING基本操作</h3><p>（1）SET 设置存储在给定键中的值<br>（2）GET 获取存储在给定键中的值<br>（3）DEL 删除存储在给定键中的值</p>\n<h3 id=\"h3--list-\"><a name=\"二、LIST（列表）基本操作\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、LIST（列表）基本操作</h3><p>（1）RPUSH 将给定值推入列表的右端<br>（2）LRANGE 获取列表在给定范围上的所有值<br>（3）LINDEX 获取列表在给定位置上的单个元素<br>（4）LPOP 从列表的左端弹出一个值，并返回被弹出的值</p>\n<h3 id=\"h3--set-\"><a name=\"三、SET（集合）基本操作\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>　三、SET（集合）基本操作</h3><p>（1）SADD 将给定元素添加到集合<br>（2）SMEMBERS 返回集合包含的所有元素<br>（3）SISMEMBER 检查给定元素是否存在于集合中<br>（4）SREM 如果给定的元素存在于集合中，那么移除这个元素</p>\n<h3 id=\"h3--hash-\"><a name=\"四、HASH（散列）基本操作\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>四、HASH（散列）基本操作</h3><p>（1）HSET 在散列里面关联起给定的键值对<br>（2）HGET 获取指定散列键的值<br>（3）HGETALL 获取散列包含的所有键值对<br>（4）HDEL 如果给定键存在于散列里面，那么移除这个键</p>\n<h3 id=\"h3--zset-\"><a name=\"五、ZSET（有序集合）基本操作\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>五、ZSET（有序集合）基本操作</h3><p>（1）ZADD 将一个带有给定分值的成员添加到有序集合里面<br>（2）ZRANGE 根据元素在有序排列中所处的位置，从有序集合里面获取多个元素<br>（3）ZRANGEBYSCORE 获取有序集合在给定分值范围的所有元素<br>（4）ZREM 如果给定成员存在于有序集合，那么移除这个成员</p>\n</div>','2017-05-04',6,21,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(376,'工厂模式','工厂模式 目录 何为工厂模式 工厂方法与抽象工厂 如何在Java EE中通过@Producers与@Inject注解实现工厂模式 如何创建自定义注解以及通过@Qualifier消除具体实现之间的歧义 工厂模式有两种模式：工厂方法和抽象方法。它们的意图是一样的：提供一个接口，在不指定具体类的情况下创建相关或依赖的一系列对象。 一.何为工厂模式 工厂的目的在于创建对象。创建的逻辑被封装在工厂中，要么提','<h1 id=\"h1-u5DE5u5382u6A21u5F0F\"><a name=\"工厂模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>工厂模式</h1><p>目录</p>\r\n<ul>\r\n<li>何为工厂模式</li><li>工厂方法与抽象工厂</li><li>如何在Java EE中通过<a href=\"https://github.com/Producers\" title=\"&#64;Producers\" class=\"at-link\">@Producers</a>与<a href=\"https://github.com/Inject\" title=\"&#64;Inject\" class=\"at-link\">@Inject</a>注解实现工厂模式</li><li>如何创建自定义注解以及通过<a href=\"https://github.com/Qualifier\" title=\"&#64;Qualifier\" class=\"at-link\">@Qualifier</a>消除具体实现之间的歧义<br>工厂模式有两种模式：工厂方法和抽象方法。它们的意图是一样的：提供一个接口，在不指定具体类的情况下创建相关或依赖的一系列对象。</li></ul>\r\n<h3 id=\"h3--\"><a name=\"一.何为工厂模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一.何为工厂模式</h3><p>工厂的目的在于创建对象。创建的逻辑被封装在工厂中，要么提供一个方法来返回新创建的对象（工厂方法模式），要么将对象的创建委托给子类（抽象工厂模式）。<br>客户端不必考虑接口或类的不同实现，它只需通过工厂（工厂）获取接口实现的一个实例的即可，这样客户端与对象的创建就实现了解耦<br>解耦是应用依赖反转原则的结果，这带来了很多好处，其中最重要的好处就是实现了高层类与底层类之间的解耦。通过解耦，具体类实现的变化不会影响到客户端，这降低了类与类之间的耦合，并提升了灵活性。</p>\r\n<h3 id=\"h3--\"><a name=\"二.工厂方法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二.工厂方法</h3><p>GoF一书是这样描述工程方法模式的：“定义一个用于创建对象的接口，不过让子类决定实例化那个类”<br>工厂极大降低了new关键字的使用次数，并且将初始化过程与不同的具体实现封装起来。将这些需求中心化可以极大减少向系统中添加或删除具体类的影响以及具体的类依赖的影响。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src=\"http://ohlrxdl4p.bkt.clouddn.com/images/QQ截图20170506134421.jpg\" alt=\"\"><br><strong>1.使用普通代码实现工厂方法</strong><br>被具体实现继承的DrinksMachine抽象类</p>\r\n<pre><code class=\"lang-java\">public abstract class DrinksMachine {\r\n    public abstract Drink dispenseDrink();\r\n    public String displayMessage(){\r\n        return &quot;Thank for your custom.&quot;;\r\n    }\r\n}\r\n</code></pre>\r\n<p>DrinksMachine抽象类的CoffeeMachine实现</p>\r\n<pre><code class=\"lang-java\">public class CoffeeMachine extends DrinksMachine {\r\n    public Drink dispenseDrink() {\r\n        return new Coffee();\r\n    }\r\n}\r\n</code></pre>\r\n<p>DrinksMachine抽象类的SoftDrinksMachine实现</p>\r\n<pre><code class=\"lang-java\">public class SoftDrinksMachine extends DrinksMachine {\r\n    public Drink dispenseDrink() {\r\n        return new SoftDrink();\r\n    }\r\n}\r\n</code></pre>\r\n<p>Drink接口</p>\r\n<pre><code class=\"lang-java\">public interface Drink {}\r\n</code></pre>\r\n<p>Drink接口的SoftDrink实现</p>\r\n<pre><code class=\"lang-java\">public class SoftDrink implements Drink {\r\n    SoftDrink() {\r\n        System.out.println(&quot;Soft drink&quot;);\r\n    }\r\n}\r\n</code></pre>\r\n<p>Drink接口的Coffee实现</p>\r\n<pre><code class=\"lang-java\">public class Coffee implements Drink {\r\n    Coffee() {\r\n        System.out.println(&quot;Coffee&quot;);\r\n    }\r\n}\r\n</code></pre>\r\n<p>CoffeeType枚举<br>```java<br>public enum CoffeeType {EXPRESSO, LATTE}</p>\r\n<p>public Drink dispenseDrink(CoffeeType type) {<br>    Drink coffee = null;<br>    switch (type) {<br>        case EXPRESSO: coffee = new Expresso();<br>        case LATTE: coffee = new Latte();<br>    }<br>    return coffee;<br>}<br>```&lt;!--前面不能有空格--&gt;</p>','2017-05-06',1,33,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(377,'代理模式','代理模式(Proxy Pattern) GoF中给出的代理模式的定义为： 代理模式给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。 代理模式的英文叫做Proxy或Surrogate，它是一种对象结构型模式。 代理模式根据其目的和实现可分为很多种类，常用的代理模式包括如下几种： （1）远程代理（Remote Proxy）————为一个位于不同的地址空间的对象提供一个本地的代理对象','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h1 id=\"h1--proxy-pattern-\"><a name=\"代理模式(Proxy Pattern)\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代理模式(Proxy Pattern)</h1><p>GoF中给出的代理模式的定义为：<br>代理模式给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。<br>代理模式的英文叫做Proxy或Surrogate，它是一种对象结构型模式。<br>代理模式根据其目的和实现可分为很多种类，常用的代理模式包括如下几种：<br>（1）远程代理（Remote Proxy）————为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以是在同一台主机中，也可以是在另一台主机中，远程代理又称为大使（Ambassador）<br>（2）虚拟代理（Virtual Proxy）————如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。<br>（3）保护代理（Protect Proxy）————控制一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。<br>（4）缓冲代理（Cache Proxy）————为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。<br>（5）只能引用代理（Smart Reference Proxy）————当一个对象被引用时，提供一些额外的操作，例如将对象被调用的次数记录下来。<br><img src=\"http://ohlrxdl4p.bkt.clouddn.com/images/QQ截图20170507103646.jpg\" alt=\"\"></p>\n<p>代码实现：<br>1.抽象主题类——BuyTicket.java</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code class=\"lang-java\"><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">interface</span><span class=\"pln\"> </span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> showticket</span><span class=\"pun\">();</span></code></li><li class=\"L2\"><code class=\"lang-java\"><span class=\"pun\">}</span></code></li></ol></pre>\n<p>2.具体主题类——Train.java</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code class=\"lang-java\"><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Train</span><span class=\"pln\"> </span><span class=\"kwd\">implements</span><span class=\"pln\"> </span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"lit\">@Override</span></code></li><li class=\"L2\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> showticket</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L3\"><code class=\"lang-java\"><span class=\"pln\">        </span><span class=\"typ\">System</span><span class=\"pun\">.</span><span class=\"pln\">out</span><span class=\"pun\">.</span><span class=\"pln\">println</span><span class=\"pun\">(</span><span class=\"str\">\"one ticket\"</span><span class=\"pun\">);</span></code></li><li class=\"L4\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L5\"><code class=\"lang-java\"><span class=\"pun\">}</span></code></li></ol></pre>\n<p>3.代理角色类——TicketCenter.java</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code class=\"lang-java\"><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">TicketCenter</span><span class=\"pln\"> </span><span class=\"kwd\">implements</span><span class=\"pln\"> </span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> ticket</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code class=\"lang-java\"></code></li><li class=\"L3\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"typ\">TicketCenter</span><span class=\"pun\">(</span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> ticket</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code class=\"lang-java\"><span class=\"pln\">        </span><span class=\"kwd\">this</span><span class=\"pun\">.</span><span class=\"pln\">ticket </span><span class=\"pun\">=</span><span class=\"pln\"> ticket</span><span class=\"pun\">;</span></code></li><li class=\"L5\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code class=\"lang-java\"></code></li><li class=\"L7\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"lit\">@Override</span></code></li><li class=\"L8\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> showticket</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L9\"><code class=\"lang-java\"><span class=\"pln\">        ticket</span><span class=\"pun\">.</span><span class=\"pln\">showticket</span><span class=\"pun\">();</span></code></li><li class=\"L0\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code class=\"lang-java\"></code></li><li class=\"L2\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> buy</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L3\"><code class=\"lang-java\"><span class=\"pln\">        </span><span class=\"typ\">System</span><span class=\"pun\">.</span><span class=\"pln\">out</span><span class=\"pun\">.</span><span class=\"pln\">println</span><span class=\"pun\">(</span><span class=\"str\">\"by proxy\"</span><span class=\"pun\">);</span></code></li><li class=\"L4\"><code class=\"lang-java\"><span class=\"pln\">        showticket</span><span class=\"pun\">();</span></code></li><li class=\"L5\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code class=\"lang-java\"><span class=\"pun\">}</span></code></li></ol></pre>\n<p>4.客户端测试类</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code class=\"lang-java\"><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">ProxyPattern</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> main</span><span class=\"pun\">(</span><span class=\"typ\">String</span><span class=\"pln\"> args</span><span class=\"pun\">[])</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L2\"><code class=\"lang-java\"><span class=\"pln\">        </span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> x </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Train</span><span class=\"pun\">();</span></code></li><li class=\"L3\"><code class=\"lang-java\"><span class=\"pln\">        </span><span class=\"typ\">TicketCenter</span><span class=\"pln\"> y </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">TicketCenter</span><span class=\"pun\">(</span><span class=\"pln\">x</span><span class=\"pun\">);</span></code></li><li class=\"L4\"><code class=\"lang-java\"><span class=\"pln\">        y</span><span class=\"pun\">.</span><span class=\"pln\">buy</span><span class=\"pun\">();</span></code></li><li class=\"L5\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code class=\"lang-java\"><span class=\"pun\">}</span></code></li></ol></pre>\n<p>运行结果：</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code class=\"lang-html\"><span class=\"pln\">by proxy</span></code></li><li class=\"L1\"><code class=\"lang-html\"><span class=\"pln\">one ticket</span></code></li></ol></pre>\n</div>','2017-05-07',1,35,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(378,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,31,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(379,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,22,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(380,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,19,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(381,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,19,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(382,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,19,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(383,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,19,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(384,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,19,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(385,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,19,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(386,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,17,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(387,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,18,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(388,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,19,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(389,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>','2016-02-02',2,21,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(390,'BSbsbsbs','heloo 哦i已被肉','<h1 id=\"h1-heloo-i-\"><a name=\"heloo 哦i已被肉\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>heloo 哦i已被肉</h1>','2017-01-23',3,20,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(391,'2017-02-28学习笔记','','<p><img src=\"http://ohlrxdl4p.bkt.clouddn.com/images/826546_1482322555369_C5DABB18734059E89A45A0E9170722B0.png\" alt=\"\"></p>','2017-02-28',1,23,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(392,'2017-03-01学习笔记','知识点 1.java中只有值传递，没有引用传递http://guhanjie.iteye.com/blog/1683637 2.final关键字 final修饰变量，则等同于常量. final修饰方法中的参数，称为最终参数. final修饰类，则类不能被继承. final修饰方法，则方法不能被','<h1 id=\"h1-u77E5u8BC6u70B9\"><a name=\"知识点\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>知识点</h1><h4 id=\"h4-1-java-http-guhanjie-iteye-com-blog-1683637\"><a name=\"1.java中只有值传递，没有引用传递  http://guhanjie.iteye.com/blog/1683637\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.java中只有值传递，没有引用传递<a href=\"http://guhanjie.iteye.com/blog/1683637\">http://guhanjie.iteye.com/blog/1683637</a></h4><h4 id=\"h4-2-final-\"><a name=\"2.final关键字\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.final关键字</h4><ul>\r\n<li>final修饰变量，则等同于常量.</li><li>final修饰方法中的参数，称为最终参数.</li><li>final修饰类，则类不能被继承.</li><li>final修饰方法，则方法不能被重写.</li></ul>\r\n<h4 id=\"h4-3-integer-img-src-https-uploadfiles-nowcoder-com-images-20160717-6316247_1468761643205_9f7b85ab04292cf73778d98998a20ed1-alt-\"><a name=\"3.Integer<img src=\"https://uploadfiles.nowcoder.com/images/20160717/6316247_1468761643205_9F7B85AB04292CF73778D98998A20ED1\" alt=\"图片\">\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.Integer<img src=\"https://uploadfiles.nowcoder.com/images/20160717/6316247_1468761643205_9F7B85AB04292CF73778D98998A20ED1\" alt=\"图片\"></h4><h4 id=\"h4-4-java-\"><a name=\"4.java内存模型   点击原文\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.java内存模型 <a href=\"http://blog.csdn.net/ns_code/article/details/17565503\">点击原文</a></h4><p><img src=\"https://uploadfiles.nowcoder.com/images/20161223/415611_1482452184396_6FB53C51539B47559CF0D122A832CF63\" alt=\"\"></p>\r\n<h4 id=\"h4-5-java-reference\"><a name=\"5.java中是没有指针的，有reference\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.java中是没有指针的，有reference</h4><p>第一：指针变量是在栈内存中，它也是有值的，这个值存储的就是地址单元，这个地址就是来自于赋值操作。<br>第二：指针变量有类型，这个类型（如Person）的含义是指针指向的变量在栈内存（不是很确定）中的范围（大小），我理解为是占用的堆内存空间。<br>第三：声明一个对象时，是对“指针变量”的定义。<br>第四：用new关键字在堆内存创建了对象，在赋值时，是把这个对象的首地址传给了这个“指针变量”（即引用型变量）。</p>\r\n<h4 id=\"h4-6-string-\"><a name=\"6.String生成常量\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6.String生成常量</h4><pre><code class=\"lang-java\">String s1=&quot;abc&quot;+&quot;def&quot;;//生成的是一个常量，放在堆内存中\r\nString s2=new String（s1);//s2是一个变量\r\nif(s1.equals(s2))//比较的是字符串的内容\r\n    System.out.println(&quot;.equals succeeded&quot;);//输出\r\nif(s1==s2)//比较的是内存地址，但s1是常量，所以不相等\r\n    System.out.println(&quot;==succeeded&quot;);\r\n</code></pre>\r\n<h4 id=\"h4-7-jsp-\"><a name=\"7.jsp内置对象和属性\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>7.jsp内置对象和属性</h4><p>（１）request对象<br>客户端的请求信息被封装在request对象中，通过它才能了解到客户的需求，然后做出响应。它是HttpServletRequest类的实例。<br>（２）response对象<br>response对象包含了响应客户请求的有关信息，但在JSP中很少直接用到它。它是HttpServletResponse类的实例。<br>（３）session对象<br>session对象指的是客户端与服务器的一次会话，从客户连到服务器的一个WebApplication开始，直到客户端与服务器断开连接为止。它是HttpSession类的实例.<br>（４）out对象<br>out对象是JspWriter类的实例,是向客户端输出内容常用的对象<br>（５）page对象<br>page对象就是指向当前JSP页面本身，有点象类中的this指针，它是java.lang.Object类的实例<br>（６）application对象<br>application对象实现了用户间数据的共享，可存放全局变量。它开始于服务器的启动，直到服务器的关闭，在此期间，此对象将一直存在；这样在用户的前后连接或不同用户之间的连接中，可以对此对象的同一属性进行操作；在任何地方对此对象属性的操作，都将影响到其他用户对此的访问。服务器的启动和关闭决定了application对象的生命。它是ServletContext类的实例。<br>（７）exception对象<br>exception对象是一个例外对象，当一个页面在运行过程中发生了例外，就产生这个对象。如果一个JSP页面要应用此对象，就必须把isErrorPage设为true，否则无法编译。他实际上是java.lang.Throwable的对象<br>（８）pageContext对象<br>pageContext对象提供了对JSP页面内所有的对象及名字空间的访问，也就是说他可以访问到本页所在的SESSION，也可以取本页面所在的application的某一属性值，他相当于页面中所有功能的集大成者，它的本 类名也叫pageContext。<br>（９）config对象<br>config对象是在一个Servlet初始化时，JSP引擎向它传递信息用的，此信息包括Servlet初始化时所要用到的参数（通过属性名和属性值构成）以及服务器的有关信息（通过传递一个ServletContext对象）</p>','2017-03-01',1,26,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(393,'2017-03-02学习笔记','知识点 一、static public class Spike\r\n{\r\n    public static void main(String[] args)\r\n    {\r\n        Counter a = new Counter();\r\n        System.out.println(a.increment());\r\n        System.out.println(a.anot','<h1 id=\"h1-u77E5u8BC6u70B9\"><a name=\"知识点\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>知识点</h1><h4 id=\"h4--static\"><a name=\"一、static\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、static</h4><pre><code class=\"lang-java\">public class Spike\r\n{\r\n    public static void main(String[] args)\r\n    {\r\n        Counter a = new Counter();\r\n        System.out.println(a.increment());\r\n        System.out.println(a.anotherIncrement());\r\n        Counter b = new Counter();\r\n        System.out.println(b.increment());\r\n    }\r\n}\r\nclass Counter\r\n{\r\n    private static int count = 0;\r\n    public int increment()\r\n    {\r\n        return count++;\r\n    }\r\n    public int anotherIncrement()\r\n    {\r\n        return ++count;\r\n    }\r\n}\r\n</code></pre>\r\n<p>count是静态变量，为所有对象所共享，因此不管a.increment()还是b.increment()都会使count持续增加。<br>increment()方法返回当前count值，然后count增加1<br>antoherIncrement()方法让count增加1，然后返回count值<br>第一次a.increment()返回值为0，此时count值为1<br>第二次a.anotherIncrement()先让count+1再返回，返回值为2<br>第三次b.increment()先返回count当前值2，然后count+1</p>\r\n<h4 id=\"h4--aop-\"><a name=\"二、AOP面向切面\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、AOP面向切面</h4><p>AOP的概念是Aspected Oriented Programming 面向方面编程。<br>  好处：AOP将程序分解成各个方面或者说关注点。这使得可以模块化，相当横向上分切了。它可以解决OOP和过程化方法不能够很好解决的横切（crosscut）问题，如：事务、安全、日志等横切关注。<br>  实现AOP有几种方式:<br>  1.Spring 1.2版本中通过ProxyFactoryBean来实现aop,即通过动态代理来实现的,Aspect必须继承MethodBeforeAdvice,MethodAfterAdvice等<br>  2.Spring 2.0 AOP需要改的是FBI 这个类，而且它也不需要再实现某些接口<br>  3.三使用标注（<a href=\"https://github.com/AspectJ\" title=\"&#64;AspectJ\" class=\"at-link\">@AspectJ</a>）实现AOP<br>    AOP 和 OOP的区别：</p>\r\n<pre><code>```html\r\n 1. 面向方面编程 AOP 偏重业务处理过程的某个步骤或阶段，强调降低模块之间的耦合度，使代码拥有更好的移植性。  \r\n 2. 面向对象编程 (oop) 则是对业务分析中抽取的实体进行方法和属性的封装。\r\n ```\r\n</code></pre><p>也可以说 AOP 是面向业务中的动词领域， OOP 面向名词领域。<br>AOP 的一个很重要的特点是源代码无关性，也就是说如果我们的系统中引用了 AOP 组件，即使我们把该组件去掉，系统代码也应该能够编译通过。要实现这一点，可以使用动态 proxy 模式。</p>\r\n<h4 id=\"h4--jdbc-\"><a name=\"三、jdbc桥接模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、jdbc桥接模式</h4><p>桥接模式：<br>定义 ：将抽象部分与它的实现部分分离，使它们都可以独立地变化。<br>意图 ：将抽象与实现解耦。<br>桥接模式所涉及的角色</p>\r\n<ol>\r\n<li>Abstraction ：定义抽象接口，拥有一个Implementor类型的对象引用</li><li>RefinedAbstraction ：扩展Abstraction中的接口定义</li><li>Implementor ：是具体实现的接口，Implementor和RefinedAbstraction接口并不一定完全一致，实际上这两个接口可以完全不一样Implementor提供具体操作方法，而Abstraction提供更高层次的调用</li><li>ConcreteImplementor ：实现Implementor接口，给出具体实现<br>Jdk中的桥接模式：JDBC<br>JDBC连接 数据库 的时候，在各个数据库之间进行切换，基本不需要动太多的代码，甚至丝毫不动，原因就是JDBC提供了统一接口，每个数据库提供各自的实现，用一个叫做数据库驱动的程序来桥接就行了<h4 id=\"h4--\"><a name=\"四、抽象类\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>四、抽象类</h4>抽象类和普通类有三点区别：<br>1）抽象方法必须为public和protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public。<br>2）抽象类不能用来创建对象，但是它可以有构造方法，用来帮助子类实例化。<br>3）如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为abstract类。<h4 id=\"h4--\"><a name=\"五、接口\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>五、接口</h4>接口的主要特点<br>1）接口中的成员变量默认都是public、static、final类型的，必须被显示初始化。<br>2）接口中的方法默认都是public、abstract类型的。<br>3）接口中只能包含public、static、final类型的成员变量和public、abstract类型的成员方法。<br>4）接口没有构造方法，不能被实例化。<br>5）一个接口不能实现另一个接口，但它可以继承多个其他接口。<br>6）接口必须通过类来实现它的抽象方法。<br>7）与子类继承抽象父类相似，当类实现了某个接口时，它必须实现接口中所有的抽象方法，否则这个类必须被定义为抽象类。<br>8）一个类只能继承一个直接的父类，但能实现多个接口。<h4 id=\"h4--\"><a name=\"六、抽象类和接口的区别\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>六、抽象类和接口的区别</h4>1）抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract方法；<br>2）抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；<br>3）接口中不能含有静态代码块以及静态方法，而抽象类尅有静态代码块和静态方法；<br>4）一个类只能继承一个抽象类，而一个类却可以实现多个接口。<br>5）抽象类中的方法子类必须全部实现，不然子类也是抽象类，而接口中的抽象方法子类必须全部实现，是可选择实现的。<br>6）抽象类是一种模板设计模式，而接口时一种行为规范。</li></ol>','2017-03-02',1,32,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(394,'2017-03-03学习笔记','一、String StringBuffer.toString()源码： @Override\r\npublic synchronized String toString() {\r\n    if (toStringCache == null) {\r\n        toStringCache = Arrays.copyOfRange(value, 0, count);\r\n    }\r\n    retur','<h4 id=\"h4--string\"><a name=\"一、String\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、String</h4><p>StringBuffer.toString()源码：</p>\r\n<pre><code class=\"lang-java\">@Override\r\npublic synchronized String toString() {\r\n    if (toStringCache == null) {\r\n        toStringCache = Arrays.copyOfRange(value, 0, count);\r\n    }\r\n    return new String(toStringCache, true);\r\n}\r\n</code></pre>\r\n<p>Arrays.copyOfRange用的是System.arraycopy</p>\r\n<pre><code class=\"lang-java\">public static char[] copyOfRange(char[] original, int from, int to) {\r\n        int newLength = to - from;\r\n        if (newLength &lt; 0)\r\n            throw new IllegalArgumentException(from + &quot; &gt; &quot; + to);\r\n        char[] copy = new char[newLength];\r\n        System.arraycopy(original, from, copy, 0,\r\n                         Math.min(original.length - from, newLength));\r\n        return copy;\r\n    }\r\n</code></pre>\r\n<p>1.String是值传入，不是引用传入。<br>2.String对String  类型进行改变的时候其实都等同于生成了一个新的  String  对象，然后将指针指向新的  String  对象，而不是StringBuffer；StringBuffer每次结果都会对  StringBuffer  对象本身进行操作，而不是生成新的对象，再改变对象引用。<br>3.效率比较String&lt;StringBuffer&lt;StringBuilder，但是在 String S1 = “This is only a” + “ simple” + “ test”时，String效率最高。</p>\r\n<h4 id=\"h4--jvm-\"><a name=\"二、jvm知识图谱\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、jvm知识图谱</h4><p><a href=\"https://zhuanlan.zhihu.com/p/25511795\">引用自知乎</a><br><img src=\"https://pic2.zhimg.com/v2-701563ac1fe745fc8e1234c96e82ac99_r.jpg\" alt=\"\"></p>\r\n<h4 id=\"h4--treemap-linkhashmap\"><a name=\"三、Treemap、LinkHashMap\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、Treemap、LinkHashMap</h4><p>1.TreeMap取出来的是排序后的键值对。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。<br>2.LinkedHashMap 是HashMap的一个子类，如果需要输出的顺序和输入的相同,那么用LinkedHashMap可以实现,它还可以按读取顺序来排列。</p>\r\n<h4 id=\"h4--sql-\"><a name=\"四、sql模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>四、sql模式</h4><p>MySQL数据库中，变量分为 系统变量（以”@@”开头）和用户自定义变量。系统变量分为全局系统变量(global)和会话系统变量(session)。<br>@<a href=\"https://github.com/global\" title=\"&#64;global\" class=\"at-link\">@global</a>     仅用于访问全局系统变量的值；<br>@<a href=\"https://github.com/session\" title=\"&#64;session\" class=\"at-link\">@session</a>  仅用于访问会话系统变量的值；<br>@@              先访问会话系统变量的值，若不存在则去访问全局系统变量的值；<br>sql_mode 为系统变量，既是全局系统变量，又是会话系统变量。</p>\r\n<h4 id=\"h4--\"><a name=\"五、代码的执行顺序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>五、代码的执行顺序</h4><p>父类Ｂ静态代码块-&gt;子类Ａ静态代码块-&gt;父类Ｂ非静态代码块-&gt;父类Ｂ构造函数-&gt;子类Ａ非静态代码块-&gt;子类Ａ构造函数<br><img src=\"http://ohlrxdl4p.bkt.clouddn.com/images/QQ截图20170303165728.jpg\" alt=\"\"></p>','2017-03-03',1,33,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(395,'ifhifhajfe','hello','<h1 id=\"h1-hello\"><a name=\"hello\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>hello</h1>','2017-03-05',1,33,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(396,'2017-03-05学习笔记','java的堆，栈，静态代码区（常量区） 详解','<p><a href=\"http://blog.csdn.net/u012031380/article/details/54981472\"> java的堆，栈，静态代码区（常量区） 详解</a></p>','2017-03-05',1,32,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(397,'java归并排序','package datastruct;\r\n\r\n/**\r\n * Created by Zephery on 2017/3/3.\r\n */\r\npublic class Solution {\r\n    public static void printArray(int[] arr, int i, int j) {\r\n        System.out.print(\"[\");\r\n        for','<pre><code class=\"lang-java\">package datastruct;\r\n\r\n/**\r\n * Created by Zephery on 2017/3/3.\r\n */\r\npublic class Solution {\r\n    public static void printArray(int[] arr, int i, int j) {\r\n        System.out.print(&quot;[&quot;);\r\n        for (int k = i; k &lt; j; k++) {\r\n            System.out.print(arr[k] + &quot;,&quot;);\r\n        }\r\n        System.out.print(arr[j] + &quot;]&quot;);\r\n    }\r\n\r\n    private static void mergesort(int[] arr, int i, int j) {\r\n        int mid = 0;\r\n        if (i &lt; j) {\r\n            mid = (i + j) / 2;\r\n            mergesort(arr, i, mid);\r\n            mergesort(arr, mid + 1, j);\r\n            merge(arr, i, mid, j);\r\n        }\r\n    }\r\n\r\n    private static void merge(int[] arr, int i, int mid, int j) {\r\n        System.out.print(&quot;Left:&quot;);\r\n        printArray(arr, i, mid);\r\n        System.out.println(&quot;Right:&quot;);\r\n        printArray(arr, mid + 1, j);\r\n        System.out.println();\r\n        int temp[] = new int[arr.length];\r\n        int l = i;\r\n        int r = j;\r\n        int m = mid + 1;\r\n        int k = l;\r\n        while (l &lt;= mid &amp;&amp; m &lt;= r) {\r\n            if (arr[l] &lt;= arr[m]) {\r\n                temp[k++] = arr[l++];\r\n            } else {\r\n                temp[k++] = arr[m++];\r\n            }\r\n        }\r\n        while (l &lt;= mid) {\r\n            temp[k++] = arr[l++];\r\n        }\r\n        while (m &lt;= r) {\r\n            temp[k++] = arr[m++];\r\n        }\r\n        for (int i1 = i; i1 &lt;= j; i1++) {\r\n            arr[i1] = temp[i1];\r\n        }\r\n        System.out.print(&quot;After Merge:&quot;);\r\n        printArray(arr, i, j);\r\n        System.out.println();\r\n    }\r\n\r\n    public static void main(String args[]) {\r\n        int[] arr = {9, 4, 8, 3, 1, 2, 5};\r\n        System.out.print(&quot;Initial Array:&quot;);\r\n        printArray(arr, 0, arr.length - 1);\r\n        System.out.println();\r\n        mergesort(arr, 0, arr.length - 1);\r\n    }\r\n}\r\n</code></pre>\r\n<pre><code class=\"lang-js\">Initial Array:[9,4,8,3,1,2,5]\r\nLeft:[9]Right:\r\n[4]\r\nAfter Merge:[4,9]\r\nLeft:[8]Right:\r\n[3]\r\nAfter Merge:[3,8]\r\nLeft:[4,9]Right:\r\n[3,8]\r\nAfter Merge:[3,4,8,9]\r\nLeft:[1]Right:\r\n[2]\r\nAfter Merge:[1,2]\r\nLeft:[1,2]Right:\r\n[5]\r\nAfter Merge:[1,2,5]\r\nLeft:[3,4,8,9]Right:\r\n[1,2,5]\r\nAfter Merge:[1,2,3,4,5,8,9]\r\n</code></pre>','2017-03-06',1,34,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(398,'2017-03-10学习笔记','1.Integer和int，装箱拆箱 1、基本型和基本型封装型进行“==”运算符的比较，基本型封装型将会自动拆箱变为基本型后再进行比较，因此Integer(0)会自动拆箱为int类型再进行比较，显然返回true； 2、两个Integer类型进行“==”比较，如果其值在-128至127，那么返回true，否则返回false, 这跟Integer.valueOf()的缓冲对象有关，这里不进行赘述。 3','<h1 id=\"h1-1-integer-int-\"><a name=\"1.Integer和int，装箱拆箱\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.Integer和int，装箱拆箱</h1><p>1、基本型和基本型封装型进行“==”运算符的比较，基本型封装型将会自动拆箱变为基本型后再进行比较，因此Integer(0)会自动拆箱为int类型再进行比较，显然返回true；<br>2、两个Integer类型进行“==”比较，如果其值在-128至127，那么返回true，否则返回false, 这跟Integer.valueOf()的缓冲对象有关，这里不进行赘述。<br>3、两个基本型的封装型进行equals()比较，首先equals()会比较类型，如果类型相同，则继续比较值，如果值也相同，返回true<br>4、基本型封装类型调用equals(),但是参数是基本类型，这时候，先会进行自动装箱，基本型转换为其封装类型，再进行3中的比较。</p>\r\n<pre><code class=\"lang-java\">int a=257;\r\nInteger b=257;\r\nInteger c=257;\r\nInteger b2=57;\r\nInteger c2=57;\r\nSystem.out.println(a==b);\r\n//System.out.println(a.equals(b));  编译出错，基本型不能调用equals()\r\nSystem.out.println(b.equals(257.0));\r\nSystem.out.println(b==c);\r\nSystem.out.println(b2==c2);\r\n</code></pre>\r\n<p>因此上面的代码的结果因此为 true, false, false, true</p>\r\n<h1 id=\"h1-2-\"><a name=\"2.线程调度\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.线程调度</h1><p>分为协同式调度和抢占式调度，Java使用的是抢占式调度，也就是每个线程将由操作系统来分配执行时间，线程的切换不由线程本身来决定（协同式调度）。这就是平台独立的原因。</p>\r\n<h1 id=\"h1-3-\"><a name=\"3.重载，重写\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.重载，重写</h1><p>重写：<br>两同，两小，一大<br>两同：方法名，方法参数列表相同。<br>两小：抛出的异常类型要小于等于父类，返回值类型要小于等于父类<br>一大：访问权限大于等于父类。<br>重载：<br>在同一个类中，方法名和方法参数列表不同，其他的（访问权限、返回值）随意。</p>\r\n<h1 id=\"h1-4-jvm-\"><a name=\"4.  JVM面试题\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.<a href=\"http://blog.csdn.net/hsk256/article/details/49104955\">JVM面试题</a></h1>','2017-03-10',1,27,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(399,'2017-03-12学习笔记','1.继承的加载顺序 执行顺序大体上可以说是先父类后子类，父类static域 ==》子类static域 ==》父类数据成员域 ==》父类构造器 ==》子类数据成员域 ==》子类构造器 2.优化Hibernate所鼓励的7大措施： 1.尽量使用many-to-one，避免使用单项one-to-many 2.灵活使用单向one-to-many 3.不用一对一，使用多对一代替一对一 4.配置对象缓存，不使','<h4 id=\"h4-1-\"><a name=\"1.  继承的加载顺序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.<a href=\"http://www.cnblogs.com/SirSmith/p/5536288.html\">继承的加载顺序</a></h4><p><img src=\"http://images2015.cnblogs.com/blog/452847/201605/452847-20160527221410288-2119099273.png\" alt=\"\"></p>\r\n<p>执行顺序大体上可以说是先父类后子类，父类static域 ==》子类static域 ==》父类数据成员域 ==》父类构造器 ==》子类数据成员域 ==》子类构造器</p>\r\n<h4 id=\"h4-2-hibernate-7-\"><a name=\"2.优化Hibernate所鼓励的7大措施：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.优化Hibernate所鼓励的7大措施：</h4><p>1.尽量使用many-to-one，避免使用单项one-to-many<br>2.灵活使用单向one-to-many<br>3.不用一对一，使用多对一代替一对一<br>4.配置对象缓存，不使用集合缓存<br>5.一对多使用Bag 多对一使用Set<br>6.继承使用显示多态 HQL:from object polymorphism=”exlicit” 避免查处所有对象<br>7.消除大表，使用二级缓存</p>\r\n<h4 id=\"h4-3-java-\"><a name=\"3.java中的数据类型分类：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.java中的数据类型分类：</h4><p>基本数据类型（或叫做原生类、内置类型）8种：<br>    整数：byte，short，int，long（默认是int类型）<br>    浮点类型： float，double（默认是double类型）<br>    字符类型：char<br>    布尔类型：boolean<br>引用数据类型3种：数组，类，接口</p>\r\n<h4 id=\"h4-4-\"><a name=\"4.触发器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.触发器</h4><p>drop trigger 删除触发器<br>Drop用于删除数据表或数据库，或删除数据表字段。<br>remove：删除数据库文件<br>Truncate：删除数据表中的数据（仅数据表中的数据，不删除表）。</p>','2017-03-12',1,23,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(400,'2017-03-14学习笔记','1.Servlet的生命周期分为5个阶段：加载、创建、初始化、处理客户请求、卸载。 (1)加载：容器通过类加载器使用servlet类对应的文件加载servlet (2)创建：通过调用servlet构造函数创建一个servlet对象 (3)初始化：调用init方法初始化 (4)处理客户请求：每当有一个客户请求，容器会创建一个线程来处理客户请求 (5)卸载：调用destroy方法让servlet自己释','<h4 id=\"h4-1-servlet-5-\"><a name=\"1.Servlet的生命周期分为5个阶段：加载、创建、初始化、处理客户请求、卸载。\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.Servlet的生命周期分为5个阶段：加载、创建、初始化、处理客户请求、卸载。</h4><p>(1)加载：容器通过类加载器使用servlet类对应的文件加载servlet<br>(2)创建：通过调用servlet构造函数创建一个servlet对象<br>(3)初始化：调用init方法初始化<br>(4)处理客户请求：每当有一个客户请求，容器会创建一个线程来处理客户请求<br>(5)卸载：调用destroy方法让servlet自己释放其占用的资源</p>\r\n<h4 id=\"h4-2-jsp\"><a name=\"2.JSP\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.JSP</h4><p><img src=\"http://uploadfiles.nowcoder.com/images/20160308/595432_1457414324036_C3D4EB7F2D61708D0C0BE2921A45B74D\" alt=\"\"></p>','2017-03-14',1,17,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(401,'2017-03-17学习笔记','1.GC线程是否和守护线程 2.java堆排序','<h4 id=\"h4-1-gc-\"><a name=\"1.GC线程是否和守护线程\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.GC线程是否和守护线程</h4><h4 id=\"h4-2-java-\"><a name=\"2.java堆排序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.java堆排序</h4>','2017-03-17',1,18,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(402,'春招~好失落啊','自己的情况：广东人，大学跑到天津一所二本学校，网络工程专业，大一大二学ccna、ccnp，发现没有创造性，按着别人的死规定敲命令好无聊，大三彻底转向编程，c++看着不爽，调研一番后选择java，自学java和java web，对jsp、servlet略过，直接上手框架（Struts，hibernate，spring），看书，找视频，敲项目，非专业课（操作系统，数据库等）不听，捣鼓一番觉得还行，继续','<p>自己的情况：广东人，大学跑到天津一所二本学校，网络工程专业，大一大二学ccna、ccnp，发现没有创造性，按着别人的死规定敲命令好无聊，大三彻底转向编程，c++看着不爽，调研一番后选择java，自学java和java web，对jsp、servlet略过，直接上手框架（Struts，hibernate，spring），看书，找视频，敲项目，非专业课（操作系统，数据库等）不听，捣鼓一番觉得还行，继续学习spring mvc，mybatis，开始了解hadoop、spark，同时搭了自己的网站，跟了软件工程的同学比了比，还能算上前列吧，当然，基础和算法跟前列的人还没得比~~~</p>\r\n<p>去年秋招，腾讯、阿里等笔试全挂，京东的没怎么做却过了，不敢去面试（真心没怎么做题），最后去了北京一家创业公司实习了三个月多，感觉真心好，12月几乎整整一个月雾霾，受不了，还是回广东吧。在家过了春节，2月10号跟同学一起来深圳，就这样，开始了春招之旅~~~~</p>\r\n<p>第一家，面试的问的差不多全答对，手写了几个sql也对了，不过居然没有问hashmap，给的工资6000到9000，想了想，还是不去的好，太郊区，后来一查，是个培训兼外包的企业，还好没去。。。。</p>\r\n<p>第二家，某ERP公司，额，笔试，全是sql，做了，感觉还可以，面试直接说我们公司不用java，用的一个小众语言，薪资应届生只有3500，直接走人。。。。</p>\r\n<p>第三家，找工作，对广东真是彻底失望了，投的简历除了培训机构理你，其他的都不理人的，无奈之下投了北京的一家创业公司（A轮），薪资1万，电话面试，过了。。。。。后来想想，还是不去北京了，虽然工资高，但是没有朋友，过得像个死人一样。</p>\r\n<p>第四家，深圳一家创业公司，做东南亚社交软件的，可惜薪资没谈成，4K-6K，这可是深圳啊。。。。</p>\r\n<p>第五家，广州凡科，那天一早就从深圳跑过去，没吃饭，下午到就做笔试题，头晕，手抖，然后一面就是跟你讲笔试题，讲了两道，就叫我走了。。。仅仅半个小时，广深来回6个小时。。。</p>\r\n<p>第六家，广州某搞运维的公司，笔试差不多答对，面试问的问题也答对，但是没给offer。。。不理解</p>\r\n<p>第七家，然后晚上跑去了广工的久邦数码宣讲，试卷发到我这的时候，HR说我这方向的试卷没带够。。。。无奈向他要了大数据的题，全是数据库的题，过几天后得知居然过了，然后一面，问的问题没啥印象，除了left join的原理没答对。。。今天得知挂了。。。。</p>\r\n<p><img src=\"http://images2015.cnblogs.com/blog/755525/201703/755525-20170318000537838-305991370.png\" alt=\"\"></p>\r\n<p>第八家，极天信息（A轮），笔试的题目没看懂它问的啥，一面没啥印象了，然后是经理面，说广州没那么高的工资（7000），等消息，估计也没谈成。。。。</p>\r\n<p>第九家，中国移动，最气的了，一面就是HR面，问了两个问题，为什么不在北京留着，你觉得相比其他人你有什么优势。我只能说我真不会说话更不知怎么回答，就强调勤奋，然后直接被HR叫走人了，3分钟=w=</p>\r\n<p>第十家，珍爱网，找别人内推的，三个问题没答上来，就不跟你们说了，亲爱的竞争对手们=w=，谈了四十分钟吧，出来后感觉很不好，估计也是挂了。。。</p>\r\n<p>今天晚上，收到了久邦数码的拒绝信，瞬间觉得好无奈好迷茫，有时候就那么一个简简单单的问题，答不好就直接拒绝的，改怎么心平气和的面对下一个面试。有时候真不理解公司是怎么招人的，是不是真的“把部分简历扔进垃圾桶，不招那些运气不好的人”？也只能这么安慰自己。可是，事实呢？</p>\r\n<p><img src=\"http://images2015.cnblogs.com/blog/755525/201703/755525-20170318001336463-1583022291.jpg\" alt=\"\"></p>\r\n<p>这些天，有时间都是往深圳图书馆跑，看书，刷牛客网，补算法，看源码，做了这么多，该怎么告诉自己不要放弃。。。。。开始有点想念北京的雾霾</p>','2017-03-18',5,19,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(403,'数据库','1.SQL执行的顺序 2.NULL “空值” 和”NULL”的概念： 1：空值(‘’)是不占用空间的,判断空字符用 = ‘’ 或者 <> ‘’ 来进行处理; 2: NULL值是未知的，且占用空间，不走索引;判断 NULL 用 IS NULL 或者 is not null , SQL 语句函数中可以使用 ifnull ()函数来进行处理. 注：在进行 count ()统计某列的记录数的时候，如果采用','<h4 id=\"h4-1-sql-\"><a name=\"1.SQL执行的顺序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.SQL执行的顺序</h4><p><img src=\"http://uploadfiles.nowcoder.com/images/20150828/415611_1440751995009_3B3E1329A400F0022B20C4F32AEFC9EF\" alt=\"\"></p>\r\n<h4 id=\"h4-2-null\"><a name=\"2.NULL\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.NULL</h4><p>“空值” 和”NULL”的概念：<br>  1：空值(‘’)是不占用空间的,判断空字符用 = ‘’ 或者 &lt;&gt; ‘’ 来进行处理;<br> 2: NULL值是未知的，且占用空间，不走索引;判断 NULL 用 IS NULL 或者 is not null , SQL 语句函数中可以使用 ifnull ()函数来进行处理.<br>注：在进行 count ()统计某列的记录数的时候，如果采用的 NULL 值，会别系统自动忽略掉，但是空值是统计到其中</p>\r\n<h4 id=\"h4-3-\"><a name=\"3.\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.</h4><p>在MySQL数据库中，NULL对于一些特殊类型的列来说，其代表了一种特殊的含义，而不仅仅是一个空值。<br>IS NULL: 此运算符返回true，当列的值是NULL。<br>IS NOT NULL: 运算符返回true，当列的值不是NULL。<br>&lt;=&gt; 操作符比较值（不同于=运算符）为ture，即使两个NULL值<br>涉及NULL条件是特殊的。不能使用 =NULL 或 !=NULL 寻找NULL值的列</p>\r\n<h4 id=\"h4-4-nf\"><a name=\"4.NF\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.NF</h4><p>第一范式（   1NF   ）：   字段具有   原子性   ,   不可再分   。所有关系型数据库系统都满足第一范式）数据库表中的字段都是单一属性的，不可再分。例如，姓名字段，其中的姓和名必须作为一个整体，无法区分哪部分是姓，哪部分是名，如果要区分出姓和名，必须设计成两个独立的字段。<br>第二范式（   2NF   ）：   第二范式（   2NF   ）是在   第一范式（   1NF   ）的基础上   建立起来的，即满足第二范式（   2NF   ）必须先满足第一范式（   1NF   ）。要求   数据库表中的每个实例或行必须可以被惟一地区分   。通常需要为表加上一个列，以存储各个实例的惟一标识。这个惟一属性列被称为   主关键字或主键   。<br>        第二范式（   2NF   ）要求   实体的属性完全依赖于主关键字   。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。简而言之，第二范式就是非主属性非部分依赖于主关键字。<br>第三范式 （  3NF  ） ：   满足第三范式（   3NF   ）   必须先满足第二范式（   2NF   ）   。简而言之，第三范式（   3NF   ）要求一个数据库表中   不包含   已在其它表中   已包含的非主关键字信息   。所以第三范式具有如下特征：<br>1   ，每一列只有一个值<br>2   ，每一行都能区分。<br>3   ，每一个表都   不包含其他表已经包含   的非主关键字信息。<br>例如，帖子表中只能出现发帖人的   id   ，而不能出现发帖人的   id   ，还同时出现发帖人姓名，否则，只要出现同一发帖人   id   的所有记录，它们中的姓名部分都必须严格保持一致，这就是   数据冗余   。</p>','2017-03-18',3,19,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(404,'重载与重写','目前的问题：父类的功能无法满足子类的需求。 方法重写的前提： 必须要存在继承的关系。 方法的重写: 子父类出了同名的函数，这个我们就称作为方法的重写。 什么是时候要使用方法的重写：父类的功能无法满足子类的需求时。 方法重写要注意的事项： 1.方法重写时， 方法名与形参列表必须一致。 2.方法重写时，子类的权限修饰符必须要大于或者等于父类的权限修饰符。 3.方法重写时，子类的返回值类型必须要小于或者','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><p>目前的问题：父类的功能无法满足子类的需求。</p>\n<p>方法重写的前提： 必须要存在继承的关系。</p>\n<p>方法的重写: 子父类出了同名的函数，这个我们就称作为方法的重写。</p>\n<p>什么是时候要使用方法的重写：父类的功能无法满足子类的需求时。</p>\n<p>方法重写要注意的事项：<br>    1.方法重写时， 方法名与形参列表必须一致。<br>    2.方法重写时，子类的权限修饰符必须要大于或者等于父类的权限修饰符。<br>    3.方法重写时，子类的返回值类型必须要小于或者 等于父类的返回值类型。<br>    4.方法重写时， 子类抛出的异常类型要小于或者等于父类抛出的异常类型。<br>            Exception(最坏)<br>            RuntimeException(小坏)</p>\n<p>方法的重载：在一个类中 存在两个或者两个 以上的同名函数,称作为方法重载。</p>\n<p>方法重载的要求</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"lit\">1.</span><span class=\"pln\"> </span><span class=\"pun\">函数名要一致。</span></code></li><li class=\"L1\"><code><span class=\"lit\">2.</span><span class=\"pln\"> </span><span class=\"pun\">形参列表不一致（形参的个数或形参</span><span class=\"pln\"> </span><span class=\"pun\">的类型不一致）</span></code></li><li class=\"L2\"><code><span class=\"lit\">3.</span><span class=\"pln\"> </span><span class=\"pun\">与返回值类型无关。</span></code></li></ol></pre></div>','2017-03-21',1,19,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(405,'垃圾回收算法','垃圾回收算法 1、标记-清除算法 2、复制算法 3、标记-整理算法 一、标记-清除算法 标记-清除算法采用从根集合进行扫描，对存活的对象对象标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收，如上图所示。 标记-清除算法不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效，但由于标记-清除算法直接回收不存活的对象，因此会造成内存碎片！ 二、复制算法 复制算法','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h2 id=\"h2-u5783u573Eu56DEu6536u7B97u6CD5\"><a name=\"垃圾回收算法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>垃圾回收算法</h2><p>1、标记-清除算法<br>2、复制算法<br>3、标记-整理算法</p>\n<h4 id=\"h4--\"><a name=\"一、标记-清除算法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、标记-清除算法</h4><p><img src=\"http://dl2.iteye.com/upload/attachment/0075/0386/29ae17ad-f8af-38b4-9e25-28ef3550858f.jpg\" alt=\"\">标记-清除算法采用从根集合进行扫描，对存活的对象对象标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收，如上图所示。<br>标记-清除算法不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效，但由于标记-清除算法直接回收不存活的对象，因此会造成内存碎片！</p>\n<h4 id=\"h4--\"><a name=\"二、复制算法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、复制算法</h4><p><img src=\"http://dl2.iteye.com/upload/attachment/0075/0388/91a656d4-f08a-377b-8eea-5785c2932533.jpg\" alt=\"\"><br>复制算法采用从根集合扫描，并将存活对象复制到一块新的，没有使用过的空间中，这种算法当控件存活的对象比较少时，极为高效，但是带来的成本是需要一块内存交换空间用于进行对象的移动。也就是我们前面提到的s0 s1等空间。</p>\n<h4 id=\"h4--\"><a name=\"三、标记-整理算法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、标记-整理算法</h4><p><img src=\"http://dl2.iteye.com/upload/attachment/0075/0390/6ba95f80-c7bc-3d09-b927-ac09297e9920.jpg\" alt=\"\"><br> 标记-整理算法采用标记-清除算法一样的方式进行对象的标记，但在清除时不同，在回收不存活的对象占用的空间后，会将所有的存活对象往左端空闲空间移动，并更新对应的指针。标记-整理算法是在标记-清除算法的基础上，又进行了对象的移动，因此成本更高，但是却解决了内存碎片的问题。</p>\n</div>','2017-04-09',1,20,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(406,'java分代回收','一、新生代内存的回收（minor GC）主要采用复制算法，下图展示了minor GC的执行过程。 二、对于新生代和旧生代，JVM可使用很多种垃圾回收器进行垃圾回收，下图展示了不同生代不通垃圾回收器，其中两个回收器之间有连线表示这两个回收器可以同时使用。 而这些垃圾回收器又分为串行回收方式、并行回收方式合并发回收方式执行，分别运用于不同的场景。如下图所示 三、收集器 1.Serial收集器 看名字我','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h2 id=\"h2--minor-gc-minor-gc-\"><a name=\"一、新生代内存的回收（minor GC）主要采用复制算法，下图展示了minor GC的执行过程。\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、新生代内存的回收（minor GC）主要采用复制算法，下图展示了minor GC的执行过程。</h2><p><img src=\"http://dl2.iteye.com/upload/attachment/0075/0392/732c7557-aa9a-3551-b14d-f543c5b0c94b.jpg\" alt=\"\"></p>\n<h2 id=\"h2--jvm-\"><a name=\"二、对于新生代和旧生代，JVM可使用很多种垃圾回收器进行垃圾回收，下图展示了不同生代不通垃圾回收器，其中两个回收器之间有连线表示这两个回收器可以同时使用。\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、对于新生代和旧生代，JVM可使用很多种垃圾回收器进行垃圾回收，下图展示了不同生代不通垃圾回收器，其中两个回收器之间有连线表示这两个回收器可以同时使用。</h2><p><img src=\"http://dl2.iteye.com/upload/attachment/0075/0394/0172f624-9018-3642-bf26-05a2c3071639.jpg\" alt=\"\"><br>而这些垃圾回收器又分为串行回收方式、并行回收方式合并发回收方式执行，分别运用于不同的场景。如下图所示<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0396/c962c2ad-273f-3de4-b2e3-a4dd8b946215.jpg\" alt=\"\"></p>\n<h2 id=\"h2--\"><a name=\"三、收集器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、收集器</h2><h4 id=\"h4-1-serial-\"><a name=\"1.Serial收集器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.Serial收集器</h4><p>看名字我们都可以看的出来，这个属于串行收集器。其运行示意图如下<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0398/681da5ca-5eff-3984-bece-3d80dfe905be.jpg\" alt=\"\"><br>    收集器是历史最悠久的一个回收器，JDK1.3之前广泛使用这个收集器，目前也是ClientVM下 ServerVM 4核4GB以下机器的默认垃圾回收器。串行收集器并不是只能使用一个CPU进行收集，而是当JVM需要进行垃圾回收的时候，需要中断所有的用户线程，知道它回收结束为止，因此又号称“Stop The World” 的垃圾回收器。注意，JVM中文名称为java虚拟机，因此它就像一台虚拟的电脑一样在工作，而其中的每一个线程就被认为是JVM的一个处理器，因此大家看到图中的CPU0、CPU1实际为用户的线程，而不是真正机器的CPU，大家不要误解哦。<br>    串行回收方式适合低端机器，是Client模式下的默认收集器，对CPU和内存的消耗不高，适合用户交互比较少，后台任务较多的系统。<br>    Serial收集器默认新旧生代的回收器搭配为Serial+ SerialOld</p>\n<h4 id=\"h4-2-parnew-\"><a name=\"2.ParNew收集器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.ParNew收集器</h4><p>ParNew收集器其实就是多线程版本的Serial收集器，其运行示意图如下<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0400/6443b39c-ed33-3d93-a690-87e646439561.jpg\" alt=\"\"><br>同样有Stop The World的问题，他是多CPU模式下的首选回收器（该回收器在单CPU的环境下回收效率远远低于Serial收集器，所以一定要注意场景哦），也是Server模式下的默认收集器。</p>\n<h4 id=\"h4-3-parallelscavenge\"><a name=\"3.ParallelScavenge\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.ParallelScavenge</h4><p>ParallelScavenge又被称为是吞吐量优先的收集器，器运行示意图如下<br><img src=\"http://dl.iteye.com/upload/attachment/0075/0402/5007beba-0b0e-3cf4-b146-c28b6c0dd696.jpg\" alt=\"\"><br> ParallelScavenge<br>所提到的吞吐量=程序运行时间/(JVM执行回收的时间+程序运行时间),假设程序运行了100分钟，JVM的垃圾回收占用1分钟，那么吞吐量就是99%。在当今网络告诉发达的今天，良好的响应速度是提升用户体验的一个重要指标，多核并行云计算的发展要求程序尽可能的使用CPU和内存资源，尽快的计算出最终结果，因此在交互不多的云端，比较适合使用该回收器。</p>\n<h4 id=\"h4-4-parallelold\"><a name=\"4.ParallelOld\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.ParallelOld</h4><p>ParallelOld是老生代并行收集器的一种，使用标记整理算法、是老生代吞吐量优先的一个收集器。这个收集器是JDK1.6之后刚引入的一款收集器，我们看之前那个图之间的关联关系可以看到，早期没有ParallelOld之前，吞吐量优先的收集器老生代只能使用串行回收收集器，大大的拖累了吞吐量优先的性能，自从JDK1.6之后，才能真正做到较高效率的吞吐量优先。其运行示意图如下<br><img src=\"http://dl.iteye.com/upload/attachment/0075/0406/9a14da85-f943-3408-ba88-c6bb3842a792.jpg\" alt=\"\"></p>\n<h4 id=\"h4-5-serialold\"><a name=\"5.SerialOld\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.SerialOld</h4><p>SerialOld是旧生代Client模式下的默认收集器，单线程执行；在JDK1.6之前也是ParallelScvenge回收新生代模式下旧生代的默认收集器，同时也是并发收集器CMS回收失败后的备用收集器。其运行示意图如下<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0404/ce7aabd5-b0e0-3cda-9b6c-607cf6ebf689.jpg\" alt=\"\"></p>\n<h4 id=\"h4-5-cms\"><a name=\"5.CMS\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.CMS</h4><p>CMS又称响应时间优先(最短回收停顿)的回收器，使用并发模式回收垃圾，使用标记-清除算法，CMS对CPU是非常敏感的，它的回收线程数=（CPU+3）/4，因此当CPU是2核的实惠，回收线程将占用的CPU资源的50%，而当CPU核心数为4时仅占用25%。他的运行示意图如下<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0408/4239228b-879f-382f-81c6-5c32799886d6.jpg\" alt=\"\"><br>模式主要分为四个过程：<br>1.初始标记<br>2.并发标记<br>3.重新标记<br>4.并发清除<br>在初始标记的时候，需要中断所有用户线程，在并发标记阶段，用户线程和标记线程<br>并发执行，而在这个过程中，随着内存引用关系的变化，可能会发生原来标记的对象被释放，进而引发新的垃圾，因此可能会产生一系列的浮动垃圾，不能被回收。</p>\n<p>CMS 为了确保能够扫描到所有的对象，避免在Initial Marking 中还有未标识到的对象，采用的方法为找到标记了的对象，并将这些对象放入Stack 中，扫描时寻找此对象依赖的对象，如果依赖的对象的地址在其之前，则将此对象进行标记，并同时放入Stack 中，如依赖的对象地址在其之后，则仅标记该对象。<br>在进行Concurrent Marking 时minor GC 也可能会同时进行，这个时候很容易造成旧生代对象引用关系改变，CMS 为了应对这样的并发现象，提供了一个Mod Union Table 来进行记录，在这个Mod Union Table中记录每次minor GC 后修改了的Card 的信息。这也是ParallelScavenge不能和CMS一起使用的原因。<br>CMS产生浮动垃圾的情况请见如下示意图<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0410/60e7c659-790a-3405-af70-9ca4cfd9258d.jpg\" alt=\"\"><br>在运行回收过后，c就变成了浮动垃圾。<br>由于CMS会产生浮动垃圾，当回收过后，浮动垃圾如果产生过多，同时因为使用标记-清除算法会产生碎片，可能会导致回收过后的连续空间仍然不能容纳新生代移动过来或者新创建的大资源，因此会导致CMS回收失败，进而触发另外一次FULL GC，而这时候则采用SerialOld进行二次回收。<br>同时CMS因为可能产生浮动垃圾，而CMS在执行回收的同时新生代也有可能在进行回收操作，为了保证旧生代能够存放新生代转移过来的数据，CMS在旧生代内存到达全部容量的68%就触发了CMS的回收！</p>\n<h4 id=\"h4-7-garbagefirst-g1-\"><a name=\"7.GarbageFirst(G1)\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>7.GarbageFirst(G1)</h4><p>我们再来看垃圾回收器的总图，刚才我们可以看到，我在图上标记了一个？，其实这是一个新的垃圾回收器，既可以回收新生代也可以回收旧生代，SunHotSpot 1.6u14以上EarlyAccess版本加入了这个回收器，sun公司预期SunHotSpot1.7发布正式版，他是商用高性能垃圾回收器，通过重新划分内存区域，整合优化CMS，同时注重吞吐量和响应时间，但是杯具的是被Oracle收购之后这个收集器属于商用收费收集器，因此目前基本上没有人使用，我们在这里也就不多介绍，更多信息可以参考oracle新版本JDK说明。</p>\n</div>','2017-04-09',1,24,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(407,'java汇编','java 汇编 http://download.csdn.net/download/jiangfuqiang/8403497','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><p>java 汇编<br><a href=\"http://download.csdn.net/download/jiangfuqiang/8403497\">http://download.csdn.net/download/jiangfuqiang/8403497</a></p>\n</div>','2017-04-10',1,24,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(408,'jvm','-XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><p>-XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly</p>\n</div>','2017-04-10',1,25,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(409,'Adaboost','NaiveBayesSpamFilter 利用朴素贝叶斯算法实现垃圾邮件的过滤，并结合Adaboost改进该算法。 1 Naive Bayes spam filtering   假设邮件的内容中包含的词汇为Wi，垃圾邮件Spam，正常邮件ham。 判断一份邮件，内容包含的词汇为Wi，判断该邮件是否是垃圾邮件，即计算P（S|Wi）这个条件概率。根据Bayes’ theorem：   Bayes’ t','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h1 id=\"h1-naivebayesspamfilter\"><a name=\"NaiveBayesSpamFilter\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>NaiveBayesSpamFilter</h1><p>利用朴素贝叶斯算法实现垃圾邮件的过滤，并结合Adaboost改进该算法。</p>\n<h3 id=\"h3-1-naive-bayes-spam-filtering\"><a name=\"1 Naive Bayes spam filtering\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1 Naive Bayes spam filtering</h3><p>  假设邮件的内容中包含的词汇为Wi，垃圾邮件Spam，正常邮件ham。 判断一份邮件，内容包含的词汇为Wi，判断该邮件是否是垃圾邮件，即计算P（S|Wi）这个条件概率。根据Bayes’ theorem：</p>\n<p>  Bayes’ theorem</p>\n<p>  其中：</p>\n<p>Pr(S|Wi) 出现词汇Wi的邮件是垃圾邮件的条件概率（即后验概率）；<br>Pr(S) 训练阶段邮件数据集中垃圾邮件的概率，或实际调查的垃圾邮件的概率（即先验概率）；<br>Pr(Wi|S) 垃圾邮件中词汇Wi出现的概率；<br>Pr(H) 训练阶段邮件数据集中正常邮件的概率，或实际调查的正常邮件的概率；<br>Pr(Wi|H) 正常邮件中词汇Wi出现的概率；<br>  对于邮件中出现的所有词汇，考虑每个词汇出现事件的独立性，计算Pr(S|Wi)的联合概率Pr(S|W)，W={W1，W2，…Wn}：</p>\n<p>  Bayes’ theorem</p>\n<p>  其中：</p>\n<p>P 即Pr(S|W)，出现词汇W={W1，W2……Wn}的邮件是垃圾邮件的条件概率；<br>Pi 即Pr(S|Wi)，出现词汇Wi的邮件是垃圾邮件的条件概率；<br>  注： 程序中，通过计算出Pr(S|W)和Pr(H|W)，比较Pr(S|W)和Pr(H|W)的大小，判断是垃圾邮件还是正常邮件。我们发现Pr(S|W)和Pr(H|W)计算的分母相同，所以我们只需要比较分子即可。</p>\n<p>  但存在两个问题：</p>\n<p>当词汇不存在时，即ni=0，此时Pr(S|Wi) = 0，会造成P=0，无法比较<br>当Pr(S|Wi)较小时，连乘操作会造成下溢出问题<br>  解决方案：</p>\n<p>计算P(Wi|S)和P(Wi|H)时，将所有词汇初始化出现的次数为1，并将分母初始化为2（或根据样本/实际调查结果调整分母的值）。</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"com\"># 统计语料库中词汇在S和H中出现的次数</span></code></li><li class=\"L1\"><code><span class=\"pln\">wordsInSpamNum </span><span class=\"pun\">=</span><span class=\"pln\"> np</span><span class=\"pun\">.</span><span class=\"pln\">ones</span><span class=\"pun\">(</span><span class=\"pln\">numWords</span><span class=\"pun\">)</span></code></li><li class=\"L2\"><code><span class=\"pln\">wordsInHealthNum </span><span class=\"pun\">=</span><span class=\"pln\"> np</span><span class=\"pun\">.</span><span class=\"pln\">ones</span><span class=\"pun\">(</span><span class=\"pln\">numWords</span><span class=\"pun\">)</span></code></li><li class=\"L3\"><code><span class=\"pln\">spamWordsNum </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">2.0</span></code></li><li class=\"L4\"><code><span class=\"pln\">healthWordsNum </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">2.0</span></code></li></ol></pre><p>计算P(Wi|S)和P(Wi|H)时，对概率取对数<br>    pWordsSpamicity = np.log(wordsInSpamNum / spamWordsNum)<br>    pWordsHealthy = np.log(wordsInHealthNum / healthWordsNum)<br>  所以最终比较的是，P(W1|S)P(W2|S)….P(Wn|S)P(S)和P(W1|H)P(W2|H)….P(Wn|H)P(H)的大小。</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"pln\">ps </span><span class=\"pun\">=</span><span class=\"pln\"> sum</span><span class=\"pun\">(</span><span class=\"pln\">testWordsMarkedArray </span><span class=\"pun\">*</span><span class=\"pln\"> pWordsSpamicity</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">+</span><span class=\"pln\"> np</span><span class=\"pun\">.</span><span class=\"pln\">log</span><span class=\"pun\">(</span><span class=\"pln\">pSpam</span><span class=\"pun\">)</span></code></li><li class=\"L1\"><code><span class=\"pln\">ph </span><span class=\"pun\">=</span><span class=\"pln\"> sum</span><span class=\"pun\">(</span><span class=\"pln\">testWordsMarkedArray </span><span class=\"pun\">*</span><span class=\"pln\"> pWordsHealthy</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">+</span><span class=\"pln\"> np</span><span class=\"pun\">.</span><span class=\"pln\">log</span><span class=\"pun\">(</span><span class=\"lit\">1</span><span class=\"pln\"> </span><span class=\"pun\">-</span><span class=\"pln\"> pSpam</span><span class=\"pun\">)</span></code></li></ol></pre><p>  测试效果： 5574个样本，采用交叉验证，随机选取4574个作为训练样本，产生词汇列表（语料库），对1000个测试样本，分类的平均错误率约为：2.5%。</p>\n<h3 id=\"h3-2-running-adaboost-on-naive-bayes\"><a name=\"2 Running Adaboost on Naive Bayes\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2 Running Adaboost on Naive Bayes</h3><p>  我们在计算ps和ph联合后验概率时，可引入一个调整因子DS，其作用是调整词汇表中某一词汇的“垃圾程度”(spamicity)，</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"pln\">ps </span><span class=\"pun\">=</span><span class=\"pln\"> sum</span><span class=\"pun\">(</span><span class=\"pln\">testWordsMarkedArray </span><span class=\"pun\">*</span><span class=\"pln\"> pWordsSpamicity </span><span class=\"pun\">*</span><span class=\"pln\"> DS</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">+</span><span class=\"pln\"> np</span><span class=\"pun\">.</span><span class=\"pln\">log</span><span class=\"pun\">(</span><span class=\"pln\">pSpam</span><span class=\"pun\">)</span></code></li></ol></pre><p>  其中DS通过Adaboost算法迭代获取最佳值。原理如下：</p>\n<p>设定adaboost循环的次数count<br>交叉验证随机选择1000个样本<br>DS初始化为和词汇列表大小相等的全一向量<br>迭代循环count次：<br>    设定最小分类错误率为inf<br>    对于每一个样本：<br>        在当前DS下对样本分类<br>        如果分类出错：<br>            计算出错的程度，即比较ps和ph的相差alpha<br>            如果样本原本是spam，错分成ham：<br>                DS[样本包含的词汇] = np.abs(DS[样本包含的词汇] - np.exp(alpha) / DS[样本包含的词汇])<br>            如果样本原本是ham，错分成spam：<br>                DS[样本包含的词汇] = DS[样本包含的词汇] + np.exp(alpha) / DS[样本包含的词汇]<br>    计算错误率<br>    保存最小的错误率和此时的词汇列表、P(Wi|S)和P(Wi|H)、DS等信息，即保存训练好的最佳模型的信息<br>  测试效果： 5574个样本，获取Adaboost算法训练的最佳模型信息（包括词汇列表、P(Wi|S)和P(Wi|H)、DS等），对1000个测试样本，分类的平均错误率约为：0.5%。</p>\n</div>','2017-04-17',4,22,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(410,'Java堆.栈和常量池 笔记','Java堆.栈和常量池 笔记','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><p><a href=\"http://www.iteye.com/topic/634530\">Java堆.栈和常量池 笔记</a></p>\n</div>','2017-04-23',1,22,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(411,'redis','redis的数据结构 数据结构类型 结构存储的值 结构的读写能力 STRING 可以是字符串、整数、或者浮点数 对整个字符串或者字符串的其中一部分执行操作；对整数和浮点数执行自增或者自减 LIST 一个链表，链表上的每个节点都包含了一个字符串 从链表的两端推入或者弹出元素；根据偏移量对链表进行修剪；根据值查找或者移除元素 SET 包含字符串的无序收集器，并且被包含的每个字符串都是独一无二、各不相同','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h1 id=\"h1-redis-\"><a name=\"redis的数据结构\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>redis的数据结构</h1><table>\n<thead>\n<tr>\n<th>数据结构类型</th>\n<th>结构存储的值</th>\n<th>结构的读写能力</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>STRING</td>\n<td>可以是字符串、整数、或者浮点数</td>\n<td>对整个字符串或者字符串的其中一部分执行操作；对整数和浮点数执行自增或者自减</td>\n</tr>\n<tr>\n<td>LIST</td>\n<td>一个链表，链表上的每个节点都包含了一个字符串</td>\n<td>从链表的两端推入或者弹出元素；根据偏移量对链表进行修剪；根据值查找或者移除元素</td>\n</tr>\n<tr>\n<td>SET</td>\n<td>包含字符串的无序收集器，并且被包含的每个字符串都是独一无二、各不相同的</td>\n<td>添加、获取、移除单个元素；检查一个元素是否存在于集合中；计算交集、并集、差集；从集合里面随机获取元素</td>\n</tr>\n<tr>\n<td>HASH</td>\n<td>包含键值对的无语散列表</td>\n<td>添加、获取、移除单个键值对；获取所有键值对</td>\n</tr>\n<tr>\n<td>ZSET(有序集合)</td>\n<td>字符串成员与浮点数分值之间的有序映射，元素的排列顺序由分值的大小决定</td>\n<td>添加、获取、单个元素；根据分值范围或者成员来获取元素</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"h3--string-\"><a name=\"一、STRING基本操作\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、STRING基本操作</h3><p>（1）SET 设置存储在给定键中的值<br>（2）GET 获取存储在给定键中的值<br>（3）DEL 删除存储在给定键中的值</p>\n<h3 id=\"h3--list-\"><a name=\"二、LIST（列表）基本操作\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、LIST（列表）基本操作</h3><p>（1）RPUSH 将给定值推入列表的右端<br>（2）LRANGE 获取列表在给定范围上的所有值<br>（3）LINDEX 获取列表在给定位置上的单个元素<br>（4）LPOP 从列表的左端弹出一个值，并返回被弹出的值</p>\n<h3 id=\"h3--set-\"><a name=\"三、SET（集合）基本操作\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>　三、SET（集合）基本操作</h3><p>（1）SADD 将给定元素添加到集合<br>（2）SMEMBERS 返回集合包含的所有元素<br>（3）SISMEMBER 检查给定元素是否存在于集合中<br>（4）SREM 如果给定的元素存在于集合中，那么移除这个元素</p>\n<h3 id=\"h3--hash-\"><a name=\"四、HASH（散列）基本操作\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>四、HASH（散列）基本操作</h3><p>（1）HSET 在散列里面关联起给定的键值对<br>（2）HGET 获取指定散列键的值<br>（3）HGETALL 获取散列包含的所有键值对<br>（4）HDEL 如果给定键存在于散列里面，那么移除这个键</p>\n<h3 id=\"h3--zset-\"><a name=\"五、ZSET（有序集合）基本操作\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>五、ZSET（有序集合）基本操作</h3><p>（1）ZADD 将一个带有给定分值的成员添加到有序集合里面<br>（2）ZRANGE 根据元素在有序排列中所处的位置，从有序集合里面获取多个元素<br>（3）ZRANGEBYSCORE 获取有序集合在给定分值范围的所有元素<br>（4）ZREM 如果给定成员存在于有序集合，那么移除这个成员</p>\n</div>','2017-05-04',6,26,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(412,'工厂模式','工厂模式 目录 何为工厂模式 工厂方法与抽象工厂 如何在Java EE中通过@Producers与@Inject注解实现工厂模式 如何创建自定义注解以及通过@Qualifier消除具体实现之间的歧义 工厂模式有两种模式：工厂方法和抽象方法。它们的意图是一样的：提供一个接口，在不指定具体类的情况下创建相关或依赖的一系列对象。 一.何为工厂模式 工厂的目的在于创建对象。创建的逻辑被封装在工厂中，要么提','<h1 id=\"h1-u5DE5u5382u6A21u5F0F\"><a name=\"工厂模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>工厂模式</h1><p>目录</p>\r\n<ul>\r\n<li>何为工厂模式</li><li>工厂方法与抽象工厂</li><li>如何在Java EE中通过<a href=\"https://github.com/Producers\" title=\"&#64;Producers\" class=\"at-link\">@Producers</a>与<a href=\"https://github.com/Inject\" title=\"&#64;Inject\" class=\"at-link\">@Inject</a>注解实现工厂模式</li><li>如何创建自定义注解以及通过<a href=\"https://github.com/Qualifier\" title=\"&#64;Qualifier\" class=\"at-link\">@Qualifier</a>消除具体实现之间的歧义<br>工厂模式有两种模式：工厂方法和抽象方法。它们的意图是一样的：提供一个接口，在不指定具体类的情况下创建相关或依赖的一系列对象。</li></ul>\r\n<h3 id=\"h3--\"><a name=\"一.何为工厂模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一.何为工厂模式</h3><p>工厂的目的在于创建对象。创建的逻辑被封装在工厂中，要么提供一个方法来返回新创建的对象（工厂方法模式），要么将对象的创建委托给子类（抽象工厂模式）。<br>客户端不必考虑接口或类的不同实现，它只需通过工厂（工厂）获取接口实现的一个实例的即可，这样客户端与对象的创建就实现了解耦<br>解耦是应用依赖反转原则的结果，这带来了很多好处，其中最重要的好处就是实现了高层类与底层类之间的解耦。通过解耦，具体类实现的变化不会影响到客户端，这降低了类与类之间的耦合，并提升了灵活性。</p>\r\n<h3 id=\"h3--\"><a name=\"二.工厂方法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二.工厂方法</h3><p>GoF一书是这样描述工程方法模式的：“定义一个用于创建对象的接口，不过让子类决定实例化那个类”<br>工厂极大降低了new关键字的使用次数，并且将初始化过程与不同的具体实现封装起来。将这些需求中心化可以极大减少向系统中添加或删除具体类的影响以及具体的类依赖的影响。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src=\"http://ohlrxdl4p.bkt.clouddn.com/images/QQ截图20170506134421.jpg\" alt=\"\"><br><strong>1.使用普通代码实现工厂方法</strong><br>被具体实现继承的DrinksMachine抽象类</p>\r\n<pre><code class=\"lang-java\">public abstract class DrinksMachine {\r\n    public abstract Drink dispenseDrink();\r\n    public String displayMessage(){\r\n        return &quot;Thank for your custom.&quot;;\r\n    }\r\n}\r\n</code></pre>\r\n<p>DrinksMachine抽象类的CoffeeMachine实现</p>\r\n<pre><code class=\"lang-java\">public class CoffeeMachine extends DrinksMachine {\r\n    public Drink dispenseDrink() {\r\n        return new Coffee();\r\n    }\r\n}\r\n</code></pre>\r\n<p>DrinksMachine抽象类的SoftDrinksMachine实现</p>\r\n<pre><code class=\"lang-java\">public class SoftDrinksMachine extends DrinksMachine {\r\n    public Drink dispenseDrink() {\r\n        return new SoftDrink();\r\n    }\r\n}\r\n</code></pre>\r\n<p>Drink接口</p>\r\n<pre><code class=\"lang-java\">public interface Drink {}\r\n</code></pre>\r\n<p>Drink接口的SoftDrink实现</p>\r\n<pre><code class=\"lang-java\">public class SoftDrink implements Drink {\r\n    SoftDrink() {\r\n        System.out.println(&quot;Soft drink&quot;);\r\n    }\r\n}\r\n</code></pre>\r\n<p>Drink接口的Coffee实现</p>\r\n<pre><code class=\"lang-java\">public class Coffee implements Drink {\r\n    Coffee() {\r\n        System.out.println(&quot;Coffee&quot;);\r\n    }\r\n}\r\n</code></pre>\r\n<p>CoffeeType枚举<br>```java<br>public enum CoffeeType {EXPRESSO, LATTE}</p>\r\n<p>public Drink dispenseDrink(CoffeeType type) {<br>    Drink coffee = null;<br>    switch (type) {<br>        case EXPRESSO: coffee = new Expresso();<br>        case LATTE: coffee = new Latte();<br>    }<br>    return coffee;<br>}<br>```&lt;!--前面不能有空格--&gt;</p>','2017-05-06',1,31,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(413,'代理模式','代理模式(Proxy Pattern) GoF中给出的代理模式的定义为： 代理模式给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。 代理模式的英文叫做Proxy或Surrogate，它是一种对象结构型模式。 代理模式根据其目的和实现可分为很多种类，常用的代理模式包括如下几种： （1）远程代理（Remote Proxy）————为一个位于不同的地址空间的对象提供一个本地的代理对象','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h1 id=\"h1--proxy-pattern-\"><a name=\"代理模式(Proxy Pattern)\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代理模式(Proxy Pattern)</h1><p>GoF中给出的代理模式的定义为：<br>代理模式给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。<br>代理模式的英文叫做Proxy或Surrogate，它是一种对象结构型模式。<br>代理模式根据其目的和实现可分为很多种类，常用的代理模式包括如下几种：<br>（1）远程代理（Remote Proxy）————为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以是在同一台主机中，也可以是在另一台主机中，远程代理又称为大使（Ambassador）<br>（2）虚拟代理（Virtual Proxy）————如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。<br>（3）保护代理（Protect Proxy）————控制一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。<br>（4）缓冲代理（Cache Proxy）————为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。<br>（5）只能引用代理（Smart Reference Proxy）————当一个对象被引用时，提供一些额外的操作，例如将对象被调用的次数记录下来。<br><img src=\"http://ohlrxdl4p.bkt.clouddn.com/images/QQ截图20170507103646.jpg\" alt=\"\"></p>\n<p>代码实现：<br>1.抽象主题类——BuyTicket.java</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code class=\"lang-java\"><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">interface</span><span class=\"pln\"> </span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> showticket</span><span class=\"pun\">();</span></code></li><li class=\"L2\"><code class=\"lang-java\"><span class=\"pun\">}</span></code></li></ol></pre>\n<p>2.具体主题类——Train.java</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code class=\"lang-java\"><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Train</span><span class=\"pln\"> </span><span class=\"kwd\">implements</span><span class=\"pln\"> </span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"lit\">@Override</span></code></li><li class=\"L2\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> showticket</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L3\"><code class=\"lang-java\"><span class=\"pln\">        </span><span class=\"typ\">System</span><span class=\"pun\">.</span><span class=\"pln\">out</span><span class=\"pun\">.</span><span class=\"pln\">println</span><span class=\"pun\">(</span><span class=\"str\">\"one ticket\"</span><span class=\"pun\">);</span></code></li><li class=\"L4\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L5\"><code class=\"lang-java\"><span class=\"pun\">}</span></code></li></ol></pre>\n<p>3.代理角色类——TicketCenter.java</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code class=\"lang-java\"><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">TicketCenter</span><span class=\"pln\"> </span><span class=\"kwd\">implements</span><span class=\"pln\"> </span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> ticket</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code class=\"lang-java\"></code></li><li class=\"L3\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"typ\">TicketCenter</span><span class=\"pun\">(</span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> ticket</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code class=\"lang-java\"><span class=\"pln\">        </span><span class=\"kwd\">this</span><span class=\"pun\">.</span><span class=\"pln\">ticket </span><span class=\"pun\">=</span><span class=\"pln\"> ticket</span><span class=\"pun\">;</span></code></li><li class=\"L5\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code class=\"lang-java\"></code></li><li class=\"L7\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"lit\">@Override</span></code></li><li class=\"L8\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> showticket</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L9\"><code class=\"lang-java\"><span class=\"pln\">        ticket</span><span class=\"pun\">.</span><span class=\"pln\">showticket</span><span class=\"pun\">();</span></code></li><li class=\"L0\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code class=\"lang-java\"></code></li><li class=\"L2\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> buy</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L3\"><code class=\"lang-java\"><span class=\"pln\">        </span><span class=\"typ\">System</span><span class=\"pun\">.</span><span class=\"pln\">out</span><span class=\"pun\">.</span><span class=\"pln\">println</span><span class=\"pun\">(</span><span class=\"str\">\"by proxy\"</span><span class=\"pun\">);</span></code></li><li class=\"L4\"><code class=\"lang-java\"><span class=\"pln\">        showticket</span><span class=\"pun\">();</span></code></li><li class=\"L5\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code class=\"lang-java\"><span class=\"pun\">}</span></code></li></ol></pre>\n<p>4.客户端测试类</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code class=\"lang-java\"><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">ProxyPattern</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> main</span><span class=\"pun\">(</span><span class=\"typ\">String</span><span class=\"pln\"> args</span><span class=\"pun\">[])</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L2\"><code class=\"lang-java\"><span class=\"pln\">        </span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> x </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Train</span><span class=\"pun\">();</span></code></li><li class=\"L3\"><code class=\"lang-java\"><span class=\"pln\">        </span><span class=\"typ\">TicketCenter</span><span class=\"pln\"> y </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">TicketCenter</span><span class=\"pun\">(</span><span class=\"pln\">x</span><span class=\"pun\">);</span></code></li><li class=\"L4\"><code class=\"lang-java\"><span class=\"pln\">        y</span><span class=\"pun\">.</span><span class=\"pln\">buy</span><span class=\"pun\">();</span></code></li><li class=\"L5\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code class=\"lang-java\"><span class=\"pun\">}</span></code></li></ol></pre>\n<p>运行结果：</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code class=\"lang-html\"><span class=\"pln\">by proxy</span></code></li><li class=\"L1\"><code class=\"lang-html\"><span class=\"pln\">one ticket</span></code></li></ol></pre>\n</div>','2017-05-07',1,29,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(414,'2017-02-28学习笔记','','<p><img src=\"http://ohlrxdl4p.bkt.clouddn.com/images/826546_1482322555369_C5DABB18734059E89A45A0E9170722B0.png\" alt=\"\"></p>','2017-02-28',0,26,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(415,'2017-03-01学习笔记','知识点 1.java中只有值传递，没有引用传递http://guhanjie.iteye.com/blog/1683637 2.final关键字 final修饰变量，则等同于常量. final修饰方法中的参数，称为最终参数. final修饰类，则类不能被继承. final修饰方法，则方法不能被','<h1 id=\"h1-u77E5u8BC6u70B9\"><a name=\"知识点\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>知识点</h1><h4 id=\"h4-1-java-http-guhanjie-iteye-com-blog-1683637\"><a name=\"1.java中只有值传递，没有引用传递  http://guhanjie.iteye.com/blog/1683637\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.java中只有值传递，没有引用传递<a href=\"http://guhanjie.iteye.com/blog/1683637\">http://guhanjie.iteye.com/blog/1683637</a></h4><h4 id=\"h4-2-final-\"><a name=\"2.final关键字\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.final关键字</h4><ul>\r\n<li>final修饰变量，则等同于常量.</li><li>final修饰方法中的参数，称为最终参数.</li><li>final修饰类，则类不能被继承.</li><li>final修饰方法，则方法不能被重写.</li></ul>\r\n<h4 id=\"h4-3-integer-img-src-https-uploadfiles-nowcoder-com-images-20160717-6316247_1468761643205_9f7b85ab04292cf73778d98998a20ed1-alt-\"><a name=\"3.Integer<img src=\"https://uploadfiles.nowcoder.com/images/20160717/6316247_1468761643205_9F7B85AB04292CF73778D98998A20ED1\" alt=\"图片\">\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.Integer<img src=\"https://uploadfiles.nowcoder.com/images/20160717/6316247_1468761643205_9F7B85AB04292CF73778D98998A20ED1\" alt=\"图片\"></h4><h4 id=\"h4-4-java-\"><a name=\"4.java内存模型   点击原文\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.java内存模型 <a href=\"http://blog.csdn.net/ns_code/article/details/17565503\">点击原文</a></h4><p><img src=\"https://uploadfiles.nowcoder.com/images/20161223/415611_1482452184396_6FB53C51539B47559CF0D122A832CF63\" alt=\"\"></p>\r\n<h4 id=\"h4-5-java-reference\"><a name=\"5.java中是没有指针的，有reference\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.java中是没有指针的，有reference</h4><p>第一：指针变量是在栈内存中，它也是有值的，这个值存储的就是地址单元，这个地址就是来自于赋值操作。<br>第二：指针变量有类型，这个类型（如Person）的含义是指针指向的变量在栈内存（不是很确定）中的范围（大小），我理解为是占用的堆内存空间。<br>第三：声明一个对象时，是对“指针变量”的定义。<br>第四：用new关键字在堆内存创建了对象，在赋值时，是把这个对象的首地址传给了这个“指针变量”（即引用型变量）。</p>\r\n<h4 id=\"h4-6-string-\"><a name=\"6.String生成常量\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6.String生成常量</h4><pre><code class=\"lang-java\">String s1=&quot;abc&quot;+&quot;def&quot;;//生成的是一个常量，放在堆内存中\r\nString s2=new String（s1);//s2是一个变量\r\nif(s1.equals(s2))//比较的是字符串的内容\r\n    System.out.println(&quot;.equals succeeded&quot;);//输出\r\nif(s1==s2)//比较的是内存地址，但s1是常量，所以不相等\r\n    System.out.println(&quot;==succeeded&quot;);\r\n</code></pre>\r\n<h4 id=\"h4-7-jsp-\"><a name=\"7.jsp内置对象和属性\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>7.jsp内置对象和属性</h4><p>（１）request对象<br>客户端的请求信息被封装在request对象中，通过它才能了解到客户的需求，然后做出响应。它是HttpServletRequest类的实例。<br>（２）response对象<br>response对象包含了响应客户请求的有关信息，但在JSP中很少直接用到它。它是HttpServletResponse类的实例。<br>（３）session对象<br>session对象指的是客户端与服务器的一次会话，从客户连到服务器的一个WebApplication开始，直到客户端与服务器断开连接为止。它是HttpSession类的实例.<br>（４）out对象<br>out对象是JspWriter类的实例,是向客户端输出内容常用的对象<br>（５）page对象<br>page对象就是指向当前JSP页面本身，有点象类中的this指针，它是java.lang.Object类的实例<br>（６）application对象<br>application对象实现了用户间数据的共享，可存放全局变量。它开始于服务器的启动，直到服务器的关闭，在此期间，此对象将一直存在；这样在用户的前后连接或不同用户之间的连接中，可以对此对象的同一属性进行操作；在任何地方对此对象属性的操作，都将影响到其他用户对此的访问。服务器的启动和关闭决定了application对象的生命。它是ServletContext类的实例。<br>（７）exception对象<br>exception对象是一个例外对象，当一个页面在运行过程中发生了例外，就产生这个对象。如果一个JSP页面要应用此对象，就必须把isErrorPage设为true，否则无法编译。他实际上是java.lang.Throwable的对象<br>（８）pageContext对象<br>pageContext对象提供了对JSP页面内所有的对象及名字空间的访问，也就是说他可以访问到本页所在的SESSION，也可以取本页面所在的application的某一属性值，他相当于页面中所有功能的集大成者，它的本 类名也叫pageContext。<br>（９）config对象<br>config对象是在一个Servlet初始化时，JSP引擎向它传递信息用的，此信息包括Servlet初始化时所要用到的参数（通过属性名和属性值构成）以及服务器的有关信息（通过传递一个ServletContext对象）</p>','2017-03-01',0,24,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(416,'2017-03-02学习笔记','知识点 一、static public class Spike\r\n{\r\n    public static void main(String[] args)\r\n    {\r\n        Counter a = new Counter();\r\n        System.out.println(a.increment());\r\n        System.out.println(a.anot','<h1 id=\"h1-u77E5u8BC6u70B9\"><a name=\"知识点\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>知识点</h1><h4 id=\"h4--static\"><a name=\"一、static\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、static</h4><pre><code class=\"lang-java\">public class Spike\r\n{\r\n    public static void main(String[] args)\r\n    {\r\n        Counter a = new Counter();\r\n        System.out.println(a.increment());\r\n        System.out.println(a.anotherIncrement());\r\n        Counter b = new Counter();\r\n        System.out.println(b.increment());\r\n    }\r\n}\r\nclass Counter\r\n{\r\n    private static int count = 0;\r\n    public int increment()\r\n    {\r\n        return count++;\r\n    }\r\n    public int anotherIncrement()\r\n    {\r\n        return ++count;\r\n    }\r\n}\r\n</code></pre>\r\n<p>count是静态变量，为所有对象所共享，因此不管a.increment()还是b.increment()都会使count持续增加。<br>increment()方法返回当前count值，然后count增加1<br>antoherIncrement()方法让count增加1，然后返回count值<br>第一次a.increment()返回值为0，此时count值为1<br>第二次a.anotherIncrement()先让count+1再返回，返回值为2<br>第三次b.increment()先返回count当前值2，然后count+1</p>\r\n<h4 id=\"h4--aop-\"><a name=\"二、AOP面向切面\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、AOP面向切面</h4><p>AOP的概念是Aspected Oriented Programming 面向方面编程。<br>  好处：AOP将程序分解成各个方面或者说关注点。这使得可以模块化，相当横向上分切了。它可以解决OOP和过程化方法不能够很好解决的横切（crosscut）问题，如：事务、安全、日志等横切关注。<br>  实现AOP有几种方式:<br>  1.Spring 1.2版本中通过ProxyFactoryBean来实现aop,即通过动态代理来实现的,Aspect必须继承MethodBeforeAdvice,MethodAfterAdvice等<br>  2.Spring 2.0 AOP需要改的是FBI 这个类，而且它也不需要再实现某些接口<br>  3.三使用标注（<a href=\"https://github.com/AspectJ\" title=\"&#64;AspectJ\" class=\"at-link\">@AspectJ</a>）实现AOP<br>    AOP 和 OOP的区别：</p>\r\n<pre><code>```html\r\n 1. 面向方面编程 AOP 偏重业务处理过程的某个步骤或阶段，强调降低模块之间的耦合度，使代码拥有更好的移植性。  \r\n 2. 面向对象编程 (oop) 则是对业务分析中抽取的实体进行方法和属性的封装。\r\n ```\r\n</code></pre><p>也可以说 AOP 是面向业务中的动词领域， OOP 面向名词领域。<br>AOP 的一个很重要的特点是源代码无关性，也就是说如果我们的系统中引用了 AOP 组件，即使我们把该组件去掉，系统代码也应该能够编译通过。要实现这一点，可以使用动态 proxy 模式。</p>\r\n<h4 id=\"h4--jdbc-\"><a name=\"三、jdbc桥接模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、jdbc桥接模式</h4><p>桥接模式：<br>定义 ：将抽象部分与它的实现部分分离，使它们都可以独立地变化。<br>意图 ：将抽象与实现解耦。<br>桥接模式所涉及的角色</p>\r\n<ol>\r\n<li>Abstraction ：定义抽象接口，拥有一个Implementor类型的对象引用</li><li>RefinedAbstraction ：扩展Abstraction中的接口定义</li><li>Implementor ：是具体实现的接口，Implementor和RefinedAbstraction接口并不一定完全一致，实际上这两个接口可以完全不一样Implementor提供具体操作方法，而Abstraction提供更高层次的调用</li><li>ConcreteImplementor ：实现Implementor接口，给出具体实现<br>Jdk中的桥接模式：JDBC<br>JDBC连接 数据库 的时候，在各个数据库之间进行切换，基本不需要动太多的代码，甚至丝毫不动，原因就是JDBC提供了统一接口，每个数据库提供各自的实现，用一个叫做数据库驱动的程序来桥接就行了<h4 id=\"h4--\"><a name=\"四、抽象类\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>四、抽象类</h4>抽象类和普通类有三点区别：<br>1）抽象方法必须为public和protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public。<br>2）抽象类不能用来创建对象，但是它可以有构造方法，用来帮助子类实例化。<br>3）如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为abstract类。<h4 id=\"h4--\"><a name=\"五、接口\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>五、接口</h4>接口的主要特点<br>1）接口中的成员变量默认都是public、static、final类型的，必须被显示初始化。<br>2）接口中的方法默认都是public、abstract类型的。<br>3）接口中只能包含public、static、final类型的成员变量和public、abstract类型的成员方法。<br>4）接口没有构造方法，不能被实例化。<br>5）一个接口不能实现另一个接口，但它可以继承多个其他接口。<br>6）接口必须通过类来实现它的抽象方法。<br>7）与子类继承抽象父类相似，当类实现了某个接口时，它必须实现接口中所有的抽象方法，否则这个类必须被定义为抽象类。<br>8）一个类只能继承一个直接的父类，但能实现多个接口。<h4 id=\"h4--\"><a name=\"六、抽象类和接口的区别\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>六、抽象类和接口的区别</h4>1）抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract方法；<br>2）抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；<br>3）接口中不能含有静态代码块以及静态方法，而抽象类尅有静态代码块和静态方法；<br>4）一个类只能继承一个抽象类，而一个类却可以实现多个接口。<br>5）抽象类中的方法子类必须全部实现，不然子类也是抽象类，而接口中的抽象方法子类必须全部实现，是可选择实现的。<br>6）抽象类是一种模板设计模式，而接口时一种行为规范。</li></ol>','2017-03-02',0,24,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(417,'2017-03-03学习笔记','一、String StringBuffer.toString()源码： @Override\r\npublic synchronized String toString() {\r\n    if (toStringCache == null) {\r\n        toStringCache = Arrays.copyOfRange(value, 0, count);\r\n    }\r\n    retur','<h4 id=\"h4--string\"><a name=\"一、String\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、String</h4><p>StringBuffer.toString()源码：</p>\r\n<pre><code class=\"lang-java\">@Override\r\npublic synchronized String toString() {\r\n    if (toStringCache == null) {\r\n        toStringCache = Arrays.copyOfRange(value, 0, count);\r\n    }\r\n    return new String(toStringCache, true);\r\n}\r\n</code></pre>\r\n<p>Arrays.copyOfRange用的是System.arraycopy</p>\r\n<pre><code class=\"lang-java\">public static char[] copyOfRange(char[] original, int from, int to) {\r\n        int newLength = to - from;\r\n        if (newLength &lt; 0)\r\n            throw new IllegalArgumentException(from + &quot; &gt; &quot; + to);\r\n        char[] copy = new char[newLength];\r\n        System.arraycopy(original, from, copy, 0,\r\n                         Math.min(original.length - from, newLength));\r\n        return copy;\r\n    }\r\n</code></pre>\r\n<p>1.String是值传入，不是引用传入。<br>2.String对String  类型进行改变的时候其实都等同于生成了一个新的  String  对象，然后将指针指向新的  String  对象，而不是StringBuffer；StringBuffer每次结果都会对  StringBuffer  对象本身进行操作，而不是生成新的对象，再改变对象引用。<br>3.效率比较String&lt;StringBuffer&lt;StringBuilder，但是在 String S1 = “This is only a” + “ simple” + “ test”时，String效率最高。</p>\r\n<h4 id=\"h4--jvm-\"><a name=\"二、jvm知识图谱\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、jvm知识图谱</h4><p><a href=\"https://zhuanlan.zhihu.com/p/25511795\">引用自知乎</a><br><img src=\"https://pic2.zhimg.com/v2-701563ac1fe745fc8e1234c96e82ac99_r.jpg\" alt=\"\"></p>\r\n<h4 id=\"h4--treemap-linkhashmap\"><a name=\"三、Treemap、LinkHashMap\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、Treemap、LinkHashMap</h4><p>1.TreeMap取出来的是排序后的键值对。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。<br>2.LinkedHashMap 是HashMap的一个子类，如果需要输出的顺序和输入的相同,那么用LinkedHashMap可以实现,它还可以按读取顺序来排列。</p>\r\n<h4 id=\"h4--sql-\"><a name=\"四、sql模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>四、sql模式</h4><p>MySQL数据库中，变量分为 系统变量（以”@@”开头）和用户自定义变量。系统变量分为全局系统变量(global)和会话系统变量(session)。<br>@<a href=\"https://github.com/global\" title=\"&#64;global\" class=\"at-link\">@global</a>     仅用于访问全局系统变量的值；<br>@<a href=\"https://github.com/session\" title=\"&#64;session\" class=\"at-link\">@session</a>  仅用于访问会话系统变量的值；<br>@@              先访问会话系统变量的值，若不存在则去访问全局系统变量的值；<br>sql_mode 为系统变量，既是全局系统变量，又是会话系统变量。</p>\r\n<h4 id=\"h4--\"><a name=\"五、代码的执行顺序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>五、代码的执行顺序</h4><p>父类Ｂ静态代码块-&gt;子类Ａ静态代码块-&gt;父类Ｂ非静态代码块-&gt;父类Ｂ构造函数-&gt;子类Ａ非静态代码块-&gt;子类Ａ构造函数<br><img src=\"http://ohlrxdl4p.bkt.clouddn.com/images/QQ截图20170303165728.jpg\" alt=\"\"></p>','2017-03-03',0,25,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(418,'ifhifhajfe','hello','<h1 id=\"h1-hello\"><a name=\"hello\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>hello</h1>','2017-03-05',0,25,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(419,'2017-03-05学习笔记','java的堆，栈，静态代码区（常量区） 详解','<p><a href=\"http://blog.csdn.net/u012031380/article/details/54981472\"> java的堆，栈，静态代码区（常量区） 详解</a></p>','2017-03-05',0,24,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(420,'java归并排序','package datastruct;\r\n\r\n/**\r\n * Created by Zephery on 2017/3/3.\r\n */\r\npublic class Solution {\r\n    public static void printArray(int[] arr, int i, int j) {\r\n        System.out.print(\"[\");\r\n        for','<pre><code class=\"lang-java\">package datastruct;\r\n\r\n/**\r\n * Created by Zephery on 2017/3/3.\r\n */\r\npublic class Solution {\r\n    public static void printArray(int[] arr, int i, int j) {\r\n        System.out.print(&quot;[&quot;);\r\n        for (int k = i; k &lt; j; k++) {\r\n            System.out.print(arr[k] + &quot;,&quot;);\r\n        }\r\n        System.out.print(arr[j] + &quot;]&quot;);\r\n    }\r\n\r\n    private static void mergesort(int[] arr, int i, int j) {\r\n        int mid = 0;\r\n        if (i &lt; j) {\r\n            mid = (i + j) / 2;\r\n            mergesort(arr, i, mid);\r\n            mergesort(arr, mid + 1, j);\r\n            merge(arr, i, mid, j);\r\n        }\r\n    }\r\n\r\n    private static void merge(int[] arr, int i, int mid, int j) {\r\n        System.out.print(&quot;Left:&quot;);\r\n        printArray(arr, i, mid);\r\n        System.out.println(&quot;Right:&quot;);\r\n        printArray(arr, mid + 1, j);\r\n        System.out.println();\r\n        int temp[] = new int[arr.length];\r\n        int l = i;\r\n        int r = j;\r\n        int m = mid + 1;\r\n        int k = l;\r\n        while (l &lt;= mid &amp;&amp; m &lt;= r) {\r\n            if (arr[l] &lt;= arr[m]) {\r\n                temp[k++] = arr[l++];\r\n            } else {\r\n                temp[k++] = arr[m++];\r\n            }\r\n        }\r\n        while (l &lt;= mid) {\r\n            temp[k++] = arr[l++];\r\n        }\r\n        while (m &lt;= r) {\r\n            temp[k++] = arr[m++];\r\n        }\r\n        for (int i1 = i; i1 &lt;= j; i1++) {\r\n            arr[i1] = temp[i1];\r\n        }\r\n        System.out.print(&quot;After Merge:&quot;);\r\n        printArray(arr, i, j);\r\n        System.out.println();\r\n    }\r\n\r\n    public static void main(String args[]) {\r\n        int[] arr = {9, 4, 8, 3, 1, 2, 5};\r\n        System.out.print(&quot;Initial Array:&quot;);\r\n        printArray(arr, 0, arr.length - 1);\r\n        System.out.println();\r\n        mergesort(arr, 0, arr.length - 1);\r\n    }\r\n}\r\n</code></pre>\r\n<pre><code class=\"lang-js\">Initial Array:[9,4,8,3,1,2,5]\r\nLeft:[9]Right:\r\n[4]\r\nAfter Merge:[4,9]\r\nLeft:[8]Right:\r\n[3]\r\nAfter Merge:[3,8]\r\nLeft:[4,9]Right:\r\n[3,8]\r\nAfter Merge:[3,4,8,9]\r\nLeft:[1]Right:\r\n[2]\r\nAfter Merge:[1,2]\r\nLeft:[1,2]Right:\r\n[5]\r\nAfter Merge:[1,2,5]\r\nLeft:[3,4,8,9]Right:\r\n[1,2,5]\r\nAfter Merge:[1,2,3,4,5,8,9]\r\n</code></pre>','2017-03-06',0,25,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(421,'2017-03-10学习笔记','1.Integer和int，装箱拆箱 1、基本型和基本型封装型进行“==”运算符的比较，基本型封装型将会自动拆箱变为基本型后再进行比较，因此Integer(0)会自动拆箱为int类型再进行比较，显然返回true； 2、两个Integer类型进行“==”比较，如果其值在-128至127，那么返回true，否则返回false, 这跟Integer.valueOf()的缓冲对象有关，这里不进行赘述。 3','<h1 id=\"h1-1-integer-int-\"><a name=\"1.Integer和int，装箱拆箱\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.Integer和int，装箱拆箱</h1><p>1、基本型和基本型封装型进行“==”运算符的比较，基本型封装型将会自动拆箱变为基本型后再进行比较，因此Integer(0)会自动拆箱为int类型再进行比较，显然返回true；<br>2、两个Integer类型进行“==”比较，如果其值在-128至127，那么返回true，否则返回false, 这跟Integer.valueOf()的缓冲对象有关，这里不进行赘述。<br>3、两个基本型的封装型进行equals()比较，首先equals()会比较类型，如果类型相同，则继续比较值，如果值也相同，返回true<br>4、基本型封装类型调用equals(),但是参数是基本类型，这时候，先会进行自动装箱，基本型转换为其封装类型，再进行3中的比较。</p>\r\n<pre><code class=\"lang-java\">int a=257;\r\nInteger b=257;\r\nInteger c=257;\r\nInteger b2=57;\r\nInteger c2=57;\r\nSystem.out.println(a==b);\r\n//System.out.println(a.equals(b));  编译出错，基本型不能调用equals()\r\nSystem.out.println(b.equals(257.0));\r\nSystem.out.println(b==c);\r\nSystem.out.println(b2==c2);\r\n</code></pre>\r\n<p>因此上面的代码的结果因此为 true, false, false, true</p>\r\n<h1 id=\"h1-2-\"><a name=\"2.线程调度\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.线程调度</h1><p>分为协同式调度和抢占式调度，Java使用的是抢占式调度，也就是每个线程将由操作系统来分配执行时间，线程的切换不由线程本身来决定（协同式调度）。这就是平台独立的原因。</p>\r\n<h1 id=\"h1-3-\"><a name=\"3.重载，重写\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.重载，重写</h1><p>重写：<br>两同，两小，一大<br>两同：方法名，方法参数列表相同。<br>两小：抛出的异常类型要小于等于父类，返回值类型要小于等于父类<br>一大：访问权限大于等于父类。<br>重载：<br>在同一个类中，方法名和方法参数列表不同，其他的（访问权限、返回值）随意。</p>\r\n<h1 id=\"h1-4-jvm-\"><a name=\"4.  JVM面试题\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.<a href=\"http://blog.csdn.net/hsk256/article/details/49104955\">JVM面试题</a></h1>','2017-03-10',0,25,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg');
INSERT INTO `blog` VALUES (422,'2017-03-12学习笔记','1.继承的加载顺序 执行顺序大体上可以说是先父类后子类，父类static域 ==》子类static域 ==》父类数据成员域 ==》父类构造器 ==》子类数据成员域 ==》子类构造器 2.优化Hibernate所鼓励的7大措施： 1.尽量使用many-to-one，避免使用单项one-to-many 2.灵活使用单向one-to-many 3.不用一对一，使用多对一代替一对一 4.配置对象缓存，不使','<h4 id=\"h4-1-\"><a name=\"1.  继承的加载顺序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.<a href=\"http://www.cnblogs.com/SirSmith/p/5536288.html\">继承的加载顺序</a></h4><p><img src=\"http://images2015.cnblogs.com/blog/452847/201605/452847-20160527221410288-2119099273.png\" alt=\"\"></p>\r\n<p>执行顺序大体上可以说是先父类后子类，父类static域 ==》子类static域 ==》父类数据成员域 ==》父类构造器 ==》子类数据成员域 ==》子类构造器</p>\r\n<h4 id=\"h4-2-hibernate-7-\"><a name=\"2.优化Hibernate所鼓励的7大措施：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.优化Hibernate所鼓励的7大措施：</h4><p>1.尽量使用many-to-one，避免使用单项one-to-many<br>2.灵活使用单向one-to-many<br>3.不用一对一，使用多对一代替一对一<br>4.配置对象缓存，不使用集合缓存<br>5.一对多使用Bag 多对一使用Set<br>6.继承使用显示多态 HQL:from object polymorphism=”exlicit” 避免查处所有对象<br>7.消除大表，使用二级缓存</p>\r\n<h4 id=\"h4-3-java-\"><a name=\"3.java中的数据类型分类：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.java中的数据类型分类：</h4><p>基本数据类型（或叫做原生类、内置类型）8种：<br>    整数：byte，short，int，long（默认是int类型）<br>    浮点类型： float，double（默认是double类型）<br>    字符类型：char<br>    布尔类型：boolean<br>引用数据类型3种：数组，类，接口</p>\r\n<h4 id=\"h4-4-\"><a name=\"4.触发器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.触发器</h4><p>drop trigger 删除触发器<br>Drop用于删除数据表或数据库，或删除数据表字段。<br>remove：删除数据库文件<br>Truncate：删除数据表中的数据（仅数据表中的数据，不删除表）。</p>','2017-03-12',0,25,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(423,'2017-03-14学习笔记','1.Servlet的生命周期分为5个阶段：加载、创建、初始化、处理客户请求、卸载。 (1)加载：容器通过类加载器使用servlet类对应的文件加载servlet (2)创建：通过调用servlet构造函数创建一个servlet对象 (3)初始化：调用init方法初始化 (4)处理客户请求：每当有一个客户请求，容器会创建一个线程来处理客户请求 (5)卸载：调用destroy方法让servlet自己释','<h4 id=\"h4-1-servlet-5-\"><a name=\"1.Servlet的生命周期分为5个阶段：加载、创建、初始化、处理客户请求、卸载。\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.Servlet的生命周期分为5个阶段：加载、创建、初始化、处理客户请求、卸载。</h4><p>(1)加载：容器通过类加载器使用servlet类对应的文件加载servlet<br>(2)创建：通过调用servlet构造函数创建一个servlet对象<br>(3)初始化：调用init方法初始化<br>(4)处理客户请求：每当有一个客户请求，容器会创建一个线程来处理客户请求<br>(5)卸载：调用destroy方法让servlet自己释放其占用的资源</p>\r\n<h4 id=\"h4-2-jsp\"><a name=\"2.JSP\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.JSP</h4><p><img src=\"http://uploadfiles.nowcoder.com/images/20160308/595432_1457414324036_C3D4EB7F2D61708D0C0BE2921A45B74D\" alt=\"\"></p>','2017-03-14',0,23,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(424,'2017-03-17学习笔记','1.GC线程是否和守护线程 2.java堆排序','<h4 id=\"h4-1-gc-\"><a name=\"1.GC线程是否和守护线程\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.GC线程是否和守护线程</h4><h4 id=\"h4-2-java-\"><a name=\"2.java堆排序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.java堆排序</h4>','2017-03-17',0,21,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(425,'重载与重写','目前的问题：父类的功能无法满足子类的需求。 方法重写的前提： 必须要存在继承的关系。 方法的重写: 子父类出了同名的函数，这个我们就称作为方法的重写。 什么是时候要使用方法的重写：父类的功能无法满足子类的需求时。 方法重写要注意的事项： 1.方法重写时， 方法名与形参列表必须一致。 2.方法重写时，子类的权限修饰符必须要大于或者等于父类的权限修饰符。 3.方法重写时，子类的返回值类型必须要小于或者','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><p>目前的问题：父类的功能无法满足子类的需求。</p>\n<p>方法重写的前提： 必须要存在继承的关系。</p>\n<p>方法的重写: 子父类出了同名的函数，这个我们就称作为方法的重写。</p>\n<p>什么是时候要使用方法的重写：父类的功能无法满足子类的需求时。</p>\n<p>方法重写要注意的事项：<br>    1.方法重写时， 方法名与形参列表必须一致。<br>    2.方法重写时，子类的权限修饰符必须要大于或者等于父类的权限修饰符。<br>    3.方法重写时，子类的返回值类型必须要小于或者 等于父类的返回值类型。<br>    4.方法重写时， 子类抛出的异常类型要小于或者等于父类抛出的异常类型。<br>            Exception(最坏)<br>            RuntimeException(小坏)</p>\n<p>方法的重载：在一个类中 存在两个或者两个 以上的同名函数,称作为方法重载。</p>\n<p>方法重载的要求</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"lit\">1.</span><span class=\"pln\"> </span><span class=\"pun\">函数名要一致。</span></code></li><li class=\"L1\"><code><span class=\"lit\">2.</span><span class=\"pln\"> </span><span class=\"pun\">形参列表不一致（形参的个数或形参</span><span class=\"pln\"> </span><span class=\"pun\">的类型不一致）</span></code></li><li class=\"L2\"><code><span class=\"lit\">3.</span><span class=\"pln\"> </span><span class=\"pun\">与返回值类型无关。</span></code></li></ol></pre></div>','2017-03-21',0,22,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(426,'垃圾回收算法','垃圾回收算法 1、标记-清除算法 2、复制算法 3、标记-整理算法 一、标记-清除算法 标记-清除算法采用从根集合进行扫描，对存活的对象对象标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收，如上图所示。 标记-清除算法不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效，但由于标记-清除算法直接回收不存活的对象，因此会造成内存碎片！ 二、复制算法 复制算法','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h2 id=\"h2-u5783u573Eu56DEu6536u7B97u6CD5\"><a name=\"垃圾回收算法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>垃圾回收算法</h2><p>1、标记-清除算法<br>2、复制算法<br>3、标记-整理算法</p>\n<h4 id=\"h4--\"><a name=\"一、标记-清除算法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、标记-清除算法</h4><p><img src=\"http://dl2.iteye.com/upload/attachment/0075/0386/29ae17ad-f8af-38b4-9e25-28ef3550858f.jpg\" alt=\"\">标记-清除算法采用从根集合进行扫描，对存活的对象对象标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收，如上图所示。<br>标记-清除算法不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效，但由于标记-清除算法直接回收不存活的对象，因此会造成内存碎片！</p>\n<h4 id=\"h4--\"><a name=\"二、复制算法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、复制算法</h4><p><img src=\"http://dl2.iteye.com/upload/attachment/0075/0388/91a656d4-f08a-377b-8eea-5785c2932533.jpg\" alt=\"\"><br>复制算法采用从根集合扫描，并将存活对象复制到一块新的，没有使用过的空间中，这种算法当控件存活的对象比较少时，极为高效，但是带来的成本是需要一块内存交换空间用于进行对象的移动。也就是我们前面提到的s0 s1等空间。</p>\n<h4 id=\"h4--\"><a name=\"三、标记-整理算法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、标记-整理算法</h4><p><img src=\"http://dl2.iteye.com/upload/attachment/0075/0390/6ba95f80-c7bc-3d09-b927-ac09297e9920.jpg\" alt=\"\"><br> 标记-整理算法采用标记-清除算法一样的方式进行对象的标记，但在清除时不同，在回收不存活的对象占用的空间后，会将所有的存活对象往左端空闲空间移动，并更新对应的指针。标记-整理算法是在标记-清除算法的基础上，又进行了对象的移动，因此成本更高，但是却解决了内存碎片的问题。</p>\n</div>','2017-04-09',0,25,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(427,'java分代回收','一、新生代内存的回收（minor GC）主要采用复制算法，下图展示了minor GC的执行过程。 二、对于新生代和旧生代，JVM可使用很多种垃圾回收器进行垃圾回收，下图展示了不同生代不通垃圾回收器，其中两个回收器之间有连线表示这两个回收器可以同时使用。 而这些垃圾回收器又分为串行回收方式、并行回收方式合并发回收方式执行，分别运用于不同的场景。如下图所示 三、收集器 1.Serial收集器 看名字我','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h2 id=\"h2--minor-gc-minor-gc-\"><a name=\"一、新生代内存的回收（minor GC）主要采用复制算法，下图展示了minor GC的执行过程。\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、新生代内存的回收（minor GC）主要采用复制算法，下图展示了minor GC的执行过程。</h2><p><img src=\"http://dl2.iteye.com/upload/attachment/0075/0392/732c7557-aa9a-3551-b14d-f543c5b0c94b.jpg\" alt=\"\"></p>\n<h2 id=\"h2--jvm-\"><a name=\"二、对于新生代和旧生代，JVM可使用很多种垃圾回收器进行垃圾回收，下图展示了不同生代不通垃圾回收器，其中两个回收器之间有连线表示这两个回收器可以同时使用。\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、对于新生代和旧生代，JVM可使用很多种垃圾回收器进行垃圾回收，下图展示了不同生代不通垃圾回收器，其中两个回收器之间有连线表示这两个回收器可以同时使用。</h2><p><img src=\"http://dl2.iteye.com/upload/attachment/0075/0394/0172f624-9018-3642-bf26-05a2c3071639.jpg\" alt=\"\"><br>而这些垃圾回收器又分为串行回收方式、并行回收方式合并发回收方式执行，分别运用于不同的场景。如下图所示<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0396/c962c2ad-273f-3de4-b2e3-a4dd8b946215.jpg\" alt=\"\"></p>\n<h2 id=\"h2--\"><a name=\"三、收集器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、收集器</h2><h4 id=\"h4-1-serial-\"><a name=\"1.Serial收集器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.Serial收集器</h4><p>看名字我们都可以看的出来，这个属于串行收集器。其运行示意图如下<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0398/681da5ca-5eff-3984-bece-3d80dfe905be.jpg\" alt=\"\"><br>    收集器是历史最悠久的一个回收器，JDK1.3之前广泛使用这个收集器，目前也是ClientVM下 ServerVM 4核4GB以下机器的默认垃圾回收器。串行收集器并不是只能使用一个CPU进行收集，而是当JVM需要进行垃圾回收的时候，需要中断所有的用户线程，知道它回收结束为止，因此又号称“Stop The World” 的垃圾回收器。注意，JVM中文名称为java虚拟机，因此它就像一台虚拟的电脑一样在工作，而其中的每一个线程就被认为是JVM的一个处理器，因此大家看到图中的CPU0、CPU1实际为用户的线程，而不是真正机器的CPU，大家不要误解哦。<br>    串行回收方式适合低端机器，是Client模式下的默认收集器，对CPU和内存的消耗不高，适合用户交互比较少，后台任务较多的系统。<br>    Serial收集器默认新旧生代的回收器搭配为Serial+ SerialOld</p>\n<h4 id=\"h4-2-parnew-\"><a name=\"2.ParNew收集器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.ParNew收集器</h4><p>ParNew收集器其实就是多线程版本的Serial收集器，其运行示意图如下<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0400/6443b39c-ed33-3d93-a690-87e646439561.jpg\" alt=\"\"><br>同样有Stop The World的问题，他是多CPU模式下的首选回收器（该回收器在单CPU的环境下回收效率远远低于Serial收集器，所以一定要注意场景哦），也是Server模式下的默认收集器。</p>\n<h4 id=\"h4-3-parallelscavenge\"><a name=\"3.ParallelScavenge\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.ParallelScavenge</h4><p>ParallelScavenge又被称为是吞吐量优先的收集器，器运行示意图如下<br><img src=\"http://dl.iteye.com/upload/attachment/0075/0402/5007beba-0b0e-3cf4-b146-c28b6c0dd696.jpg\" alt=\"\"><br> ParallelScavenge<br>所提到的吞吐量=程序运行时间/(JVM执行回收的时间+程序运行时间),假设程序运行了100分钟，JVM的垃圾回收占用1分钟，那么吞吐量就是99%。在当今网络告诉发达的今天，良好的响应速度是提升用户体验的一个重要指标，多核并行云计算的发展要求程序尽可能的使用CPU和内存资源，尽快的计算出最终结果，因此在交互不多的云端，比较适合使用该回收器。</p>\n<h4 id=\"h4-4-parallelold\"><a name=\"4.ParallelOld\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.ParallelOld</h4><p>ParallelOld是老生代并行收集器的一种，使用标记整理算法、是老生代吞吐量优先的一个收集器。这个收集器是JDK1.6之后刚引入的一款收集器，我们看之前那个图之间的关联关系可以看到，早期没有ParallelOld之前，吞吐量优先的收集器老生代只能使用串行回收收集器，大大的拖累了吞吐量优先的性能，自从JDK1.6之后，才能真正做到较高效率的吞吐量优先。其运行示意图如下<br><img src=\"http://dl.iteye.com/upload/attachment/0075/0406/9a14da85-f943-3408-ba88-c6bb3842a792.jpg\" alt=\"\"></p>\n<h4 id=\"h4-5-serialold\"><a name=\"5.SerialOld\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.SerialOld</h4><p>SerialOld是旧生代Client模式下的默认收集器，单线程执行；在JDK1.6之前也是ParallelScvenge回收新生代模式下旧生代的默认收集器，同时也是并发收集器CMS回收失败后的备用收集器。其运行示意图如下<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0404/ce7aabd5-b0e0-3cda-9b6c-607cf6ebf689.jpg\" alt=\"\"></p>\n<h4 id=\"h4-5-cms\"><a name=\"5.CMS\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.CMS</h4><p>CMS又称响应时间优先(最短回收停顿)的回收器，使用并发模式回收垃圾，使用标记-清除算法，CMS对CPU是非常敏感的，它的回收线程数=（CPU+3）/4，因此当CPU是2核的实惠，回收线程将占用的CPU资源的50%，而当CPU核心数为4时仅占用25%。他的运行示意图如下<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0408/4239228b-879f-382f-81c6-5c32799886d6.jpg\" alt=\"\"><br>模式主要分为四个过程：<br>1.初始标记<br>2.并发标记<br>3.重新标记<br>4.并发清除<br>在初始标记的时候，需要中断所有用户线程，在并发标记阶段，用户线程和标记线程<br>并发执行，而在这个过程中，随着内存引用关系的变化，可能会发生原来标记的对象被释放，进而引发新的垃圾，因此可能会产生一系列的浮动垃圾，不能被回收。</p>\n<p>CMS 为了确保能够扫描到所有的对象，避免在Initial Marking 中还有未标识到的对象，采用的方法为找到标记了的对象，并将这些对象放入Stack 中，扫描时寻找此对象依赖的对象，如果依赖的对象的地址在其之前，则将此对象进行标记，并同时放入Stack 中，如依赖的对象地址在其之后，则仅标记该对象。<br>在进行Concurrent Marking 时minor GC 也可能会同时进行，这个时候很容易造成旧生代对象引用关系改变，CMS 为了应对这样的并发现象，提供了一个Mod Union Table 来进行记录，在这个Mod Union Table中记录每次minor GC 后修改了的Card 的信息。这也是ParallelScavenge不能和CMS一起使用的原因。<br>CMS产生浮动垃圾的情况请见如下示意图<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0410/60e7c659-790a-3405-af70-9ca4cfd9258d.jpg\" alt=\"\"><br>在运行回收过后，c就变成了浮动垃圾。<br>由于CMS会产生浮动垃圾，当回收过后，浮动垃圾如果产生过多，同时因为使用标记-清除算法会产生碎片，可能会导致回收过后的连续空间仍然不能容纳新生代移动过来或者新创建的大资源，因此会导致CMS回收失败，进而触发另外一次FULL GC，而这时候则采用SerialOld进行二次回收。<br>同时CMS因为可能产生浮动垃圾，而CMS在执行回收的同时新生代也有可能在进行回收操作，为了保证旧生代能够存放新生代转移过来的数据，CMS在旧生代内存到达全部容量的68%就触发了CMS的回收！</p>\n<h4 id=\"h4-7-garbagefirst-g1-\"><a name=\"7.GarbageFirst(G1)\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>7.GarbageFirst(G1)</h4><p>我们再来看垃圾回收器的总图，刚才我们可以看到，我在图上标记了一个？，其实这是一个新的垃圾回收器，既可以回收新生代也可以回收旧生代，SunHotSpot 1.6u14以上EarlyAccess版本加入了这个回收器，sun公司预期SunHotSpot1.7发布正式版，他是商用高性能垃圾回收器，通过重新划分内存区域，整合优化CMS，同时注重吞吐量和响应时间，但是杯具的是被Oracle收购之后这个收集器属于商用收费收集器，因此目前基本上没有人使用，我们在这里也就不多介绍，更多信息可以参考oracle新版本JDK说明。</p>\n</div>','2017-04-09',0,28,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(428,'java汇编','java 汇编 http://download.csdn.net/download/jiangfuqiang/8403497','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><p>java 汇编<br><a href=\"http://download.csdn.net/download/jiangfuqiang/8403497\">http://download.csdn.net/download/jiangfuqiang/8403497</a></p>\n</div>','2017-04-10',0,28,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(429,'jvm','-XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><p>-XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly</p>\n</div>','2017-04-10',0,27,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(430,'Java堆.栈和常量池 笔记','Java堆.栈和常量池 笔记','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><p><a href=\"http://www.iteye.com/topic/634530\">Java堆.栈和常量池 笔记</a></p>\n</div>','2017-04-23',0,23,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(431,'工厂模式','工厂模式 目录 何为工厂模式 工厂方法与抽象工厂 如何在Java EE中通过@Producers与@Inject注解实现工厂模式 如何创建自定义注解以及通过@Qualifier消除具体实现之间的歧义 工厂模式有两种模式：工厂方法和抽象方法。它们的意图是一样的：提供一个接口，在不指定具体类的情况下创建相关或依赖的一系列对象。 一.何为工厂模式 工厂的目的在于创建对象。创建的逻辑被封装在工厂中，要么提','<h1 id=\"h1-u5DE5u5382u6A21u5F0F\"><a name=\"工厂模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>工厂模式</h1><p>目录</p>\r\n<ul>\r\n<li>何为工厂模式</li><li>工厂方法与抽象工厂</li><li>如何在Java EE中通过<a href=\"https://github.com/Producers\" title=\"&#64;Producers\" class=\"at-link\">@Producers</a>与<a href=\"https://github.com/Inject\" title=\"&#64;Inject\" class=\"at-link\">@Inject</a>注解实现工厂模式</li><li>如何创建自定义注解以及通过<a href=\"https://github.com/Qualifier\" title=\"&#64;Qualifier\" class=\"at-link\">@Qualifier</a>消除具体实现之间的歧义<br>工厂模式有两种模式：工厂方法和抽象方法。它们的意图是一样的：提供一个接口，在不指定具体类的情况下创建相关或依赖的一系列对象。</li></ul>\r\n<h3 id=\"h3--\"><a name=\"一.何为工厂模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一.何为工厂模式</h3><p>工厂的目的在于创建对象。创建的逻辑被封装在工厂中，要么提供一个方法来返回新创建的对象（工厂方法模式），要么将对象的创建委托给子类（抽象工厂模式）。<br>客户端不必考虑接口或类的不同实现，它只需通过工厂（工厂）获取接口实现的一个实例的即可，这样客户端与对象的创建就实现了解耦<br>解耦是应用依赖反转原则的结果，这带来了很多好处，其中最重要的好处就是实现了高层类与底层类之间的解耦。通过解耦，具体类实现的变化不会影响到客户端，这降低了类与类之间的耦合，并提升了灵活性。</p>\r\n<h3 id=\"h3--\"><a name=\"二.工厂方法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二.工厂方法</h3><p>GoF一书是这样描述工程方法模式的：“定义一个用于创建对象的接口，不过让子类决定实例化那个类”<br>工厂极大降低了new关键字的使用次数，并且将初始化过程与不同的具体实现封装起来。将这些需求中心化可以极大减少向系统中添加或删除具体类的影响以及具体的类依赖的影响。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src=\"http://ohlrxdl4p.bkt.clouddn.com/images/QQ截图20170506134421.jpg\" alt=\"\"><br><strong>1.使用普通代码实现工厂方法</strong><br>被具体实现继承的DrinksMachine抽象类</p>\r\n<pre><code class=\"lang-java\">public abstract class DrinksMachine {\r\n    public abstract Drink dispenseDrink();\r\n    public String displayMessage(){\r\n        return &quot;Thank for your custom.&quot;;\r\n    }\r\n}\r\n</code></pre>\r\n<p>DrinksMachine抽象类的CoffeeMachine实现</p>\r\n<pre><code class=\"lang-java\">public class CoffeeMachine extends DrinksMachine {\r\n    public Drink dispenseDrink() {\r\n        return new Coffee();\r\n    }\r\n}\r\n</code></pre>\r\n<p>DrinksMachine抽象类的SoftDrinksMachine实现</p>\r\n<pre><code class=\"lang-java\">public class SoftDrinksMachine extends DrinksMachine {\r\n    public Drink dispenseDrink() {\r\n        return new SoftDrink();\r\n    }\r\n}\r\n</code></pre>\r\n<p>Drink接口</p>\r\n<pre><code class=\"lang-java\">public interface Drink {}\r\n</code></pre>\r\n<p>Drink接口的SoftDrink实现</p>\r\n<pre><code class=\"lang-java\">public class SoftDrink implements Drink {\r\n    SoftDrink() {\r\n        System.out.println(&quot;Soft drink&quot;);\r\n    }\r\n}\r\n</code></pre>\r\n<p>Drink接口的Coffee实现</p>\r\n<pre><code class=\"lang-java\">public class Coffee implements Drink {\r\n    Coffee() {\r\n        System.out.println(&quot;Coffee&quot;);\r\n    }\r\n}\r\n</code></pre>\r\n<p>CoffeeType枚举<br>```java<br>public enum CoffeeType {EXPRESSO, LATTE}</p>\r\n<p>public Drink dispenseDrink(CoffeeType type) {<br>    Drink coffee = null;<br>    switch (type) {<br>        case EXPRESSO: coffee = new Expresso();<br>        case LATTE: coffee = new Latte();<br>    }<br>    return coffee;<br>}<br>```&lt;!--前面不能有空格--&gt;</p>','2017-05-06',0,23,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(432,'代理模式','代理模式(Proxy Pattern) GoF中给出的代理模式的定义为： 代理模式给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。 代理模式的英文叫做Proxy或Surrogate，它是一种对象结构型模式。 代理模式根据其目的和实现可分为很多种类，常用的代理模式包括如下几种： （1）远程代理（Remote Proxy）————为一个位于不同的地址空间的对象提供一个本地的代理对象','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h1 id=\"h1--proxy-pattern-\"><a name=\"代理模式(Proxy Pattern)\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代理模式(Proxy Pattern)</h1><p>GoF中给出的代理模式的定义为：<br>代理模式给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。<br>代理模式的英文叫做Proxy或Surrogate，它是一种对象结构型模式。<br>代理模式根据其目的和实现可分为很多种类，常用的代理模式包括如下几种：<br>（1）远程代理（Remote Proxy）————为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以是在同一台主机中，也可以是在另一台主机中，远程代理又称为大使（Ambassador）<br>（2）虚拟代理（Virtual Proxy）————如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。<br>（3）保护代理（Protect Proxy）————控制一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。<br>（4）缓冲代理（Cache Proxy）————为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。<br>（5）只能引用代理（Smart Reference Proxy）————当一个对象被引用时，提供一些额外的操作，例如将对象被调用的次数记录下来。<br><img src=\"http://ohlrxdl4p.bkt.clouddn.com/images/QQ截图20170507103646.jpg\" alt=\"\"></p>\n<p>代码实现：<br>1.抽象主题类——BuyTicket.java</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code class=\"lang-java\"><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">interface</span><span class=\"pln\"> </span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> showticket</span><span class=\"pun\">();</span></code></li><li class=\"L2\"><code class=\"lang-java\"><span class=\"pun\">}</span></code></li></ol></pre>\n<p>2.具体主题类——Train.java</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code class=\"lang-java\"><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Train</span><span class=\"pln\"> </span><span class=\"kwd\">implements</span><span class=\"pln\"> </span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"lit\">@Override</span></code></li><li class=\"L2\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> showticket</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L3\"><code class=\"lang-java\"><span class=\"pln\">        </span><span class=\"typ\">System</span><span class=\"pun\">.</span><span class=\"pln\">out</span><span class=\"pun\">.</span><span class=\"pln\">println</span><span class=\"pun\">(</span><span class=\"str\">\"one ticket\"</span><span class=\"pun\">);</span></code></li><li class=\"L4\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L5\"><code class=\"lang-java\"><span class=\"pun\">}</span></code></li></ol></pre>\n<p>3.代理角色类——TicketCenter.java</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code class=\"lang-java\"><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">TicketCenter</span><span class=\"pln\"> </span><span class=\"kwd\">implements</span><span class=\"pln\"> </span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> ticket</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code class=\"lang-java\"></code></li><li class=\"L3\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"typ\">TicketCenter</span><span class=\"pun\">(</span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> ticket</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code class=\"lang-java\"><span class=\"pln\">        </span><span class=\"kwd\">this</span><span class=\"pun\">.</span><span class=\"pln\">ticket </span><span class=\"pun\">=</span><span class=\"pln\"> ticket</span><span class=\"pun\">;</span></code></li><li class=\"L5\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code class=\"lang-java\"></code></li><li class=\"L7\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"lit\">@Override</span></code></li><li class=\"L8\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> showticket</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L9\"><code class=\"lang-java\"><span class=\"pln\">        ticket</span><span class=\"pun\">.</span><span class=\"pln\">showticket</span><span class=\"pun\">();</span></code></li><li class=\"L0\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code class=\"lang-java\"></code></li><li class=\"L2\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> buy</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L3\"><code class=\"lang-java\"><span class=\"pln\">        </span><span class=\"typ\">System</span><span class=\"pun\">.</span><span class=\"pln\">out</span><span class=\"pun\">.</span><span class=\"pln\">println</span><span class=\"pun\">(</span><span class=\"str\">\"by proxy\"</span><span class=\"pun\">);</span></code></li><li class=\"L4\"><code class=\"lang-java\"><span class=\"pln\">        showticket</span><span class=\"pun\">();</span></code></li><li class=\"L5\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code class=\"lang-java\"><span class=\"pun\">}</span></code></li></ol></pre>\n<p>4.客户端测试类</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code class=\"lang-java\"><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">ProxyPattern</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> main</span><span class=\"pun\">(</span><span class=\"typ\">String</span><span class=\"pln\"> args</span><span class=\"pun\">[])</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L2\"><code class=\"lang-java\"><span class=\"pln\">        </span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> x </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Train</span><span class=\"pun\">();</span></code></li><li class=\"L3\"><code class=\"lang-java\"><span class=\"pln\">        </span><span class=\"typ\">TicketCenter</span><span class=\"pln\"> y </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">TicketCenter</span><span class=\"pun\">(</span><span class=\"pln\">x</span><span class=\"pun\">);</span></code></li><li class=\"L4\"><code class=\"lang-java\"><span class=\"pln\">        y</span><span class=\"pun\">.</span><span class=\"pln\">buy</span><span class=\"pun\">();</span></code></li><li class=\"L5\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code class=\"lang-java\"><span class=\"pun\">}</span></code></li></ol></pre>\n<p>运行结果：</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code class=\"lang-html\"><span class=\"pln\">by proxy</span></code></li><li class=\"L1\"><code class=\"lang-html\"><span class=\"pln\">one ticket</span></code></li></ol></pre>\n</div>','2017-05-07',0,23,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(433,'2017-02-28学习笔记','','<p><img src=\"http://ohlrxdl4p.bkt.clouddn.com/images/826546_1482322555369_C5DABB18734059E89A45A0E9170722B0.png\" alt=\"\"></p>','2017-02-28',0,26,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(434,'2017-03-01学习笔记','知识点 1.java中只有值传递，没有引用传递http://guhanjie.iteye.com/blog/1683637 2.final关键字 final修饰变量，则等同于常量. final修饰方法中的参数，称为最终参数. final修饰类，则类不能被继承. final修饰方法，则方法不能被','<h1 id=\"h1-u77E5u8BC6u70B9\"><a name=\"知识点\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>知识点</h1><h4 id=\"h4-1-java-http-guhanjie-iteye-com-blog-1683637\"><a name=\"1.java中只有值传递，没有引用传递  http://guhanjie.iteye.com/blog/1683637\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.java中只有值传递，没有引用传递<a href=\"http://guhanjie.iteye.com/blog/1683637\">http://guhanjie.iteye.com/blog/1683637</a></h4><h4 id=\"h4-2-final-\"><a name=\"2.final关键字\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.final关键字</h4><ul>\r\n<li>final修饰变量，则等同于常量.</li><li>final修饰方法中的参数，称为最终参数.</li><li>final修饰类，则类不能被继承.</li><li>final修饰方法，则方法不能被重写.</li></ul>\r\n<h4 id=\"h4-3-integer-img-src-https-uploadfiles-nowcoder-com-images-20160717-6316247_1468761643205_9f7b85ab04292cf73778d98998a20ed1-alt-\"><a name=\"3.Integer<img src=\"https://uploadfiles.nowcoder.com/images/20160717/6316247_1468761643205_9F7B85AB04292CF73778D98998A20ED1\" alt=\"图片\">\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.Integer<img src=\"https://uploadfiles.nowcoder.com/images/20160717/6316247_1468761643205_9F7B85AB04292CF73778D98998A20ED1\" alt=\"图片\"></h4><h4 id=\"h4-4-java-\"><a name=\"4.java内存模型   点击原文\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.java内存模型 <a href=\"http://blog.csdn.net/ns_code/article/details/17565503\">点击原文</a></h4><p><img src=\"https://uploadfiles.nowcoder.com/images/20161223/415611_1482452184396_6FB53C51539B47559CF0D122A832CF63\" alt=\"\"></p>\r\n<h4 id=\"h4-5-java-reference\"><a name=\"5.java中是没有指针的，有reference\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.java中是没有指针的，有reference</h4><p>第一：指针变量是在栈内存中，它也是有值的，这个值存储的就是地址单元，这个地址就是来自于赋值操作。<br>第二：指针变量有类型，这个类型（如Person）的含义是指针指向的变量在栈内存（不是很确定）中的范围（大小），我理解为是占用的堆内存空间。<br>第三：声明一个对象时，是对“指针变量”的定义。<br>第四：用new关键字在堆内存创建了对象，在赋值时，是把这个对象的首地址传给了这个“指针变量”（即引用型变量）。</p>\r\n<h4 id=\"h4-6-string-\"><a name=\"6.String生成常量\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6.String生成常量</h4><pre><code class=\"lang-java\">String s1=&quot;abc&quot;+&quot;def&quot;;//生成的是一个常量，放在堆内存中\r\nString s2=new String（s1);//s2是一个变量\r\nif(s1.equals(s2))//比较的是字符串的内容\r\n    System.out.println(&quot;.equals succeeded&quot;);//输出\r\nif(s1==s2)//比较的是内存地址，但s1是常量，所以不相等\r\n    System.out.println(&quot;==succeeded&quot;);\r\n</code></pre>\r\n<h4 id=\"h4-7-jsp-\"><a name=\"7.jsp内置对象和属性\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>7.jsp内置对象和属性</h4><p>（１）request对象<br>客户端的请求信息被封装在request对象中，通过它才能了解到客户的需求，然后做出响应。它是HttpServletRequest类的实例。<br>（２）response对象<br>response对象包含了响应客户请求的有关信息，但在JSP中很少直接用到它。它是HttpServletResponse类的实例。<br>（３）session对象<br>session对象指的是客户端与服务器的一次会话，从客户连到服务器的一个WebApplication开始，直到客户端与服务器断开连接为止。它是HttpSession类的实例.<br>（４）out对象<br>out对象是JspWriter类的实例,是向客户端输出内容常用的对象<br>（５）page对象<br>page对象就是指向当前JSP页面本身，有点象类中的this指针，它是java.lang.Object类的实例<br>（６）application对象<br>application对象实现了用户间数据的共享，可存放全局变量。它开始于服务器的启动，直到服务器的关闭，在此期间，此对象将一直存在；这样在用户的前后连接或不同用户之间的连接中，可以对此对象的同一属性进行操作；在任何地方对此对象属性的操作，都将影响到其他用户对此的访问。服务器的启动和关闭决定了application对象的生命。它是ServletContext类的实例。<br>（７）exception对象<br>exception对象是一个例外对象，当一个页面在运行过程中发生了例外，就产生这个对象。如果一个JSP页面要应用此对象，就必须把isErrorPage设为true，否则无法编译。他实际上是java.lang.Throwable的对象<br>（８）pageContext对象<br>pageContext对象提供了对JSP页面内所有的对象及名字空间的访问，也就是说他可以访问到本页所在的SESSION，也可以取本页面所在的application的某一属性值，他相当于页面中所有功能的集大成者，它的本 类名也叫pageContext。<br>（９）config对象<br>config对象是在一个Servlet初始化时，JSP引擎向它传递信息用的，此信息包括Servlet初始化时所要用到的参数（通过属性名和属性值构成）以及服务器的有关信息（通过传递一个ServletContext对象）</p>','2017-03-01',0,25,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(435,'2017-03-02学习笔记','知识点 一、static public class Spike\r\n{\r\n    public static void main(String[] args)\r\n    {\r\n        Counter a = new Counter();\r\n        System.out.println(a.increment());\r\n        System.out.println(a.anot','<h1 id=\"h1-u77E5u8BC6u70B9\"><a name=\"知识点\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>知识点</h1><h4 id=\"h4--static\"><a name=\"一、static\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、static</h4><pre><code class=\"lang-java\">public class Spike\r\n{\r\n    public static void main(String[] args)\r\n    {\r\n        Counter a = new Counter();\r\n        System.out.println(a.increment());\r\n        System.out.println(a.anotherIncrement());\r\n        Counter b = new Counter();\r\n        System.out.println(b.increment());\r\n    }\r\n}\r\nclass Counter\r\n{\r\n    private static int count = 0;\r\n    public int increment()\r\n    {\r\n        return count++;\r\n    }\r\n    public int anotherIncrement()\r\n    {\r\n        return ++count;\r\n    }\r\n}\r\n</code></pre>\r\n<p>count是静态变量，为所有对象所共享，因此不管a.increment()还是b.increment()都会使count持续增加。<br>increment()方法返回当前count值，然后count增加1<br>antoherIncrement()方法让count增加1，然后返回count值<br>第一次a.increment()返回值为0，此时count值为1<br>第二次a.anotherIncrement()先让count+1再返回，返回值为2<br>第三次b.increment()先返回count当前值2，然后count+1</p>\r\n<h4 id=\"h4--aop-\"><a name=\"二、AOP面向切面\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、AOP面向切面</h4><p>AOP的概念是Aspected Oriented Programming 面向方面编程。<br>  好处：AOP将程序分解成各个方面或者说关注点。这使得可以模块化，相当横向上分切了。它可以解决OOP和过程化方法不能够很好解决的横切（crosscut）问题，如：事务、安全、日志等横切关注。<br>  实现AOP有几种方式:<br>  1.Spring 1.2版本中通过ProxyFactoryBean来实现aop,即通过动态代理来实现的,Aspect必须继承MethodBeforeAdvice,MethodAfterAdvice等<br>  2.Spring 2.0 AOP需要改的是FBI 这个类，而且它也不需要再实现某些接口<br>  3.三使用标注（<a href=\"https://github.com/AspectJ\" title=\"&#64;AspectJ\" class=\"at-link\">@AspectJ</a>）实现AOP<br>    AOP 和 OOP的区别：</p>\r\n<pre><code>```html\r\n 1. 面向方面编程 AOP 偏重业务处理过程的某个步骤或阶段，强调降低模块之间的耦合度，使代码拥有更好的移植性。  \r\n 2. 面向对象编程 (oop) 则是对业务分析中抽取的实体进行方法和属性的封装。\r\n ```\r\n</code></pre><p>也可以说 AOP 是面向业务中的动词领域， OOP 面向名词领域。<br>AOP 的一个很重要的特点是源代码无关性，也就是说如果我们的系统中引用了 AOP 组件，即使我们把该组件去掉，系统代码也应该能够编译通过。要实现这一点，可以使用动态 proxy 模式。</p>\r\n<h4 id=\"h4--jdbc-\"><a name=\"三、jdbc桥接模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、jdbc桥接模式</h4><p>桥接模式：<br>定义 ：将抽象部分与它的实现部分分离，使它们都可以独立地变化。<br>意图 ：将抽象与实现解耦。<br>桥接模式所涉及的角色</p>\r\n<ol>\r\n<li>Abstraction ：定义抽象接口，拥有一个Implementor类型的对象引用</li><li>RefinedAbstraction ：扩展Abstraction中的接口定义</li><li>Implementor ：是具体实现的接口，Implementor和RefinedAbstraction接口并不一定完全一致，实际上这两个接口可以完全不一样Implementor提供具体操作方法，而Abstraction提供更高层次的调用</li><li>ConcreteImplementor ：实现Implementor接口，给出具体实现<br>Jdk中的桥接模式：JDBC<br>JDBC连接 数据库 的时候，在各个数据库之间进行切换，基本不需要动太多的代码，甚至丝毫不动，原因就是JDBC提供了统一接口，每个数据库提供各自的实现，用一个叫做数据库驱动的程序来桥接就行了<h4 id=\"h4--\"><a name=\"四、抽象类\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>四、抽象类</h4>抽象类和普通类有三点区别：<br>1）抽象方法必须为public和protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public。<br>2）抽象类不能用来创建对象，但是它可以有构造方法，用来帮助子类实例化。<br>3）如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为abstract类。<h4 id=\"h4--\"><a name=\"五、接口\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>五、接口</h4>接口的主要特点<br>1）接口中的成员变量默认都是public、static、final类型的，必须被显示初始化。<br>2）接口中的方法默认都是public、abstract类型的。<br>3）接口中只能包含public、static、final类型的成员变量和public、abstract类型的成员方法。<br>4）接口没有构造方法，不能被实例化。<br>5）一个接口不能实现另一个接口，但它可以继承多个其他接口。<br>6）接口必须通过类来实现它的抽象方法。<br>7）与子类继承抽象父类相似，当类实现了某个接口时，它必须实现接口中所有的抽象方法，否则这个类必须被定义为抽象类。<br>8）一个类只能继承一个直接的父类，但能实现多个接口。<h4 id=\"h4--\"><a name=\"六、抽象类和接口的区别\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>六、抽象类和接口的区别</h4>1）抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract方法；<br>2）抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；<br>3）接口中不能含有静态代码块以及静态方法，而抽象类尅有静态代码块和静态方法；<br>4）一个类只能继承一个抽象类，而一个类却可以实现多个接口。<br>5）抽象类中的方法子类必须全部实现，不然子类也是抽象类，而接口中的抽象方法子类必须全部实现，是可选择实现的。<br>6）抽象类是一种模板设计模式，而接口时一种行为规范。</li></ol>','2017-03-02',0,24,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(436,'2017-03-03学习笔记','一、String StringBuffer.toString()源码： @Override\r\npublic synchronized String toString() {\r\n    if (toStringCache == null) {\r\n        toStringCache = Arrays.copyOfRange(value, 0, count);\r\n    }\r\n    retur','<h4 id=\"h4--string\"><a name=\"一、String\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、String</h4><p>StringBuffer.toString()源码：</p>\r\n<pre><code class=\"lang-java\">@Override\r\npublic synchronized String toString() {\r\n    if (toStringCache == null) {\r\n        toStringCache = Arrays.copyOfRange(value, 0, count);\r\n    }\r\n    return new String(toStringCache, true);\r\n}\r\n</code></pre>\r\n<p>Arrays.copyOfRange用的是System.arraycopy</p>\r\n<pre><code class=\"lang-java\">public static char[] copyOfRange(char[] original, int from, int to) {\r\n        int newLength = to - from;\r\n        if (newLength &lt; 0)\r\n            throw new IllegalArgumentException(from + &quot; &gt; &quot; + to);\r\n        char[] copy = new char[newLength];\r\n        System.arraycopy(original, from, copy, 0,\r\n                         Math.min(original.length - from, newLength));\r\n        return copy;\r\n    }\r\n</code></pre>\r\n<p>1.String是值传入，不是引用传入。<br>2.String对String  类型进行改变的时候其实都等同于生成了一个新的  String  对象，然后将指针指向新的  String  对象，而不是StringBuffer；StringBuffer每次结果都会对  StringBuffer  对象本身进行操作，而不是生成新的对象，再改变对象引用。<br>3.效率比较String&lt;StringBuffer&lt;StringBuilder，但是在 String S1 = “This is only a” + “ simple” + “ test”时，String效率最高。</p>\r\n<h4 id=\"h4--jvm-\"><a name=\"二、jvm知识图谱\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、jvm知识图谱</h4><p><a href=\"https://zhuanlan.zhihu.com/p/25511795\">引用自知乎</a><br><img src=\"https://pic2.zhimg.com/v2-701563ac1fe745fc8e1234c96e82ac99_r.jpg\" alt=\"\"></p>\r\n<h4 id=\"h4--treemap-linkhashmap\"><a name=\"三、Treemap、LinkHashMap\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、Treemap、LinkHashMap</h4><p>1.TreeMap取出来的是排序后的键值对。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。<br>2.LinkedHashMap 是HashMap的一个子类，如果需要输出的顺序和输入的相同,那么用LinkedHashMap可以实现,它还可以按读取顺序来排列。</p>\r\n<h4 id=\"h4--sql-\"><a name=\"四、sql模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>四、sql模式</h4><p>MySQL数据库中，变量分为 系统变量（以”@@”开头）和用户自定义变量。系统变量分为全局系统变量(global)和会话系统变量(session)。<br>@<a href=\"https://github.com/global\" title=\"&#64;global\" class=\"at-link\">@global</a>     仅用于访问全局系统变量的值；<br>@<a href=\"https://github.com/session\" title=\"&#64;session\" class=\"at-link\">@session</a>  仅用于访问会话系统变量的值；<br>@@              先访问会话系统变量的值，若不存在则去访问全局系统变量的值；<br>sql_mode 为系统变量，既是全局系统变量，又是会话系统变量。</p>\r\n<h4 id=\"h4--\"><a name=\"五、代码的执行顺序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>五、代码的执行顺序</h4><p>父类Ｂ静态代码块-&gt;子类Ａ静态代码块-&gt;父类Ｂ非静态代码块-&gt;父类Ｂ构造函数-&gt;子类Ａ非静态代码块-&gt;子类Ａ构造函数<br><img src=\"http://ohlrxdl4p.bkt.clouddn.com/images/QQ截图20170303165728.jpg\" alt=\"\"></p>','2017-03-03',0,25,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(437,'ifhifhajfe','hello','<h1 id=\"h1-hello\"><a name=\"hello\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>hello</h1>','2017-03-05',0,23,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(438,'2017-03-05学习笔记','java的堆，栈，静态代码区（常量区） 详解','<p><a href=\"http://blog.csdn.net/u012031380/article/details/54981472\"> java的堆，栈，静态代码区（常量区） 详解</a></p>','2017-03-05',0,24,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(439,'java归并排序','package datastruct;\r\n\r\n/**\r\n * Created by Zephery on 2017/3/3.\r\n */\r\npublic class Solution {\r\n    public static void printArray(int[] arr, int i, int j) {\r\n        System.out.print(\"[\");\r\n        for','<pre><code class=\"lang-java\">package datastruct;\r\n\r\n/**\r\n * Created by Zephery on 2017/3/3.\r\n */\r\npublic class Solution {\r\n    public static void printArray(int[] arr, int i, int j) {\r\n        System.out.print(&quot;[&quot;);\r\n        for (int k = i; k &lt; j; k++) {\r\n            System.out.print(arr[k] + &quot;,&quot;);\r\n        }\r\n        System.out.print(arr[j] + &quot;]&quot;);\r\n    }\r\n\r\n    private static void mergesort(int[] arr, int i, int j) {\r\n        int mid = 0;\r\n        if (i &lt; j) {\r\n            mid = (i + j) / 2;\r\n            mergesort(arr, i, mid);\r\n            mergesort(arr, mid + 1, j);\r\n            merge(arr, i, mid, j);\r\n        }\r\n    }\r\n\r\n    private static void merge(int[] arr, int i, int mid, int j) {\r\n        System.out.print(&quot;Left:&quot;);\r\n        printArray(arr, i, mid);\r\n        System.out.println(&quot;Right:&quot;);\r\n        printArray(arr, mid + 1, j);\r\n        System.out.println();\r\n        int temp[] = new int[arr.length];\r\n        int l = i;\r\n        int r = j;\r\n        int m = mid + 1;\r\n        int k = l;\r\n        while (l &lt;= mid &amp;&amp; m &lt;= r) {\r\n            if (arr[l] &lt;= arr[m]) {\r\n                temp[k++] = arr[l++];\r\n            } else {\r\n                temp[k++] = arr[m++];\r\n            }\r\n        }\r\n        while (l &lt;= mid) {\r\n            temp[k++] = arr[l++];\r\n        }\r\n        while (m &lt;= r) {\r\n            temp[k++] = arr[m++];\r\n        }\r\n        for (int i1 = i; i1 &lt;= j; i1++) {\r\n            arr[i1] = temp[i1];\r\n        }\r\n        System.out.print(&quot;After Merge:&quot;);\r\n        printArray(arr, i, j);\r\n        System.out.println();\r\n    }\r\n\r\n    public static void main(String args[]) {\r\n        int[] arr = {9, 4, 8, 3, 1, 2, 5};\r\n        System.out.print(&quot;Initial Array:&quot;);\r\n        printArray(arr, 0, arr.length - 1);\r\n        System.out.println();\r\n        mergesort(arr, 0, arr.length - 1);\r\n    }\r\n}\r\n</code></pre>\r\n<pre><code class=\"lang-js\">Initial Array:[9,4,8,3,1,2,5]\r\nLeft:[9]Right:\r\n[4]\r\nAfter Merge:[4,9]\r\nLeft:[8]Right:\r\n[3]\r\nAfter Merge:[3,8]\r\nLeft:[4,9]Right:\r\n[3,8]\r\nAfter Merge:[3,4,8,9]\r\nLeft:[1]Right:\r\n[2]\r\nAfter Merge:[1,2]\r\nLeft:[1,2]Right:\r\n[5]\r\nAfter Merge:[1,2,5]\r\nLeft:[3,4,8,9]Right:\r\n[1,2,5]\r\nAfter Merge:[1,2,3,4,5,8,9]\r\n</code></pre>','2017-03-06',0,24,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(440,'2017-03-10学习笔记','1.Integer和int，装箱拆箱 1、基本型和基本型封装型进行“==”运算符的比较，基本型封装型将会自动拆箱变为基本型后再进行比较，因此Integer(0)会自动拆箱为int类型再进行比较，显然返回true； 2、两个Integer类型进行“==”比较，如果其值在-128至127，那么返回true，否则返回false, 这跟Integer.valueOf()的缓冲对象有关，这里不进行赘述。 3','<h1 id=\"h1-1-integer-int-\"><a name=\"1.Integer和int，装箱拆箱\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.Integer和int，装箱拆箱</h1><p>1、基本型和基本型封装型进行“==”运算符的比较，基本型封装型将会自动拆箱变为基本型后再进行比较，因此Integer(0)会自动拆箱为int类型再进行比较，显然返回true；<br>2、两个Integer类型进行“==”比较，如果其值在-128至127，那么返回true，否则返回false, 这跟Integer.valueOf()的缓冲对象有关，这里不进行赘述。<br>3、两个基本型的封装型进行equals()比较，首先equals()会比较类型，如果类型相同，则继续比较值，如果值也相同，返回true<br>4、基本型封装类型调用equals(),但是参数是基本类型，这时候，先会进行自动装箱，基本型转换为其封装类型，再进行3中的比较。</p>\r\n<pre><code class=\"lang-java\">int a=257;\r\nInteger b=257;\r\nInteger c=257;\r\nInteger b2=57;\r\nInteger c2=57;\r\nSystem.out.println(a==b);\r\n//System.out.println(a.equals(b));  编译出错，基本型不能调用equals()\r\nSystem.out.println(b.equals(257.0));\r\nSystem.out.println(b==c);\r\nSystem.out.println(b2==c2);\r\n</code></pre>\r\n<p>因此上面的代码的结果因此为 true, false, false, true</p>\r\n<h1 id=\"h1-2-\"><a name=\"2.线程调度\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.线程调度</h1><p>分为协同式调度和抢占式调度，Java使用的是抢占式调度，也就是每个线程将由操作系统来分配执行时间，线程的切换不由线程本身来决定（协同式调度）。这就是平台独立的原因。</p>\r\n<h1 id=\"h1-3-\"><a name=\"3.重载，重写\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.重载，重写</h1><p>重写：<br>两同，两小，一大<br>两同：方法名，方法参数列表相同。<br>两小：抛出的异常类型要小于等于父类，返回值类型要小于等于父类<br>一大：访问权限大于等于父类。<br>重载：<br>在同一个类中，方法名和方法参数列表不同，其他的（访问权限、返回值）随意。</p>\r\n<h1 id=\"h1-4-jvm-\"><a name=\"4.  JVM面试题\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.<a href=\"http://blog.csdn.net/hsk256/article/details/49104955\">JVM面试题</a></h1>','2017-03-10',0,24,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(441,'2017-03-12学习笔记','1.继承的加载顺序 执行顺序大体上可以说是先父类后子类，父类static域 ==》子类static域 ==》父类数据成员域 ==》父类构造器 ==》子类数据成员域 ==》子类构造器 2.优化Hibernate所鼓励的7大措施： 1.尽量使用many-to-one，避免使用单项one-to-many 2.灵活使用单向one-to-many 3.不用一对一，使用多对一代替一对一 4.配置对象缓存，不使','<h4 id=\"h4-1-\"><a name=\"1.  继承的加载顺序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.<a href=\"http://www.cnblogs.com/SirSmith/p/5536288.html\">继承的加载顺序</a></h4><p><img src=\"http://images2015.cnblogs.com/blog/452847/201605/452847-20160527221410288-2119099273.png\" alt=\"\"></p>\r\n<p>执行顺序大体上可以说是先父类后子类，父类static域 ==》子类static域 ==》父类数据成员域 ==》父类构造器 ==》子类数据成员域 ==》子类构造器</p>\r\n<h4 id=\"h4-2-hibernate-7-\"><a name=\"2.优化Hibernate所鼓励的7大措施：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.优化Hibernate所鼓励的7大措施：</h4><p>1.尽量使用many-to-one，避免使用单项one-to-many<br>2.灵活使用单向one-to-many<br>3.不用一对一，使用多对一代替一对一<br>4.配置对象缓存，不使用集合缓存<br>5.一对多使用Bag 多对一使用Set<br>6.继承使用显示多态 HQL:from object polymorphism=”exlicit” 避免查处所有对象<br>7.消除大表，使用二级缓存</p>\r\n<h4 id=\"h4-3-java-\"><a name=\"3.java中的数据类型分类：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.java中的数据类型分类：</h4><p>基本数据类型（或叫做原生类、内置类型）8种：<br>    整数：byte，short，int，long（默认是int类型）<br>    浮点类型： float，double（默认是double类型）<br>    字符类型：char<br>    布尔类型：boolean<br>引用数据类型3种：数组，类，接口</p>\r\n<h4 id=\"h4-4-\"><a name=\"4.触发器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.触发器</h4><p>drop trigger 删除触发器<br>Drop用于删除数据表或数据库，或删除数据表字段。<br>remove：删除数据库文件<br>Truncate：删除数据表中的数据（仅数据表中的数据，不删除表）。</p>','2017-03-12',0,23,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(442,'2017-03-14学习笔记','1.Servlet的生命周期分为5个阶段：加载、创建、初始化、处理客户请求、卸载。 (1)加载：容器通过类加载器使用servlet类对应的文件加载servlet (2)创建：通过调用servlet构造函数创建一个servlet对象 (3)初始化：调用init方法初始化 (4)处理客户请求：每当有一个客户请求，容器会创建一个线程来处理客户请求 (5)卸载：调用destroy方法让servlet自己释','<h4 id=\"h4-1-servlet-5-\"><a name=\"1.Servlet的生命周期分为5个阶段：加载、创建、初始化、处理客户请求、卸载。\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.Servlet的生命周期分为5个阶段：加载、创建、初始化、处理客户请求、卸载。</h4><p>(1)加载：容器通过类加载器使用servlet类对应的文件加载servlet<br>(2)创建：通过调用servlet构造函数创建一个servlet对象<br>(3)初始化：调用init方法初始化<br>(4)处理客户请求：每当有一个客户请求，容器会创建一个线程来处理客户请求<br>(5)卸载：调用destroy方法让servlet自己释放其占用的资源</p>\r\n<h4 id=\"h4-2-jsp\"><a name=\"2.JSP\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.JSP</h4><p><img src=\"http://uploadfiles.nowcoder.com/images/20160308/595432_1457414324036_C3D4EB7F2D61708D0C0BE2921A45B74D\" alt=\"\"></p>','2017-03-14',0,22,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(443,'2017-03-17学习笔记','1.GC线程是否和守护线程 2.java堆排序','<h4 id=\"h4-1-gc-\"><a name=\"1.GC线程是否和守护线程\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.GC线程是否和守护线程</h4><h4 id=\"h4-2-java-\"><a name=\"2.java堆排序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.java堆排序</h4>','2017-03-17',0,21,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(444,'重载与重写','目前的问题：父类的功能无法满足子类的需求。 方法重写的前提： 必须要存在继承的关系。 方法的重写: 子父类出了同名的函数，这个我们就称作为方法的重写。 什么是时候要使用方法的重写：父类的功能无法满足子类的需求时。 方法重写要注意的事项： 1.方法重写时， 方法名与形参列表必须一致。 2.方法重写时，子类的权限修饰符必须要大于或者等于父类的权限修饰符。 3.方法重写时，子类的返回值类型必须要小于或者','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><p>目前的问题：父类的功能无法满足子类的需求。</p>\n<p>方法重写的前提： 必须要存在继承的关系。</p>\n<p>方法的重写: 子父类出了同名的函数，这个我们就称作为方法的重写。</p>\n<p>什么是时候要使用方法的重写：父类的功能无法满足子类的需求时。</p>\n<p>方法重写要注意的事项：<br>    1.方法重写时， 方法名与形参列表必须一致。<br>    2.方法重写时，子类的权限修饰符必须要大于或者等于父类的权限修饰符。<br>    3.方法重写时，子类的返回值类型必须要小于或者 等于父类的返回值类型。<br>    4.方法重写时， 子类抛出的异常类型要小于或者等于父类抛出的异常类型。<br>            Exception(最坏)<br>            RuntimeException(小坏)</p>\n<p>方法的重载：在一个类中 存在两个或者两个 以上的同名函数,称作为方法重载。</p>\n<p>方法重载的要求</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"lit\">1.</span><span class=\"pln\"> </span><span class=\"pun\">函数名要一致。</span></code></li><li class=\"L1\"><code><span class=\"lit\">2.</span><span class=\"pln\"> </span><span class=\"pun\">形参列表不一致（形参的个数或形参</span><span class=\"pln\"> </span><span class=\"pun\">的类型不一致）</span></code></li><li class=\"L2\"><code><span class=\"lit\">3.</span><span class=\"pln\"> </span><span class=\"pun\">与返回值类型无关。</span></code></li></ol></pre></div>','2017-03-21',0,26,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(445,'垃圾回收算法','垃圾回收算法 1、标记-清除算法 2、复制算法 3、标记-整理算法 一、标记-清除算法 标记-清除算法采用从根集合进行扫描，对存活的对象对象标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收，如上图所示。 标记-清除算法不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效，但由于标记-清除算法直接回收不存活的对象，因此会造成内存碎片！ 二、复制算法 复制算法','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h2 id=\"h2-u5783u573Eu56DEu6536u7B97u6CD5\"><a name=\"垃圾回收算法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>垃圾回收算法</h2><p>1、标记-清除算法<br>2、复制算法<br>3、标记-整理算法</p>\n<h4 id=\"h4--\"><a name=\"一、标记-清除算法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、标记-清除算法</h4><p><img src=\"http://dl2.iteye.com/upload/attachment/0075/0386/29ae17ad-f8af-38b4-9e25-28ef3550858f.jpg\" alt=\"\">标记-清除算法采用从根集合进行扫描，对存活的对象对象标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收，如上图所示。<br>标记-清除算法不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效，但由于标记-清除算法直接回收不存活的对象，因此会造成内存碎片！</p>\n<h4 id=\"h4--\"><a name=\"二、复制算法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、复制算法</h4><p><img src=\"http://dl2.iteye.com/upload/attachment/0075/0388/91a656d4-f08a-377b-8eea-5785c2932533.jpg\" alt=\"\"><br>复制算法采用从根集合扫描，并将存活对象复制到一块新的，没有使用过的空间中，这种算法当控件存活的对象比较少时，极为高效，但是带来的成本是需要一块内存交换空间用于进行对象的移动。也就是我们前面提到的s0 s1等空间。</p>\n<h4 id=\"h4--\"><a name=\"三、标记-整理算法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、标记-整理算法</h4><p><img src=\"http://dl2.iteye.com/upload/attachment/0075/0390/6ba95f80-c7bc-3d09-b927-ac09297e9920.jpg\" alt=\"\"><br> 标记-整理算法采用标记-清除算法一样的方式进行对象的标记，但在清除时不同，在回收不存活的对象占用的空间后，会将所有的存活对象往左端空闲空间移动，并更新对应的指针。标记-整理算法是在标记-清除算法的基础上，又进行了对象的移动，因此成本更高，但是却解决了内存碎片的问题。</p>\n</div>','2017-04-09',0,28,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(446,'java分代回收','一、新生代内存的回收（minor GC）主要采用复制算法，下图展示了minor GC的执行过程。 二、对于新生代和旧生代，JVM可使用很多种垃圾回收器进行垃圾回收，下图展示了不同生代不通垃圾回收器，其中两个回收器之间有连线表示这两个回收器可以同时使用。 而这些垃圾回收器又分为串行回收方式、并行回收方式合并发回收方式执行，分别运用于不同的场景。如下图所示 三、收集器 1.Serial收集器 看名字我','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h2 id=\"h2--minor-gc-minor-gc-\"><a name=\"一、新生代内存的回收（minor GC）主要采用复制算法，下图展示了minor GC的执行过程。\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、新生代内存的回收（minor GC）主要采用复制算法，下图展示了minor GC的执行过程。</h2><p><img src=\"http://dl2.iteye.com/upload/attachment/0075/0392/732c7557-aa9a-3551-b14d-f543c5b0c94b.jpg\" alt=\"\"></p>\n<h2 id=\"h2--jvm-\"><a name=\"二、对于新生代和旧生代，JVM可使用很多种垃圾回收器进行垃圾回收，下图展示了不同生代不通垃圾回收器，其中两个回收器之间有连线表示这两个回收器可以同时使用。\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、对于新生代和旧生代，JVM可使用很多种垃圾回收器进行垃圾回收，下图展示了不同生代不通垃圾回收器，其中两个回收器之间有连线表示这两个回收器可以同时使用。</h2><p><img src=\"http://dl2.iteye.com/upload/attachment/0075/0394/0172f624-9018-3642-bf26-05a2c3071639.jpg\" alt=\"\"><br>而这些垃圾回收器又分为串行回收方式、并行回收方式合并发回收方式执行，分别运用于不同的场景。如下图所示<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0396/c962c2ad-273f-3de4-b2e3-a4dd8b946215.jpg\" alt=\"\"></p>\n<h2 id=\"h2--\"><a name=\"三、收集器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、收集器</h2><h4 id=\"h4-1-serial-\"><a name=\"1.Serial收集器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.Serial收集器</h4><p>看名字我们都可以看的出来，这个属于串行收集器。其运行示意图如下<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0398/681da5ca-5eff-3984-bece-3d80dfe905be.jpg\" alt=\"\"><br>    收集器是历史最悠久的一个回收器，JDK1.3之前广泛使用这个收集器，目前也是ClientVM下 ServerVM 4核4GB以下机器的默认垃圾回收器。串行收集器并不是只能使用一个CPU进行收集，而是当JVM需要进行垃圾回收的时候，需要中断所有的用户线程，知道它回收结束为止，因此又号称“Stop The World” 的垃圾回收器。注意，JVM中文名称为java虚拟机，因此它就像一台虚拟的电脑一样在工作，而其中的每一个线程就被认为是JVM的一个处理器，因此大家看到图中的CPU0、CPU1实际为用户的线程，而不是真正机器的CPU，大家不要误解哦。<br>    串行回收方式适合低端机器，是Client模式下的默认收集器，对CPU和内存的消耗不高，适合用户交互比较少，后台任务较多的系统。<br>    Serial收集器默认新旧生代的回收器搭配为Serial+ SerialOld</p>\n<h4 id=\"h4-2-parnew-\"><a name=\"2.ParNew收集器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.ParNew收集器</h4><p>ParNew收集器其实就是多线程版本的Serial收集器，其运行示意图如下<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0400/6443b39c-ed33-3d93-a690-87e646439561.jpg\" alt=\"\"><br>同样有Stop The World的问题，他是多CPU模式下的首选回收器（该回收器在单CPU的环境下回收效率远远低于Serial收集器，所以一定要注意场景哦），也是Server模式下的默认收集器。</p>\n<h4 id=\"h4-3-parallelscavenge\"><a name=\"3.ParallelScavenge\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.ParallelScavenge</h4><p>ParallelScavenge又被称为是吞吐量优先的收集器，器运行示意图如下<br><img src=\"http://dl.iteye.com/upload/attachment/0075/0402/5007beba-0b0e-3cf4-b146-c28b6c0dd696.jpg\" alt=\"\"><br> ParallelScavenge<br>所提到的吞吐量=程序运行时间/(JVM执行回收的时间+程序运行时间),假设程序运行了100分钟，JVM的垃圾回收占用1分钟，那么吞吐量就是99%。在当今网络告诉发达的今天，良好的响应速度是提升用户体验的一个重要指标，多核并行云计算的发展要求程序尽可能的使用CPU和内存资源，尽快的计算出最终结果，因此在交互不多的云端，比较适合使用该回收器。</p>\n<h4 id=\"h4-4-parallelold\"><a name=\"4.ParallelOld\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.ParallelOld</h4><p>ParallelOld是老生代并行收集器的一种，使用标记整理算法、是老生代吞吐量优先的一个收集器。这个收集器是JDK1.6之后刚引入的一款收集器，我们看之前那个图之间的关联关系可以看到，早期没有ParallelOld之前，吞吐量优先的收集器老生代只能使用串行回收收集器，大大的拖累了吞吐量优先的性能，自从JDK1.6之后，才能真正做到较高效率的吞吐量优先。其运行示意图如下<br><img src=\"http://dl.iteye.com/upload/attachment/0075/0406/9a14da85-f943-3408-ba88-c6bb3842a792.jpg\" alt=\"\"></p>\n<h4 id=\"h4-5-serialold\"><a name=\"5.SerialOld\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.SerialOld</h4><p>SerialOld是旧生代Client模式下的默认收集器，单线程执行；在JDK1.6之前也是ParallelScvenge回收新生代模式下旧生代的默认收集器，同时也是并发收集器CMS回收失败后的备用收集器。其运行示意图如下<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0404/ce7aabd5-b0e0-3cda-9b6c-607cf6ebf689.jpg\" alt=\"\"></p>\n<h4 id=\"h4-5-cms\"><a name=\"5.CMS\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.CMS</h4><p>CMS又称响应时间优先(最短回收停顿)的回收器，使用并发模式回收垃圾，使用标记-清除算法，CMS对CPU是非常敏感的，它的回收线程数=（CPU+3）/4，因此当CPU是2核的实惠，回收线程将占用的CPU资源的50%，而当CPU核心数为4时仅占用25%。他的运行示意图如下<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0408/4239228b-879f-382f-81c6-5c32799886d6.jpg\" alt=\"\"><br>模式主要分为四个过程：<br>1.初始标记<br>2.并发标记<br>3.重新标记<br>4.并发清除<br>在初始标记的时候，需要中断所有用户线程，在并发标记阶段，用户线程和标记线程<br>并发执行，而在这个过程中，随着内存引用关系的变化，可能会发生原来标记的对象被释放，进而引发新的垃圾，因此可能会产生一系列的浮动垃圾，不能被回收。</p>\n<p>CMS 为了确保能够扫描到所有的对象，避免在Initial Marking 中还有未标识到的对象，采用的方法为找到标记了的对象，并将这些对象放入Stack 中，扫描时寻找此对象依赖的对象，如果依赖的对象的地址在其之前，则将此对象进行标记，并同时放入Stack 中，如依赖的对象地址在其之后，则仅标记该对象。<br>在进行Concurrent Marking 时minor GC 也可能会同时进行，这个时候很容易造成旧生代对象引用关系改变，CMS 为了应对这样的并发现象，提供了一个Mod Union Table 来进行记录，在这个Mod Union Table中记录每次minor GC 后修改了的Card 的信息。这也是ParallelScavenge不能和CMS一起使用的原因。<br>CMS产生浮动垃圾的情况请见如下示意图<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0410/60e7c659-790a-3405-af70-9ca4cfd9258d.jpg\" alt=\"\"><br>在运行回收过后，c就变成了浮动垃圾。<br>由于CMS会产生浮动垃圾，当回收过后，浮动垃圾如果产生过多，同时因为使用标记-清除算法会产生碎片，可能会导致回收过后的连续空间仍然不能容纳新生代移动过来或者新创建的大资源，因此会导致CMS回收失败，进而触发另外一次FULL GC，而这时候则采用SerialOld进行二次回收。<br>同时CMS因为可能产生浮动垃圾，而CMS在执行回收的同时新生代也有可能在进行回收操作，为了保证旧生代能够存放新生代转移过来的数据，CMS在旧生代内存到达全部容量的68%就触发了CMS的回收！</p>\n<h4 id=\"h4-7-garbagefirst-g1-\"><a name=\"7.GarbageFirst(G1)\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>7.GarbageFirst(G1)</h4><p>我们再来看垃圾回收器的总图，刚才我们可以看到，我在图上标记了一个？，其实这是一个新的垃圾回收器，既可以回收新生代也可以回收旧生代，SunHotSpot 1.6u14以上EarlyAccess版本加入了这个回收器，sun公司预期SunHotSpot1.7发布正式版，他是商用高性能垃圾回收器，通过重新划分内存区域，整合优化CMS，同时注重吞吐量和响应时间，但是杯具的是被Oracle收购之后这个收集器属于商用收费收集器，因此目前基本上没有人使用，我们在这里也就不多介绍，更多信息可以参考oracle新版本JDK说明。</p>\n</div>','2017-04-09',0,28,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(447,'java汇编','java 汇编 http://download.csdn.net/download/jiangfuqiang/8403497','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><p>java 汇编<br><a href=\"http://download.csdn.net/download/jiangfuqiang/8403497\">http://download.csdn.net/download/jiangfuqiang/8403497</a></p>\n</div>','2017-04-10',0,22,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(448,'jvm','-XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><p>-XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly</p>\n</div>','2017-04-10',0,22,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(449,'Java堆.栈和常量池 笔记','Java堆.栈和常量池 笔记','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><p><a href=\"http://www.iteye.com/topic/634530\">Java堆.栈和常量池 笔记</a></p>\n</div>','2017-04-23',0,25,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(450,'工厂模式','工厂模式 目录 何为工厂模式 工厂方法与抽象工厂 如何在Java EE中通过@Producers与@Inject注解实现工厂模式 如何创建自定义注解以及通过@Qualifier消除具体实现之间的歧义 工厂模式有两种模式：工厂方法和抽象方法。它们的意图是一样的：提供一个接口，在不指定具体类的情况下创建相关或依赖的一系列对象。 一.何为工厂模式 工厂的目的在于创建对象。创建的逻辑被封装在工厂中，要么提','<h1 id=\"h1-u5DE5u5382u6A21u5F0F\"><a name=\"工厂模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>工厂模式</h1><p>目录</p>\r\n<ul>\r\n<li>何为工厂模式</li><li>工厂方法与抽象工厂</li><li>如何在Java EE中通过<a href=\"https://github.com/Producers\" title=\"&#64;Producers\" class=\"at-link\">@Producers</a>与<a href=\"https://github.com/Inject\" title=\"&#64;Inject\" class=\"at-link\">@Inject</a>注解实现工厂模式</li><li>如何创建自定义注解以及通过<a href=\"https://github.com/Qualifier\" title=\"&#64;Qualifier\" class=\"at-link\">@Qualifier</a>消除具体实现之间的歧义<br>工厂模式有两种模式：工厂方法和抽象方法。它们的意图是一样的：提供一个接口，在不指定具体类的情况下创建相关或依赖的一系列对象。</li></ul>\r\n<h3 id=\"h3--\"><a name=\"一.何为工厂模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一.何为工厂模式</h3><p>工厂的目的在于创建对象。创建的逻辑被封装在工厂中，要么提供一个方法来返回新创建的对象（工厂方法模式），要么将对象的创建委托给子类（抽象工厂模式）。<br>客户端不必考虑接口或类的不同实现，它只需通过工厂（工厂）获取接口实现的一个实例的即可，这样客户端与对象的创建就实现了解耦<br>解耦是应用依赖反转原则的结果，这带来了很多好处，其中最重要的好处就是实现了高层类与底层类之间的解耦。通过解耦，具体类实现的变化不会影响到客户端，这降低了类与类之间的耦合，并提升了灵活性。</p>\r\n<h3 id=\"h3--\"><a name=\"二.工厂方法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二.工厂方法</h3><p>GoF一书是这样描述工程方法模式的：“定义一个用于创建对象的接口，不过让子类决定实例化那个类”<br>工厂极大降低了new关键字的使用次数，并且将初始化过程与不同的具体实现封装起来。将这些需求中心化可以极大减少向系统中添加或删除具体类的影响以及具体的类依赖的影响。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src=\"http://ohlrxdl4p.bkt.clouddn.com/images/QQ截图20170506134421.jpg\" alt=\"\"><br><strong>1.使用普通代码实现工厂方法</strong><br>被具体实现继承的DrinksMachine抽象类</p>\r\n<pre><code class=\"lang-java\">public abstract class DrinksMachine {\r\n    public abstract Drink dispenseDrink();\r\n    public String displayMessage(){\r\n        return &quot;Thank for your custom.&quot;;\r\n    }\r\n}\r\n</code></pre>\r\n<p>DrinksMachine抽象类的CoffeeMachine实现</p>\r\n<pre><code class=\"lang-java\">public class CoffeeMachine extends DrinksMachine {\r\n    public Drink dispenseDrink() {\r\n        return new Coffee();\r\n    }\r\n}\r\n</code></pre>\r\n<p>DrinksMachine抽象类的SoftDrinksMachine实现</p>\r\n<pre><code class=\"lang-java\">public class SoftDrinksMachine extends DrinksMachine {\r\n    public Drink dispenseDrink() {\r\n        return new SoftDrink();\r\n    }\r\n}\r\n</code></pre>\r\n<p>Drink接口</p>\r\n<pre><code class=\"lang-java\">public interface Drink {}\r\n</code></pre>\r\n<p>Drink接口的SoftDrink实现</p>\r\n<pre><code class=\"lang-java\">public class SoftDrink implements Drink {\r\n    SoftDrink() {\r\n        System.out.println(&quot;Soft drink&quot;);\r\n    }\r\n}\r\n</code></pre>\r\n<p>Drink接口的Coffee实现</p>\r\n<pre><code class=\"lang-java\">public class Coffee implements Drink {\r\n    Coffee() {\r\n        System.out.println(&quot;Coffee&quot;);\r\n    }\r\n}\r\n</code></pre>\r\n<p>CoffeeType枚举<br>```java<br>public enum CoffeeType {EXPRESSO, LATTE}</p>\r\n<p>public Drink dispenseDrink(CoffeeType type) {<br>    Drink coffee = null;<br>    switch (type) {<br>        case EXPRESSO: coffee = new Expresso();<br>        case LATTE: coffee = new Latte();<br>    }<br>    return coffee;<br>}<br>```&lt;!--前面不能有空格--&gt;</p>','2017-05-06',0,28,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(451,'代理模式','代理模式(Proxy Pattern) GoF中给出的代理模式的定义为： 代理模式给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。 代理模式的英文叫做Proxy或Surrogate，它是一种对象结构型模式。 代理模式根据其目的和实现可分为很多种类，常用的代理模式包括如下几种： （1）远程代理（Remote Proxy）————为一个位于不同的地址空间的对象提供一个本地的代理对象','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h1 id=\"h1--proxy-pattern-\"><a name=\"代理模式(Proxy Pattern)\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代理模式(Proxy Pattern)</h1><p>GoF中给出的代理模式的定义为：<br>代理模式给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。<br>代理模式的英文叫做Proxy或Surrogate，它是一种对象结构型模式。<br>代理模式根据其目的和实现可分为很多种类，常用的代理模式包括如下几种：<br>（1）远程代理（Remote Proxy）————为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以是在同一台主机中，也可以是在另一台主机中，远程代理又称为大使（Ambassador）<br>（2）虚拟代理（Virtual Proxy）————如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。<br>（3）保护代理（Protect Proxy）————控制一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。<br>（4）缓冲代理（Cache Proxy）————为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。<br>（5）只能引用代理（Smart Reference Proxy）————当一个对象被引用时，提供一些额外的操作，例如将对象被调用的次数记录下来。<br><img src=\"http://ohlrxdl4p.bkt.clouddn.com/images/QQ截图20170507103646.jpg\" alt=\"\"></p>\n<p>代码实现：<br>1.抽象主题类——BuyTicket.java</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code class=\"lang-java\"><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">interface</span><span class=\"pln\"> </span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> showticket</span><span class=\"pun\">();</span></code></li><li class=\"L2\"><code class=\"lang-java\"><span class=\"pun\">}</span></code></li></ol></pre>\n<p>2.具体主题类——Train.java</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code class=\"lang-java\"><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Train</span><span class=\"pln\"> </span><span class=\"kwd\">implements</span><span class=\"pln\"> </span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"lit\">@Override</span></code></li><li class=\"L2\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> showticket</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L3\"><code class=\"lang-java\"><span class=\"pln\">        </span><span class=\"typ\">System</span><span class=\"pun\">.</span><span class=\"pln\">out</span><span class=\"pun\">.</span><span class=\"pln\">println</span><span class=\"pun\">(</span><span class=\"str\">\"one ticket\"</span><span class=\"pun\">);</span></code></li><li class=\"L4\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L5\"><code class=\"lang-java\"><span class=\"pun\">}</span></code></li></ol></pre>\n<p>3.代理角色类——TicketCenter.java</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code class=\"lang-java\"><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">TicketCenter</span><span class=\"pln\"> </span><span class=\"kwd\">implements</span><span class=\"pln\"> </span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> ticket</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code class=\"lang-java\"></code></li><li class=\"L3\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"typ\">TicketCenter</span><span class=\"pun\">(</span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> ticket</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code class=\"lang-java\"><span class=\"pln\">        </span><span class=\"kwd\">this</span><span class=\"pun\">.</span><span class=\"pln\">ticket </span><span class=\"pun\">=</span><span class=\"pln\"> ticket</span><span class=\"pun\">;</span></code></li><li class=\"L5\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code class=\"lang-java\"></code></li><li class=\"L7\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"lit\">@Override</span></code></li><li class=\"L8\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> showticket</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L9\"><code class=\"lang-java\"><span class=\"pln\">        ticket</span><span class=\"pun\">.</span><span class=\"pln\">showticket</span><span class=\"pun\">();</span></code></li><li class=\"L0\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code class=\"lang-java\"></code></li><li class=\"L2\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> buy</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L3\"><code class=\"lang-java\"><span class=\"pln\">        </span><span class=\"typ\">System</span><span class=\"pun\">.</span><span class=\"pln\">out</span><span class=\"pun\">.</span><span class=\"pln\">println</span><span class=\"pun\">(</span><span class=\"str\">\"by proxy\"</span><span class=\"pun\">);</span></code></li><li class=\"L4\"><code class=\"lang-java\"><span class=\"pln\">        showticket</span><span class=\"pun\">();</span></code></li><li class=\"L5\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code class=\"lang-java\"><span class=\"pun\">}</span></code></li></ol></pre>\n<p>4.客户端测试类</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code class=\"lang-java\"><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">ProxyPattern</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> main</span><span class=\"pun\">(</span><span class=\"typ\">String</span><span class=\"pln\"> args</span><span class=\"pun\">[])</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L2\"><code class=\"lang-java\"><span class=\"pln\">        </span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> x </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Train</span><span class=\"pun\">();</span></code></li><li class=\"L3\"><code class=\"lang-java\"><span class=\"pln\">        </span><span class=\"typ\">TicketCenter</span><span class=\"pln\"> y </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">TicketCenter</span><span class=\"pun\">(</span><span class=\"pln\">x</span><span class=\"pun\">);</span></code></li><li class=\"L4\"><code class=\"lang-java\"><span class=\"pln\">        y</span><span class=\"pun\">.</span><span class=\"pln\">buy</span><span class=\"pun\">();</span></code></li><li class=\"L5\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code class=\"lang-java\"><span class=\"pun\">}</span></code></li></ol></pre>\n<p>运行结果：</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code class=\"lang-html\"><span class=\"pln\">by proxy</span></code></li><li class=\"L1\"><code class=\"lang-html\"><span class=\"pln\">one ticket</span></code></li></ol></pre>\n</div>','2017-05-07',0,34,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(452,'2017-02-28学习笔记','','<p><img src=\"http://ohlrxdl4p.bkt.clouddn.com/images/826546_1482322555369_C5DABB18734059E89A45A0E9170722B0.png\" alt=\"\"></p>','2017-02-28',0,22,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(453,'2017-03-01学习笔记','知识点 1.java中只有值传递，没有引用传递http://guhanjie.iteye.com/blog/1683637 2.final关键字 final修饰变量，则等同于常量. final修饰方法中的参数，称为最终参数. final修饰类，则类不能被继承. final修饰方法，则方法不能被','<h1 id=\"h1-u77E5u8BC6u70B9\"><a name=\"知识点\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>知识点</h1><h4 id=\"h4-1-java-http-guhanjie-iteye-com-blog-1683637\"><a name=\"1.java中只有值传递，没有引用传递  http://guhanjie.iteye.com/blog/1683637\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.java中只有值传递，没有引用传递<a href=\"http://guhanjie.iteye.com/blog/1683637\">http://guhanjie.iteye.com/blog/1683637</a></h4><h4 id=\"h4-2-final-\"><a name=\"2.final关键字\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.final关键字</h4><ul>\r\n<li>final修饰变量，则等同于常量.</li><li>final修饰方法中的参数，称为最终参数.</li><li>final修饰类，则类不能被继承.</li><li>final修饰方法，则方法不能被重写.</li></ul>\r\n<h4 id=\"h4-3-integer-img-src-https-uploadfiles-nowcoder-com-images-20160717-6316247_1468761643205_9f7b85ab04292cf73778d98998a20ed1-alt-\"><a name=\"3.Integer<img src=\"https://uploadfiles.nowcoder.com/images/20160717/6316247_1468761643205_9F7B85AB04292CF73778D98998A20ED1\" alt=\"图片\">\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.Integer<img src=\"https://uploadfiles.nowcoder.com/images/20160717/6316247_1468761643205_9F7B85AB04292CF73778D98998A20ED1\" alt=\"图片\"></h4><h4 id=\"h4-4-java-\"><a name=\"4.java内存模型   点击原文\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.java内存模型 <a href=\"http://blog.csdn.net/ns_code/article/details/17565503\">点击原文</a></h4><p><img src=\"https://uploadfiles.nowcoder.com/images/20161223/415611_1482452184396_6FB53C51539B47559CF0D122A832CF63\" alt=\"\"></p>\r\n<h4 id=\"h4-5-java-reference\"><a name=\"5.java中是没有指针的，有reference\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.java中是没有指针的，有reference</h4><p>第一：指针变量是在栈内存中，它也是有值的，这个值存储的就是地址单元，这个地址就是来自于赋值操作。<br>第二：指针变量有类型，这个类型（如Person）的含义是指针指向的变量在栈内存（不是很确定）中的范围（大小），我理解为是占用的堆内存空间。<br>第三：声明一个对象时，是对“指针变量”的定义。<br>第四：用new关键字在堆内存创建了对象，在赋值时，是把这个对象的首地址传给了这个“指针变量”（即引用型变量）。</p>\r\n<h4 id=\"h4-6-string-\"><a name=\"6.String生成常量\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6.String生成常量</h4><pre><code class=\"lang-java\">String s1=&quot;abc&quot;+&quot;def&quot;;//生成的是一个常量，放在堆内存中\r\nString s2=new String（s1);//s2是一个变量\r\nif(s1.equals(s2))//比较的是字符串的内容\r\n    System.out.println(&quot;.equals succeeded&quot;);//输出\r\nif(s1==s2)//比较的是内存地址，但s1是常量，所以不相等\r\n    System.out.println(&quot;==succeeded&quot;);\r\n</code></pre>\r\n<h4 id=\"h4-7-jsp-\"><a name=\"7.jsp内置对象和属性\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>7.jsp内置对象和属性</h4><p>（１）request对象<br>客户端的请求信息被封装在request对象中，通过它才能了解到客户的需求，然后做出响应。它是HttpServletRequest类的实例。<br>（２）response对象<br>response对象包含了响应客户请求的有关信息，但在JSP中很少直接用到它。它是HttpServletResponse类的实例。<br>（３）session对象<br>session对象指的是客户端与服务器的一次会话，从客户连到服务器的一个WebApplication开始，直到客户端与服务器断开连接为止。它是HttpSession类的实例.<br>（４）out对象<br>out对象是JspWriter类的实例,是向客户端输出内容常用的对象<br>（５）page对象<br>page对象就是指向当前JSP页面本身，有点象类中的this指针，它是java.lang.Object类的实例<br>（６）application对象<br>application对象实现了用户间数据的共享，可存放全局变量。它开始于服务器的启动，直到服务器的关闭，在此期间，此对象将一直存在；这样在用户的前后连接或不同用户之间的连接中，可以对此对象的同一属性进行操作；在任何地方对此对象属性的操作，都将影响到其他用户对此的访问。服务器的启动和关闭决定了application对象的生命。它是ServletContext类的实例。<br>（７）exception对象<br>exception对象是一个例外对象，当一个页面在运行过程中发生了例外，就产生这个对象。如果一个JSP页面要应用此对象，就必须把isErrorPage设为true，否则无法编译。他实际上是java.lang.Throwable的对象<br>（８）pageContext对象<br>pageContext对象提供了对JSP页面内所有的对象及名字空间的访问，也就是说他可以访问到本页所在的SESSION，也可以取本页面所在的application的某一属性值，他相当于页面中所有功能的集大成者，它的本 类名也叫pageContext。<br>（９）config对象<br>config对象是在一个Servlet初始化时，JSP引擎向它传递信息用的，此信息包括Servlet初始化时所要用到的参数（通过属性名和属性值构成）以及服务器的有关信息（通过传递一个ServletContext对象）</p>','2017-03-01',0,21,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(454,'2017-03-02学习笔记','知识点 一、static public class Spike\r\n{\r\n    public static void main(String[] args)\r\n    {\r\n        Counter a = new Counter();\r\n        System.out.println(a.increment());\r\n        System.out.println(a.anot','<h1 id=\"h1-u77E5u8BC6u70B9\"><a name=\"知识点\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>知识点</h1><h4 id=\"h4--static\"><a name=\"一、static\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、static</h4><pre><code class=\"lang-java\">public class Spike\r\n{\r\n    public static void main(String[] args)\r\n    {\r\n        Counter a = new Counter();\r\n        System.out.println(a.increment());\r\n        System.out.println(a.anotherIncrement());\r\n        Counter b = new Counter();\r\n        System.out.println(b.increment());\r\n    }\r\n}\r\nclass Counter\r\n{\r\n    private static int count = 0;\r\n    public int increment()\r\n    {\r\n        return count++;\r\n    }\r\n    public int anotherIncrement()\r\n    {\r\n        return ++count;\r\n    }\r\n}\r\n</code></pre>\r\n<p>count是静态变量，为所有对象所共享，因此不管a.increment()还是b.increment()都会使count持续增加。<br>increment()方法返回当前count值，然后count增加1<br>antoherIncrement()方法让count增加1，然后返回count值<br>第一次a.increment()返回值为0，此时count值为1<br>第二次a.anotherIncrement()先让count+1再返回，返回值为2<br>第三次b.increment()先返回count当前值2，然后count+1</p>\r\n<h4 id=\"h4--aop-\"><a name=\"二、AOP面向切面\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、AOP面向切面</h4><p>AOP的概念是Aspected Oriented Programming 面向方面编程。<br>  好处：AOP将程序分解成各个方面或者说关注点。这使得可以模块化，相当横向上分切了。它可以解决OOP和过程化方法不能够很好解决的横切（crosscut）问题，如：事务、安全、日志等横切关注。<br>  实现AOP有几种方式:<br>  1.Spring 1.2版本中通过ProxyFactoryBean来实现aop,即通过动态代理来实现的,Aspect必须继承MethodBeforeAdvice,MethodAfterAdvice等<br>  2.Spring 2.0 AOP需要改的是FBI 这个类，而且它也不需要再实现某些接口<br>  3.三使用标注（<a href=\"https://github.com/AspectJ\" title=\"&#64;AspectJ\" class=\"at-link\">@AspectJ</a>）实现AOP<br>    AOP 和 OOP的区别：</p>\r\n<pre><code>```html\r\n 1. 面向方面编程 AOP 偏重业务处理过程的某个步骤或阶段，强调降低模块之间的耦合度，使代码拥有更好的移植性。  \r\n 2. 面向对象编程 (oop) 则是对业务分析中抽取的实体进行方法和属性的封装。\r\n ```\r\n</code></pre><p>也可以说 AOP 是面向业务中的动词领域， OOP 面向名词领域。<br>AOP 的一个很重要的特点是源代码无关性，也就是说如果我们的系统中引用了 AOP 组件，即使我们把该组件去掉，系统代码也应该能够编译通过。要实现这一点，可以使用动态 proxy 模式。</p>\r\n<h4 id=\"h4--jdbc-\"><a name=\"三、jdbc桥接模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、jdbc桥接模式</h4><p>桥接模式：<br>定义 ：将抽象部分与它的实现部分分离，使它们都可以独立地变化。<br>意图 ：将抽象与实现解耦。<br>桥接模式所涉及的角色</p>\r\n<ol>\r\n<li>Abstraction ：定义抽象接口，拥有一个Implementor类型的对象引用</li><li>RefinedAbstraction ：扩展Abstraction中的接口定义</li><li>Implementor ：是具体实现的接口，Implementor和RefinedAbstraction接口并不一定完全一致，实际上这两个接口可以完全不一样Implementor提供具体操作方法，而Abstraction提供更高层次的调用</li><li>ConcreteImplementor ：实现Implementor接口，给出具体实现<br>Jdk中的桥接模式：JDBC<br>JDBC连接 数据库 的时候，在各个数据库之间进行切换，基本不需要动太多的代码，甚至丝毫不动，原因就是JDBC提供了统一接口，每个数据库提供各自的实现，用一个叫做数据库驱动的程序来桥接就行了<h4 id=\"h4--\"><a name=\"四、抽象类\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>四、抽象类</h4>抽象类和普通类有三点区别：<br>1）抽象方法必须为public和protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public。<br>2）抽象类不能用来创建对象，但是它可以有构造方法，用来帮助子类实例化。<br>3）如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为abstract类。<h4 id=\"h4--\"><a name=\"五、接口\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>五、接口</h4>接口的主要特点<br>1）接口中的成员变量默认都是public、static、final类型的，必须被显示初始化。<br>2）接口中的方法默认都是public、abstract类型的。<br>3）接口中只能包含public、static、final类型的成员变量和public、abstract类型的成员方法。<br>4）接口没有构造方法，不能被实例化。<br>5）一个接口不能实现另一个接口，但它可以继承多个其他接口。<br>6）接口必须通过类来实现它的抽象方法。<br>7）与子类继承抽象父类相似，当类实现了某个接口时，它必须实现接口中所有的抽象方法，否则这个类必须被定义为抽象类。<br>8）一个类只能继承一个直接的父类，但能实现多个接口。<h4 id=\"h4--\"><a name=\"六、抽象类和接口的区别\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>六、抽象类和接口的区别</h4>1）抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract方法；<br>2）抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；<br>3）接口中不能含有静态代码块以及静态方法，而抽象类尅有静态代码块和静态方法；<br>4）一个类只能继承一个抽象类，而一个类却可以实现多个接口。<br>5）抽象类中的方法子类必须全部实现，不然子类也是抽象类，而接口中的抽象方法子类必须全部实现，是可选择实现的。<br>6）抽象类是一种模板设计模式，而接口时一种行为规范。</li></ol>','2017-03-02',0,21,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(455,'2017-03-03学习笔记','一、String StringBuffer.toString()源码： @Override\r\npublic synchronized String toString() {\r\n    if (toStringCache == null) {\r\n        toStringCache = Arrays.copyOfRange(value, 0, count);\r\n    }\r\n    retur','<h4 id=\"h4--string\"><a name=\"一、String\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、String</h4><p>StringBuffer.toString()源码：</p>\r\n<pre><code class=\"lang-java\">@Override\r\npublic synchronized String toString() {\r\n    if (toStringCache == null) {\r\n        toStringCache = Arrays.copyOfRange(value, 0, count);\r\n    }\r\n    return new String(toStringCache, true);\r\n}\r\n</code></pre>\r\n<p>Arrays.copyOfRange用的是System.arraycopy</p>\r\n<pre><code class=\"lang-java\">public static char[] copyOfRange(char[] original, int from, int to) {\r\n        int newLength = to - from;\r\n        if (newLength &lt; 0)\r\n            throw new IllegalArgumentException(from + &quot; &gt; &quot; + to);\r\n        char[] copy = new char[newLength];\r\n        System.arraycopy(original, from, copy, 0,\r\n                         Math.min(original.length - from, newLength));\r\n        return copy;\r\n    }\r\n</code></pre>\r\n<p>1.String是值传入，不是引用传入。<br>2.String对String  类型进行改变的时候其实都等同于生成了一个新的  String  对象，然后将指针指向新的  String  对象，而不是StringBuffer；StringBuffer每次结果都会对  StringBuffer  对象本身进行操作，而不是生成新的对象，再改变对象引用。<br>3.效率比较String&lt;StringBuffer&lt;StringBuilder，但是在 String S1 = “This is only a” + “ simple” + “ test”时，String效率最高。</p>\r\n<h4 id=\"h4--jvm-\"><a name=\"二、jvm知识图谱\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、jvm知识图谱</h4><p><a href=\"https://zhuanlan.zhihu.com/p/25511795\">引用自知乎</a><br><img src=\"https://pic2.zhimg.com/v2-701563ac1fe745fc8e1234c96e82ac99_r.jpg\" alt=\"\"></p>\r\n<h4 id=\"h4--treemap-linkhashmap\"><a name=\"三、Treemap、LinkHashMap\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、Treemap、LinkHashMap</h4><p>1.TreeMap取出来的是排序后的键值对。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。<br>2.LinkedHashMap 是HashMap的一个子类，如果需要输出的顺序和输入的相同,那么用LinkedHashMap可以实现,它还可以按读取顺序来排列。</p>\r\n<h4 id=\"h4--sql-\"><a name=\"四、sql模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>四、sql模式</h4><p>MySQL数据库中，变量分为 系统变量（以”@@”开头）和用户自定义变量。系统变量分为全局系统变量(global)和会话系统变量(session)。<br>@<a href=\"https://github.com/global\" title=\"&#64;global\" class=\"at-link\">@global</a>     仅用于访问全局系统变量的值；<br>@<a href=\"https://github.com/session\" title=\"&#64;session\" class=\"at-link\">@session</a>  仅用于访问会话系统变量的值；<br>@@              先访问会话系统变量的值，若不存在则去访问全局系统变量的值；<br>sql_mode 为系统变量，既是全局系统变量，又是会话系统变量。</p>\r\n<h4 id=\"h4--\"><a name=\"五、代码的执行顺序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>五、代码的执行顺序</h4><p>父类Ｂ静态代码块-&gt;子类Ａ静态代码块-&gt;父类Ｂ非静态代码块-&gt;父类Ｂ构造函数-&gt;子类Ａ非静态代码块-&gt;子类Ａ构造函数<br><img src=\"http://ohlrxdl4p.bkt.clouddn.com/images/QQ截图20170303165728.jpg\" alt=\"\"></p>','2017-03-03',0,25,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(456,'ifhifhajfe','hello','<h1 id=\"h1-hello\"><a name=\"hello\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>hello</h1>','2017-03-05',0,25,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(457,'2017-03-05学习笔记','java的堆，栈，静态代码区（常量区） 详解','<p><a href=\"http://blog.csdn.net/u012031380/article/details/54981472\"> java的堆，栈，静态代码区（常量区） 详解</a></p>','2017-03-05',0,25,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(458,'java归并排序','package datastruct;\r\n\r\n/**\r\n * Created by Zephery on 2017/3/3.\r\n */\r\npublic class Solution {\r\n    public static void printArray(int[] arr, int i, int j) {\r\n        System.out.print(\"[\");\r\n        for','<pre><code class=\"lang-java\">package datastruct;\r\n\r\n/**\r\n * Created by Zephery on 2017/3/3.\r\n */\r\npublic class Solution {\r\n    public static void printArray(int[] arr, int i, int j) {\r\n        System.out.print(&quot;[&quot;);\r\n        for (int k = i; k &lt; j; k++) {\r\n            System.out.print(arr[k] + &quot;,&quot;);\r\n        }\r\n        System.out.print(arr[j] + &quot;]&quot;);\r\n    }\r\n\r\n    private static void mergesort(int[] arr, int i, int j) {\r\n        int mid = 0;\r\n        if (i &lt; j) {\r\n            mid = (i + j) / 2;\r\n            mergesort(arr, i, mid);\r\n            mergesort(arr, mid + 1, j);\r\n            merge(arr, i, mid, j);\r\n        }\r\n    }\r\n\r\n    private static void merge(int[] arr, int i, int mid, int j) {\r\n        System.out.print(&quot;Left:&quot;);\r\n        printArray(arr, i, mid);\r\n        System.out.println(&quot;Right:&quot;);\r\n        printArray(arr, mid + 1, j);\r\n        System.out.println();\r\n        int temp[] = new int[arr.length];\r\n        int l = i;\r\n        int r = j;\r\n        int m = mid + 1;\r\n        int k = l;\r\n        while (l &lt;= mid &amp;&amp; m &lt;= r) {\r\n            if (arr[l] &lt;= arr[m]) {\r\n                temp[k++] = arr[l++];\r\n            } else {\r\n                temp[k++] = arr[m++];\r\n            }\r\n        }\r\n        while (l &lt;= mid) {\r\n            temp[k++] = arr[l++];\r\n        }\r\n        while (m &lt;= r) {\r\n            temp[k++] = arr[m++];\r\n        }\r\n        for (int i1 = i; i1 &lt;= j; i1++) {\r\n            arr[i1] = temp[i1];\r\n        }\r\n        System.out.print(&quot;After Merge:&quot;);\r\n        printArray(arr, i, j);\r\n        System.out.println();\r\n    }\r\n\r\n    public static void main(String args[]) {\r\n        int[] arr = {9, 4, 8, 3, 1, 2, 5};\r\n        System.out.print(&quot;Initial Array:&quot;);\r\n        printArray(arr, 0, arr.length - 1);\r\n        System.out.println();\r\n        mergesort(arr, 0, arr.length - 1);\r\n    }\r\n}\r\n</code></pre>\r\n<pre><code class=\"lang-js\">Initial Array:[9,4,8,3,1,2,5]\r\nLeft:[9]Right:\r\n[4]\r\nAfter Merge:[4,9]\r\nLeft:[8]Right:\r\n[3]\r\nAfter Merge:[3,8]\r\nLeft:[4,9]Right:\r\n[3,8]\r\nAfter Merge:[3,4,8,9]\r\nLeft:[1]Right:\r\n[2]\r\nAfter Merge:[1,2]\r\nLeft:[1,2]Right:\r\n[5]\r\nAfter Merge:[1,2,5]\r\nLeft:[3,4,8,9]Right:\r\n[1,2,5]\r\nAfter Merge:[1,2,3,4,5,8,9]\r\n</code></pre>','2017-03-06',0,26,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(459,'2017-03-10学习笔记','1.Integer和int，装箱拆箱 1、基本型和基本型封装型进行“==”运算符的比较，基本型封装型将会自动拆箱变为基本型后再进行比较，因此Integer(0)会自动拆箱为int类型再进行比较，显然返回true； 2、两个Integer类型进行“==”比较，如果其值在-128至127，那么返回true，否则返回false, 这跟Integer.valueOf()的缓冲对象有关，这里不进行赘述。 3','<h1 id=\"h1-1-integer-int-\"><a name=\"1.Integer和int，装箱拆箱\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.Integer和int，装箱拆箱</h1><p>1、基本型和基本型封装型进行“==”运算符的比较，基本型封装型将会自动拆箱变为基本型后再进行比较，因此Integer(0)会自动拆箱为int类型再进行比较，显然返回true；<br>2、两个Integer类型进行“==”比较，如果其值在-128至127，那么返回true，否则返回false, 这跟Integer.valueOf()的缓冲对象有关，这里不进行赘述。<br>3、两个基本型的封装型进行equals()比较，首先equals()会比较类型，如果类型相同，则继续比较值，如果值也相同，返回true<br>4、基本型封装类型调用equals(),但是参数是基本类型，这时候，先会进行自动装箱，基本型转换为其封装类型，再进行3中的比较。</p>\r\n<pre><code class=\"lang-java\">int a=257;\r\nInteger b=257;\r\nInteger c=257;\r\nInteger b2=57;\r\nInteger c2=57;\r\nSystem.out.println(a==b);\r\n//System.out.println(a.equals(b));  编译出错，基本型不能调用equals()\r\nSystem.out.println(b.equals(257.0));\r\nSystem.out.println(b==c);\r\nSystem.out.println(b2==c2);\r\n</code></pre>\r\n<p>因此上面的代码的结果因此为 true, false, false, true</p>\r\n<h1 id=\"h1-2-\"><a name=\"2.线程调度\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.线程调度</h1><p>分为协同式调度和抢占式调度，Java使用的是抢占式调度，也就是每个线程将由操作系统来分配执行时间，线程的切换不由线程本身来决定（协同式调度）。这就是平台独立的原因。</p>\r\n<h1 id=\"h1-3-\"><a name=\"3.重载，重写\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.重载，重写</h1><p>重写：<br>两同，两小，一大<br>两同：方法名，方法参数列表相同。<br>两小：抛出的异常类型要小于等于父类，返回值类型要小于等于父类<br>一大：访问权限大于等于父类。<br>重载：<br>在同一个类中，方法名和方法参数列表不同，其他的（访问权限、返回值）随意。</p>\r\n<h1 id=\"h1-4-jvm-\"><a name=\"4.  JVM面试题\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.<a href=\"http://blog.csdn.net/hsk256/article/details/49104955\">JVM面试题</a></h1>','2017-03-10',0,25,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(460,'2017-03-12学习笔记','1.继承的加载顺序 执行顺序大体上可以说是先父类后子类，父类static域 ==》子类static域 ==》父类数据成员域 ==》父类构造器 ==》子类数据成员域 ==》子类构造器 2.优化Hibernate所鼓励的7大措施： 1.尽量使用many-to-one，避免使用单项one-to-many 2.灵活使用单向one-to-many 3.不用一对一，使用多对一代替一对一 4.配置对象缓存，不使','<h4 id=\"h4-1-\"><a name=\"1.  继承的加载顺序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.<a href=\"http://www.cnblogs.com/SirSmith/p/5536288.html\">继承的加载顺序</a></h4><p><img src=\"http://images2015.cnblogs.com/blog/452847/201605/452847-20160527221410288-2119099273.png\" alt=\"\"></p>\r\n<p>执行顺序大体上可以说是先父类后子类，父类static域 ==》子类static域 ==》父类数据成员域 ==》父类构造器 ==》子类数据成员域 ==》子类构造器</p>\r\n<h4 id=\"h4-2-hibernate-7-\"><a name=\"2.优化Hibernate所鼓励的7大措施：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.优化Hibernate所鼓励的7大措施：</h4><p>1.尽量使用many-to-one，避免使用单项one-to-many<br>2.灵活使用单向one-to-many<br>3.不用一对一，使用多对一代替一对一<br>4.配置对象缓存，不使用集合缓存<br>5.一对多使用Bag 多对一使用Set<br>6.继承使用显示多态 HQL:from object polymorphism=”exlicit” 避免查处所有对象<br>7.消除大表，使用二级缓存</p>\r\n<h4 id=\"h4-3-java-\"><a name=\"3.java中的数据类型分类：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.java中的数据类型分类：</h4><p>基本数据类型（或叫做原生类、内置类型）8种：<br>    整数：byte，short，int，long（默认是int类型）<br>    浮点类型： float，double（默认是double类型）<br>    字符类型：char<br>    布尔类型：boolean<br>引用数据类型3种：数组，类，接口</p>\r\n<h4 id=\"h4-4-\"><a name=\"4.触发器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.触发器</h4><p>drop trigger 删除触发器<br>Drop用于删除数据表或数据库，或删除数据表字段。<br>remove：删除数据库文件<br>Truncate：删除数据表中的数据（仅数据表中的数据，不删除表）。</p>','2017-03-12',0,25,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(461,'2017-03-14学习笔记','1.Servlet的生命周期分为5个阶段：加载、创建、初始化、处理客户请求、卸载。 (1)加载：容器通过类加载器使用servlet类对应的文件加载servlet (2)创建：通过调用servlet构造函数创建一个servlet对象 (3)初始化：调用init方法初始化 (4)处理客户请求：每当有一个客户请求，容器会创建一个线程来处理客户请求 (5)卸载：调用destroy方法让servlet自己释','<h4 id=\"h4-1-servlet-5-\"><a name=\"1.Servlet的生命周期分为5个阶段：加载、创建、初始化、处理客户请求、卸载。\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.Servlet的生命周期分为5个阶段：加载、创建、初始化、处理客户请求、卸载。</h4><p>(1)加载：容器通过类加载器使用servlet类对应的文件加载servlet<br>(2)创建：通过调用servlet构造函数创建一个servlet对象<br>(3)初始化：调用init方法初始化<br>(4)处理客户请求：每当有一个客户请求，容器会创建一个线程来处理客户请求<br>(5)卸载：调用destroy方法让servlet自己释放其占用的资源</p>\r\n<h4 id=\"h4-2-jsp\"><a name=\"2.JSP\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.JSP</h4><p><img src=\"http://uploadfiles.nowcoder.com/images/20160308/595432_1457414324036_C3D4EB7F2D61708D0C0BE2921A45B74D\" alt=\"\"></p>','2017-03-14',0,24,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(462,'2017-03-17学习笔记','1.GC线程是否和守护线程 2.java堆排序','<h4 id=\"h4-1-gc-\"><a name=\"1.GC线程是否和守护线程\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.GC线程是否和守护线程</h4><h4 id=\"h4-2-java-\"><a name=\"2.java堆排序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.java堆排序</h4>','2017-03-17',0,23,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(463,'重载与重写','目前的问题：父类的功能无法满足子类的需求。 方法重写的前提： 必须要存在继承的关系。 方法的重写: 子父类出了同名的函数，这个我们就称作为方法的重写。 什么是时候要使用方法的重写：父类的功能无法满足子类的需求时。 方法重写要注意的事项： 1.方法重写时， 方法名与形参列表必须一致。 2.方法重写时，子类的权限修饰符必须要大于或者等于父类的权限修饰符。 3.方法重写时，子类的返回值类型必须要小于或者','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><p>目前的问题：父类的功能无法满足子类的需求。</p>\n<p>方法重写的前提： 必须要存在继承的关系。</p>\n<p>方法的重写: 子父类出了同名的函数，这个我们就称作为方法的重写。</p>\n<p>什么是时候要使用方法的重写：父类的功能无法满足子类的需求时。</p>\n<p>方法重写要注意的事项：<br>    1.方法重写时， 方法名与形参列表必须一致。<br>    2.方法重写时，子类的权限修饰符必须要大于或者等于父类的权限修饰符。<br>    3.方法重写时，子类的返回值类型必须要小于或者 等于父类的返回值类型。<br>    4.方法重写时， 子类抛出的异常类型要小于或者等于父类抛出的异常类型。<br>            Exception(最坏)<br>            RuntimeException(小坏)</p>\n<p>方法的重载：在一个类中 存在两个或者两个 以上的同名函数,称作为方法重载。</p>\n<p>方法重载的要求</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"lit\">1.</span><span class=\"pln\"> </span><span class=\"pun\">函数名要一致。</span></code></li><li class=\"L1\"><code><span class=\"lit\">2.</span><span class=\"pln\"> </span><span class=\"pun\">形参列表不一致（形参的个数或形参</span><span class=\"pln\"> </span><span class=\"pun\">的类型不一致）</span></code></li><li class=\"L2\"><code><span class=\"lit\">3.</span><span class=\"pln\"> </span><span class=\"pun\">与返回值类型无关。</span></code></li></ol></pre></div>','2017-03-21',0,26,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(464,'垃圾回收算法','垃圾回收算法 1、标记-清除算法 2、复制算法 3、标记-整理算法 一、标记-清除算法 标记-清除算法采用从根集合进行扫描，对存活的对象对象标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收，如上图所示。 标记-清除算法不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效，但由于标记-清除算法直接回收不存活的对象，因此会造成内存碎片！ 二、复制算法 复制算法','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h2 id=\"h2-u5783u573Eu56DEu6536u7B97u6CD5\"><a name=\"垃圾回收算法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>垃圾回收算法</h2><p>1、标记-清除算法<br>2、复制算法<br>3、标记-整理算法</p>\n<h4 id=\"h4--\"><a name=\"一、标记-清除算法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、标记-清除算法</h4><p><img src=\"http://dl2.iteye.com/upload/attachment/0075/0386/29ae17ad-f8af-38b4-9e25-28ef3550858f.jpg\" alt=\"\">标记-清除算法采用从根集合进行扫描，对存活的对象对象标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收，如上图所示。<br>标记-清除算法不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效，但由于标记-清除算法直接回收不存活的对象，因此会造成内存碎片！</p>\n<h4 id=\"h4--\"><a name=\"二、复制算法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、复制算法</h4><p><img src=\"http://dl2.iteye.com/upload/attachment/0075/0388/91a656d4-f08a-377b-8eea-5785c2932533.jpg\" alt=\"\"><br>复制算法采用从根集合扫描，并将存活对象复制到一块新的，没有使用过的空间中，这种算法当控件存活的对象比较少时，极为高效，但是带来的成本是需要一块内存交换空间用于进行对象的移动。也就是我们前面提到的s0 s1等空间。</p>\n<h4 id=\"h4--\"><a name=\"三、标记-整理算法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、标记-整理算法</h4><p><img src=\"http://dl2.iteye.com/upload/attachment/0075/0390/6ba95f80-c7bc-3d09-b927-ac09297e9920.jpg\" alt=\"\"><br> 标记-整理算法采用标记-清除算法一样的方式进行对象的标记，但在清除时不同，在回收不存活的对象占用的空间后，会将所有的存活对象往左端空闲空间移动，并更新对应的指针。标记-整理算法是在标记-清除算法的基础上，又进行了对象的移动，因此成本更高，但是却解决了内存碎片的问题。</p>\n</div>','2017-04-09',0,29,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(465,'java分代回收','一、新生代内存的回收（minor GC）主要采用复制算法，下图展示了minor GC的执行过程。 二、对于新生代和旧生代，JVM可使用很多种垃圾回收器进行垃圾回收，下图展示了不同生代不通垃圾回收器，其中两个回收器之间有连线表示这两个回收器可以同时使用。 而这些垃圾回收器又分为串行回收方式、并行回收方式合并发回收方式执行，分别运用于不同的场景。如下图所示 三、收集器 1.Serial收集器 看名字我','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h2 id=\"h2--minor-gc-minor-gc-\"><a name=\"一、新生代内存的回收（minor GC）主要采用复制算法，下图展示了minor GC的执行过程。\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、新生代内存的回收（minor GC）主要采用复制算法，下图展示了minor GC的执行过程。</h2><p><img src=\"http://dl2.iteye.com/upload/attachment/0075/0392/732c7557-aa9a-3551-b14d-f543c5b0c94b.jpg\" alt=\"\"></p>\n<h2 id=\"h2--jvm-\"><a name=\"二、对于新生代和旧生代，JVM可使用很多种垃圾回收器进行垃圾回收，下图展示了不同生代不通垃圾回收器，其中两个回收器之间有连线表示这两个回收器可以同时使用。\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、对于新生代和旧生代，JVM可使用很多种垃圾回收器进行垃圾回收，下图展示了不同生代不通垃圾回收器，其中两个回收器之间有连线表示这两个回收器可以同时使用。</h2><p><img src=\"http://dl2.iteye.com/upload/attachment/0075/0394/0172f624-9018-3642-bf26-05a2c3071639.jpg\" alt=\"\"><br>而这些垃圾回收器又分为串行回收方式、并行回收方式合并发回收方式执行，分别运用于不同的场景。如下图所示<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0396/c962c2ad-273f-3de4-b2e3-a4dd8b946215.jpg\" alt=\"\"></p>\n<h2 id=\"h2--\"><a name=\"三、收集器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、收集器</h2><h4 id=\"h4-1-serial-\"><a name=\"1.Serial收集器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.Serial收集器</h4><p>看名字我们都可以看的出来，这个属于串行收集器。其运行示意图如下<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0398/681da5ca-5eff-3984-bece-3d80dfe905be.jpg\" alt=\"\"><br>    收集器是历史最悠久的一个回收器，JDK1.3之前广泛使用这个收集器，目前也是ClientVM下 ServerVM 4核4GB以下机器的默认垃圾回收器。串行收集器并不是只能使用一个CPU进行收集，而是当JVM需要进行垃圾回收的时候，需要中断所有的用户线程，知道它回收结束为止，因此又号称“Stop The World” 的垃圾回收器。注意，JVM中文名称为java虚拟机，因此它就像一台虚拟的电脑一样在工作，而其中的每一个线程就被认为是JVM的一个处理器，因此大家看到图中的CPU0、CPU1实际为用户的线程，而不是真正机器的CPU，大家不要误解哦。<br>    串行回收方式适合低端机器，是Client模式下的默认收集器，对CPU和内存的消耗不高，适合用户交互比较少，后台任务较多的系统。<br>    Serial收集器默认新旧生代的回收器搭配为Serial+ SerialOld</p>\n<h4 id=\"h4-2-parnew-\"><a name=\"2.ParNew收集器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.ParNew收集器</h4><p>ParNew收集器其实就是多线程版本的Serial收集器，其运行示意图如下<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0400/6443b39c-ed33-3d93-a690-87e646439561.jpg\" alt=\"\"><br>同样有Stop The World的问题，他是多CPU模式下的首选回收器（该回收器在单CPU的环境下回收效率远远低于Serial收集器，所以一定要注意场景哦），也是Server模式下的默认收集器。</p>\n<h4 id=\"h4-3-parallelscavenge\"><a name=\"3.ParallelScavenge\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.ParallelScavenge</h4><p>ParallelScavenge又被称为是吞吐量优先的收集器，器运行示意图如下<br><img src=\"http://dl.iteye.com/upload/attachment/0075/0402/5007beba-0b0e-3cf4-b146-c28b6c0dd696.jpg\" alt=\"\"><br> ParallelScavenge<br>所提到的吞吐量=程序运行时间/(JVM执行回收的时间+程序运行时间),假设程序运行了100分钟，JVM的垃圾回收占用1分钟，那么吞吐量就是99%。在当今网络告诉发达的今天，良好的响应速度是提升用户体验的一个重要指标，多核并行云计算的发展要求程序尽可能的使用CPU和内存资源，尽快的计算出最终结果，因此在交互不多的云端，比较适合使用该回收器。</p>\n<h4 id=\"h4-4-parallelold\"><a name=\"4.ParallelOld\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.ParallelOld</h4><p>ParallelOld是老生代并行收集器的一种，使用标记整理算法、是老生代吞吐量优先的一个收集器。这个收集器是JDK1.6之后刚引入的一款收集器，我们看之前那个图之间的关联关系可以看到，早期没有ParallelOld之前，吞吐量优先的收集器老生代只能使用串行回收收集器，大大的拖累了吞吐量优先的性能，自从JDK1.6之后，才能真正做到较高效率的吞吐量优先。其运行示意图如下<br><img src=\"http://dl.iteye.com/upload/attachment/0075/0406/9a14da85-f943-3408-ba88-c6bb3842a792.jpg\" alt=\"\"></p>\n<h4 id=\"h4-5-serialold\"><a name=\"5.SerialOld\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.SerialOld</h4><p>SerialOld是旧生代Client模式下的默认收集器，单线程执行；在JDK1.6之前也是ParallelScvenge回收新生代模式下旧生代的默认收集器，同时也是并发收集器CMS回收失败后的备用收集器。其运行示意图如下<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0404/ce7aabd5-b0e0-3cda-9b6c-607cf6ebf689.jpg\" alt=\"\"></p>\n<h4 id=\"h4-5-cms\"><a name=\"5.CMS\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.CMS</h4><p>CMS又称响应时间优先(最短回收停顿)的回收器，使用并发模式回收垃圾，使用标记-清除算法，CMS对CPU是非常敏感的，它的回收线程数=（CPU+3）/4，因此当CPU是2核的实惠，回收线程将占用的CPU资源的50%，而当CPU核心数为4时仅占用25%。他的运行示意图如下<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0408/4239228b-879f-382f-81c6-5c32799886d6.jpg\" alt=\"\"><br>模式主要分为四个过程：<br>1.初始标记<br>2.并发标记<br>3.重新标记<br>4.并发清除<br>在初始标记的时候，需要中断所有用户线程，在并发标记阶段，用户线程和标记线程<br>并发执行，而在这个过程中，随着内存引用关系的变化，可能会发生原来标记的对象被释放，进而引发新的垃圾，因此可能会产生一系列的浮动垃圾，不能被回收。</p>\n<p>CMS 为了确保能够扫描到所有的对象，避免在Initial Marking 中还有未标识到的对象，采用的方法为找到标记了的对象，并将这些对象放入Stack 中，扫描时寻找此对象依赖的对象，如果依赖的对象的地址在其之前，则将此对象进行标记，并同时放入Stack 中，如依赖的对象地址在其之后，则仅标记该对象。<br>在进行Concurrent Marking 时minor GC 也可能会同时进行，这个时候很容易造成旧生代对象引用关系改变，CMS 为了应对这样的并发现象，提供了一个Mod Union Table 来进行记录，在这个Mod Union Table中记录每次minor GC 后修改了的Card 的信息。这也是ParallelScavenge不能和CMS一起使用的原因。<br>CMS产生浮动垃圾的情况请见如下示意图<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0410/60e7c659-790a-3405-af70-9ca4cfd9258d.jpg\" alt=\"\"><br>在运行回收过后，c就变成了浮动垃圾。<br>由于CMS会产生浮动垃圾，当回收过后，浮动垃圾如果产生过多，同时因为使用标记-清除算法会产生碎片，可能会导致回收过后的连续空间仍然不能容纳新生代移动过来或者新创建的大资源，因此会导致CMS回收失败，进而触发另外一次FULL GC，而这时候则采用SerialOld进行二次回收。<br>同时CMS因为可能产生浮动垃圾，而CMS在执行回收的同时新生代也有可能在进行回收操作，为了保证旧生代能够存放新生代转移过来的数据，CMS在旧生代内存到达全部容量的68%就触发了CMS的回收！</p>\n<h4 id=\"h4-7-garbagefirst-g1-\"><a name=\"7.GarbageFirst(G1)\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>7.GarbageFirst(G1)</h4><p>我们再来看垃圾回收器的总图，刚才我们可以看到，我在图上标记了一个？，其实这是一个新的垃圾回收器，既可以回收新生代也可以回收旧生代，SunHotSpot 1.6u14以上EarlyAccess版本加入了这个回收器，sun公司预期SunHotSpot1.7发布正式版，他是商用高性能垃圾回收器，通过重新划分内存区域，整合优化CMS，同时注重吞吐量和响应时间，但是杯具的是被Oracle收购之后这个收集器属于商用收费收集器，因此目前基本上没有人使用，我们在这里也就不多介绍，更多信息可以参考oracle新版本JDK说明。</p>\n</div>','2017-04-09',0,31,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(466,'java汇编','java 汇编 http://download.csdn.net/download/jiangfuqiang/8403497','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><p>java 汇编<br><a href=\"http://download.csdn.net/download/jiangfuqiang/8403497\">http://download.csdn.net/download/jiangfuqiang/8403497</a></p>\n</div>','2017-04-10',0,25,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(467,'jvm','-XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><p>-XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly</p>\n</div>','2017-04-10',0,24,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(468,'Java堆.栈和常量池 笔记','Java堆.栈和常量池 笔记','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><p><a href=\"http://www.iteye.com/topic/634530\">Java堆.栈和常量池 笔记</a></p>\n</div>','2017-04-23',0,20,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(469,'工厂模式','工厂模式 目录 何为工厂模式 工厂方法与抽象工厂 如何在Java EE中通过@Producers与@Inject注解实现工厂模式 如何创建自定义注解以及通过@Qualifier消除具体实现之间的歧义 工厂模式有两种模式：工厂方法和抽象方法。它们的意图是一样的：提供一个接口，在不指定具体类的情况下创建相关或依赖的一系列对象。 一.何为工厂模式 工厂的目的在于创建对象。创建的逻辑被封装在工厂中，要么提','<h1 id=\"h1-u5DE5u5382u6A21u5F0F\"><a name=\"工厂模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>工厂模式</h1><p>目录</p>\r\n<ul>\r\n<li>何为工厂模式</li><li>工厂方法与抽象工厂</li><li>如何在Java EE中通过<a href=\"https://github.com/Producers\" title=\"&#64;Producers\" class=\"at-link\">@Producers</a>与<a href=\"https://github.com/Inject\" title=\"&#64;Inject\" class=\"at-link\">@Inject</a>注解实现工厂模式</li><li>如何创建自定义注解以及通过<a href=\"https://github.com/Qualifier\" title=\"&#64;Qualifier\" class=\"at-link\">@Qualifier</a>消除具体实现之间的歧义<br>工厂模式有两种模式：工厂方法和抽象方法。它们的意图是一样的：提供一个接口，在不指定具体类的情况下创建相关或依赖的一系列对象。</li></ul>\r\n<h3 id=\"h3--\"><a name=\"一.何为工厂模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一.何为工厂模式</h3><p>工厂的目的在于创建对象。创建的逻辑被封装在工厂中，要么提供一个方法来返回新创建的对象（工厂方法模式），要么将对象的创建委托给子类（抽象工厂模式）。<br>客户端不必考虑接口或类的不同实现，它只需通过工厂（工厂）获取接口实现的一个实例的即可，这样客户端与对象的创建就实现了解耦<br>解耦是应用依赖反转原则的结果，这带来了很多好处，其中最重要的好处就是实现了高层类与底层类之间的解耦。通过解耦，具体类实现的变化不会影响到客户端，这降低了类与类之间的耦合，并提升了灵活性。</p>\r\n<h3 id=\"h3--\"><a name=\"二.工厂方法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二.工厂方法</h3><p>GoF一书是这样描述工程方法模式的：“定义一个用于创建对象的接口，不过让子类决定实例化那个类”<br>工厂极大降低了new关键字的使用次数，并且将初始化过程与不同的具体实现封装起来。将这些需求中心化可以极大减少向系统中添加或删除具体类的影响以及具体的类依赖的影响。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src=\"http://ohlrxdl4p.bkt.clouddn.com/images/QQ截图20170506134421.jpg\" alt=\"\"><br><strong>1.使用普通代码实现工厂方法</strong><br>被具体实现继承的DrinksMachine抽象类</p>\r\n<pre><code class=\"lang-java\">public abstract class DrinksMachine {\r\n    public abstract Drink dispenseDrink();\r\n    public String displayMessage(){\r\n        return &quot;Thank for your custom.&quot;;\r\n    }\r\n}\r\n</code></pre>\r\n<p>DrinksMachine抽象类的CoffeeMachine实现</p>\r\n<pre><code class=\"lang-java\">public class CoffeeMachine extends DrinksMachine {\r\n    public Drink dispenseDrink() {\r\n        return new Coffee();\r\n    }\r\n}\r\n</code></pre>\r\n<p>DrinksMachine抽象类的SoftDrinksMachine实现</p>\r\n<pre><code class=\"lang-java\">public class SoftDrinksMachine extends DrinksMachine {\r\n    public Drink dispenseDrink() {\r\n        return new SoftDrink();\r\n    }\r\n}\r\n</code></pre>\r\n<p>Drink接口</p>\r\n<pre><code class=\"lang-java\">public interface Drink {}\r\n</code></pre>\r\n<p>Drink接口的SoftDrink实现</p>\r\n<pre><code class=\"lang-java\">public class SoftDrink implements Drink {\r\n    SoftDrink() {\r\n        System.out.println(&quot;Soft drink&quot;);\r\n    }\r\n}\r\n</code></pre>\r\n<p>Drink接口的Coffee实现</p>\r\n<pre><code class=\"lang-java\">public class Coffee implements Drink {\r\n    Coffee() {\r\n        System.out.println(&quot;Coffee&quot;);\r\n    }\r\n}\r\n</code></pre>\r\n<p>CoffeeType枚举<br>```java<br>public enum CoffeeType {EXPRESSO, LATTE}</p>\r\n<p>public Drink dispenseDrink(CoffeeType type) {<br>    Drink coffee = null;<br>    switch (type) {<br>        case EXPRESSO: coffee = new Expresso();<br>        case LATTE: coffee = new Latte();<br>    }<br>    return coffee;<br>}<br>```&lt;!--前面不能有空格--&gt;</p>','2017-05-06',0,24,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(470,'代理模式','代理模式(Proxy Pattern) GoF中给出的代理模式的定义为： 代理模式给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。 代理模式的英文叫做Proxy或Surrogate，它是一种对象结构型模式。 代理模式根据其目的和实现可分为很多种类，常用的代理模式包括如下几种： （1）远程代理（Remote Proxy）————为一个位于不同的地址空间的对象提供一个本地的代理对象','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h1 id=\"h1--proxy-pattern-\"><a name=\"代理模式(Proxy Pattern)\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代理模式(Proxy Pattern)</h1><p>GoF中给出的代理模式的定义为：<br>代理模式给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。<br>代理模式的英文叫做Proxy或Surrogate，它是一种对象结构型模式。<br>代理模式根据其目的和实现可分为很多种类，常用的代理模式包括如下几种：<br>（1）远程代理（Remote Proxy）————为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以是在同一台主机中，也可以是在另一台主机中，远程代理又称为大使（Ambassador）<br>（2）虚拟代理（Virtual Proxy）————如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。<br>（3）保护代理（Protect Proxy）————控制一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。<br>（4）缓冲代理（Cache Proxy）————为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。<br>（5）只能引用代理（Smart Reference Proxy）————当一个对象被引用时，提供一些额外的操作，例如将对象被调用的次数记录下来。<br><img src=\"http://ohlrxdl4p.bkt.clouddn.com/images/QQ截图20170507103646.jpg\" alt=\"\"></p>\n<p>代码实现：<br>1.抽象主题类——BuyTicket.java</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code class=\"lang-java\"><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">interface</span><span class=\"pln\"> </span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> showticket</span><span class=\"pun\">();</span></code></li><li class=\"L2\"><code class=\"lang-java\"><span class=\"pun\">}</span></code></li></ol></pre>\n<p>2.具体主题类——Train.java</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code class=\"lang-java\"><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Train</span><span class=\"pln\"> </span><span class=\"kwd\">implements</span><span class=\"pln\"> </span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"lit\">@Override</span></code></li><li class=\"L2\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> showticket</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L3\"><code class=\"lang-java\"><span class=\"pln\">        </span><span class=\"typ\">System</span><span class=\"pun\">.</span><span class=\"pln\">out</span><span class=\"pun\">.</span><span class=\"pln\">println</span><span class=\"pun\">(</span><span class=\"str\">\"one ticket\"</span><span class=\"pun\">);</span></code></li><li class=\"L4\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L5\"><code class=\"lang-java\"><span class=\"pun\">}</span></code></li></ol></pre>\n<p>3.代理角色类——TicketCenter.java</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code class=\"lang-java\"><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">TicketCenter</span><span class=\"pln\"> </span><span class=\"kwd\">implements</span><span class=\"pln\"> </span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> ticket</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code class=\"lang-java\"></code></li><li class=\"L3\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"typ\">TicketCenter</span><span class=\"pun\">(</span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> ticket</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code class=\"lang-java\"><span class=\"pln\">        </span><span class=\"kwd\">this</span><span class=\"pun\">.</span><span class=\"pln\">ticket </span><span class=\"pun\">=</span><span class=\"pln\"> ticket</span><span class=\"pun\">;</span></code></li><li class=\"L5\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code class=\"lang-java\"></code></li><li class=\"L7\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"lit\">@Override</span></code></li><li class=\"L8\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> showticket</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L9\"><code class=\"lang-java\"><span class=\"pln\">        ticket</span><span class=\"pun\">.</span><span class=\"pln\">showticket</span><span class=\"pun\">();</span></code></li><li class=\"L0\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code class=\"lang-java\"></code></li><li class=\"L2\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> buy</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L3\"><code class=\"lang-java\"><span class=\"pln\">        </span><span class=\"typ\">System</span><span class=\"pun\">.</span><span class=\"pln\">out</span><span class=\"pun\">.</span><span class=\"pln\">println</span><span class=\"pun\">(</span><span class=\"str\">\"by proxy\"</span><span class=\"pun\">);</span></code></li><li class=\"L4\"><code class=\"lang-java\"><span class=\"pln\">        showticket</span><span class=\"pun\">();</span></code></li><li class=\"L5\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code class=\"lang-java\"><span class=\"pun\">}</span></code></li></ol></pre>\n<p>4.客户端测试类</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code class=\"lang-java\"><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">ProxyPattern</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> main</span><span class=\"pun\">(</span><span class=\"typ\">String</span><span class=\"pln\"> args</span><span class=\"pun\">[])</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L2\"><code class=\"lang-java\"><span class=\"pln\">        </span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> x </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Train</span><span class=\"pun\">();</span></code></li><li class=\"L3\"><code class=\"lang-java\"><span class=\"pln\">        </span><span class=\"typ\">TicketCenter</span><span class=\"pln\"> y </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">TicketCenter</span><span class=\"pun\">(</span><span class=\"pln\">x</span><span class=\"pun\">);</span></code></li><li class=\"L4\"><code class=\"lang-java\"><span class=\"pln\">        y</span><span class=\"pun\">.</span><span class=\"pln\">buy</span><span class=\"pun\">();</span></code></li><li class=\"L5\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code class=\"lang-java\"><span class=\"pun\">}</span></code></li></ol></pre>\n<p>运行结果：</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code class=\"lang-html\"><span class=\"pln\">by proxy</span></code></li><li class=\"L1\"><code class=\"lang-html\"><span class=\"pln\">one ticket</span></code></li></ol></pre>\n</div>','2017-05-07',0,22,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(471,'2017-02-28学习笔记','','<p><img src=\"http://ohlrxdl4p.bkt.clouddn.com/images/826546_1482322555369_C5DABB18734059E89A45A0E9170722B0.png\" alt=\"\"></p>','2017-02-28',0,22,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(472,'2017-03-01学习笔记','知识点 1.java中只有值传递，没有引用传递http://guhanjie.iteye.com/blog/1683637 2.final关键字 final修饰变量，则等同于常量. final修饰方法中的参数，称为最终参数. final修饰类，则类不能被继承. final修饰方法，则方法不能被','<h1 id=\"h1-u77E5u8BC6u70B9\"><a name=\"知识点\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>知识点</h1><h4 id=\"h4-1-java-http-guhanjie-iteye-com-blog-1683637\"><a name=\"1.java中只有值传递，没有引用传递  http://guhanjie.iteye.com/blog/1683637\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.java中只有值传递，没有引用传递<a href=\"http://guhanjie.iteye.com/blog/1683637\">http://guhanjie.iteye.com/blog/1683637</a></h4><h4 id=\"h4-2-final-\"><a name=\"2.final关键字\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.final关键字</h4><ul>\r\n<li>final修饰变量，则等同于常量.</li><li>final修饰方法中的参数，称为最终参数.</li><li>final修饰类，则类不能被继承.</li><li>final修饰方法，则方法不能被重写.</li></ul>\r\n<h4 id=\"h4-3-integer-img-src-https-uploadfiles-nowcoder-com-images-20160717-6316247_1468761643205_9f7b85ab04292cf73778d98998a20ed1-alt-\"><a name=\"3.Integer<img src=\"https://uploadfiles.nowcoder.com/images/20160717/6316247_1468761643205_9F7B85AB04292CF73778D98998A20ED1\" alt=\"图片\">\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.Integer<img src=\"https://uploadfiles.nowcoder.com/images/20160717/6316247_1468761643205_9F7B85AB04292CF73778D98998A20ED1\" alt=\"图片\"></h4><h4 id=\"h4-4-java-\"><a name=\"4.java内存模型   点击原文\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.java内存模型 <a href=\"http://blog.csdn.net/ns_code/article/details/17565503\">点击原文</a></h4><p><img src=\"https://uploadfiles.nowcoder.com/images/20161223/415611_1482452184396_6FB53C51539B47559CF0D122A832CF63\" alt=\"\"></p>\r\n<h4 id=\"h4-5-java-reference\"><a name=\"5.java中是没有指针的，有reference\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.java中是没有指针的，有reference</h4><p>第一：指针变量是在栈内存中，它也是有值的，这个值存储的就是地址单元，这个地址就是来自于赋值操作。<br>第二：指针变量有类型，这个类型（如Person）的含义是指针指向的变量在栈内存（不是很确定）中的范围（大小），我理解为是占用的堆内存空间。<br>第三：声明一个对象时，是对“指针变量”的定义。<br>第四：用new关键字在堆内存创建了对象，在赋值时，是把这个对象的首地址传给了这个“指针变量”（即引用型变量）。</p>\r\n<h4 id=\"h4-6-string-\"><a name=\"6.String生成常量\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6.String生成常量</h4><pre><code class=\"lang-java\">String s1=&quot;abc&quot;+&quot;def&quot;;//生成的是一个常量，放在堆内存中\r\nString s2=new String（s1);//s2是一个变量\r\nif(s1.equals(s2))//比较的是字符串的内容\r\n    System.out.println(&quot;.equals succeeded&quot;);//输出\r\nif(s1==s2)//比较的是内存地址，但s1是常量，所以不相等\r\n    System.out.println(&quot;==succeeded&quot;);\r\n</code></pre>\r\n<h4 id=\"h4-7-jsp-\"><a name=\"7.jsp内置对象和属性\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>7.jsp内置对象和属性</h4><p>（１）request对象<br>客户端的请求信息被封装在request对象中，通过它才能了解到客户的需求，然后做出响应。它是HttpServletRequest类的实例。<br>（２）response对象<br>response对象包含了响应客户请求的有关信息，但在JSP中很少直接用到它。它是HttpServletResponse类的实例。<br>（３）session对象<br>session对象指的是客户端与服务器的一次会话，从客户连到服务器的一个WebApplication开始，直到客户端与服务器断开连接为止。它是HttpSession类的实例.<br>（４）out对象<br>out对象是JspWriter类的实例,是向客户端输出内容常用的对象<br>（５）page对象<br>page对象就是指向当前JSP页面本身，有点象类中的this指针，它是java.lang.Object类的实例<br>（６）application对象<br>application对象实现了用户间数据的共享，可存放全局变量。它开始于服务器的启动，直到服务器的关闭，在此期间，此对象将一直存在；这样在用户的前后连接或不同用户之间的连接中，可以对此对象的同一属性进行操作；在任何地方对此对象属性的操作，都将影响到其他用户对此的访问。服务器的启动和关闭决定了application对象的生命。它是ServletContext类的实例。<br>（７）exception对象<br>exception对象是一个例外对象，当一个页面在运行过程中发生了例外，就产生这个对象。如果一个JSP页面要应用此对象，就必须把isErrorPage设为true，否则无法编译。他实际上是java.lang.Throwable的对象<br>（８）pageContext对象<br>pageContext对象提供了对JSP页面内所有的对象及名字空间的访问，也就是说他可以访问到本页所在的SESSION，也可以取本页面所在的application的某一属性值，他相当于页面中所有功能的集大成者，它的本 类名也叫pageContext。<br>（９）config对象<br>config对象是在一个Servlet初始化时，JSP引擎向它传递信息用的，此信息包括Servlet初始化时所要用到的参数（通过属性名和属性值构成）以及服务器的有关信息（通过传递一个ServletContext对象）</p>','2017-03-01',0,21,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(473,'2017-03-02学习笔记','知识点 一、static public class Spike\r\n{\r\n    public static void main(String[] args)\r\n    {\r\n        Counter a = new Counter();\r\n        System.out.println(a.increment());\r\n        System.out.println(a.anot','<h1 id=\"h1-u77E5u8BC6u70B9\"><a name=\"知识点\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>知识点</h1><h4 id=\"h4--static\"><a name=\"一、static\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、static</h4><pre><code class=\"lang-java\">public class Spike\r\n{\r\n    public static void main(String[] args)\r\n    {\r\n        Counter a = new Counter();\r\n        System.out.println(a.increment());\r\n        System.out.println(a.anotherIncrement());\r\n        Counter b = new Counter();\r\n        System.out.println(b.increment());\r\n    }\r\n}\r\nclass Counter\r\n{\r\n    private static int count = 0;\r\n    public int increment()\r\n    {\r\n        return count++;\r\n    }\r\n    public int anotherIncrement()\r\n    {\r\n        return ++count;\r\n    }\r\n}\r\n</code></pre>\r\n<p>count是静态变量，为所有对象所共享，因此不管a.increment()还是b.increment()都会使count持续增加。<br>increment()方法返回当前count值，然后count增加1<br>antoherIncrement()方法让count增加1，然后返回count值<br>第一次a.increment()返回值为0，此时count值为1<br>第二次a.anotherIncrement()先让count+1再返回，返回值为2<br>第三次b.increment()先返回count当前值2，然后count+1</p>\r\n<h4 id=\"h4--aop-\"><a name=\"二、AOP面向切面\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、AOP面向切面</h4><p>AOP的概念是Aspected Oriented Programming 面向方面编程。<br>  好处：AOP将程序分解成各个方面或者说关注点。这使得可以模块化，相当横向上分切了。它可以解决OOP和过程化方法不能够很好解决的横切（crosscut）问题，如：事务、安全、日志等横切关注。<br>  实现AOP有几种方式:<br>  1.Spring 1.2版本中通过ProxyFactoryBean来实现aop,即通过动态代理来实现的,Aspect必须继承MethodBeforeAdvice,MethodAfterAdvice等<br>  2.Spring 2.0 AOP需要改的是FBI 这个类，而且它也不需要再实现某些接口<br>  3.三使用标注（<a href=\"https://github.com/AspectJ\" title=\"&#64;AspectJ\" class=\"at-link\">@AspectJ</a>）实现AOP<br>    AOP 和 OOP的区别：</p>\r\n<pre><code>```html\r\n 1. 面向方面编程 AOP 偏重业务处理过程的某个步骤或阶段，强调降低模块之间的耦合度，使代码拥有更好的移植性。  \r\n 2. 面向对象编程 (oop) 则是对业务分析中抽取的实体进行方法和属性的封装。\r\n ```\r\n</code></pre><p>也可以说 AOP 是面向业务中的动词领域， OOP 面向名词领域。<br>AOP 的一个很重要的特点是源代码无关性，也就是说如果我们的系统中引用了 AOP 组件，即使我们把该组件去掉，系统代码也应该能够编译通过。要实现这一点，可以使用动态 proxy 模式。</p>\r\n<h4 id=\"h4--jdbc-\"><a name=\"三、jdbc桥接模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、jdbc桥接模式</h4><p>桥接模式：<br>定义 ：将抽象部分与它的实现部分分离，使它们都可以独立地变化。<br>意图 ：将抽象与实现解耦。<br>桥接模式所涉及的角色</p>\r\n<ol>\r\n<li>Abstraction ：定义抽象接口，拥有一个Implementor类型的对象引用</li><li>RefinedAbstraction ：扩展Abstraction中的接口定义</li><li>Implementor ：是具体实现的接口，Implementor和RefinedAbstraction接口并不一定完全一致，实际上这两个接口可以完全不一样Implementor提供具体操作方法，而Abstraction提供更高层次的调用</li><li>ConcreteImplementor ：实现Implementor接口，给出具体实现<br>Jdk中的桥接模式：JDBC<br>JDBC连接 数据库 的时候，在各个数据库之间进行切换，基本不需要动太多的代码，甚至丝毫不动，原因就是JDBC提供了统一接口，每个数据库提供各自的实现，用一个叫做数据库驱动的程序来桥接就行了<h4 id=\"h4--\"><a name=\"四、抽象类\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>四、抽象类</h4>抽象类和普通类有三点区别：<br>1）抽象方法必须为public和protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public。<br>2）抽象类不能用来创建对象，但是它可以有构造方法，用来帮助子类实例化。<br>3）如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为abstract类。<h4 id=\"h4--\"><a name=\"五、接口\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>五、接口</h4>接口的主要特点<br>1）接口中的成员变量默认都是public、static、final类型的，必须被显示初始化。<br>2）接口中的方法默认都是public、abstract类型的。<br>3）接口中只能包含public、static、final类型的成员变量和public、abstract类型的成员方法。<br>4）接口没有构造方法，不能被实例化。<br>5）一个接口不能实现另一个接口，但它可以继承多个其他接口。<br>6）接口必须通过类来实现它的抽象方法。<br>7）与子类继承抽象父类相似，当类实现了某个接口时，它必须实现接口中所有的抽象方法，否则这个类必须被定义为抽象类。<br>8）一个类只能继承一个直接的父类，但能实现多个接口。<h4 id=\"h4--\"><a name=\"六、抽象类和接口的区别\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>六、抽象类和接口的区别</h4>1）抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract方法；<br>2）抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；<br>3）接口中不能含有静态代码块以及静态方法，而抽象类尅有静态代码块和静态方法；<br>4）一个类只能继承一个抽象类，而一个类却可以实现多个接口。<br>5）抽象类中的方法子类必须全部实现，不然子类也是抽象类，而接口中的抽象方法子类必须全部实现，是可选择实现的。<br>6）抽象类是一种模板设计模式，而接口时一种行为规范。</li></ol>','2017-03-02',0,22,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(474,'2017-03-03学习笔记','一、String StringBuffer.toString()源码： @Override\r\npublic synchronized String toString() {\r\n    if (toStringCache == null) {\r\n        toStringCache = Arrays.copyOfRange(value, 0, count);\r\n    }\r\n    retur','<h4 id=\"h4--string\"><a name=\"一、String\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、String</h4><p>StringBuffer.toString()源码：</p>\r\n<pre><code class=\"lang-java\">@Override\r\npublic synchronized String toString() {\r\n    if (toStringCache == null) {\r\n        toStringCache = Arrays.copyOfRange(value, 0, count);\r\n    }\r\n    return new String(toStringCache, true);\r\n}\r\n</code></pre>\r\n<p>Arrays.copyOfRange用的是System.arraycopy</p>\r\n<pre><code class=\"lang-java\">public static char[] copyOfRange(char[] original, int from, int to) {\r\n        int newLength = to - from;\r\n        if (newLength &lt; 0)\r\n            throw new IllegalArgumentException(from + &quot; &gt; &quot; + to);\r\n        char[] copy = new char[newLength];\r\n        System.arraycopy(original, from, copy, 0,\r\n                         Math.min(original.length - from, newLength));\r\n        return copy;\r\n    }\r\n</code></pre>\r\n<p>1.String是值传入，不是引用传入。<br>2.String对String  类型进行改变的时候其实都等同于生成了一个新的  String  对象，然后将指针指向新的  String  对象，而不是StringBuffer；StringBuffer每次结果都会对  StringBuffer  对象本身进行操作，而不是生成新的对象，再改变对象引用。<br>3.效率比较String&lt;StringBuffer&lt;StringBuilder，但是在 String S1 = “This is only a” + “ simple” + “ test”时，String效率最高。</p>\r\n<h4 id=\"h4--jvm-\"><a name=\"二、jvm知识图谱\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、jvm知识图谱</h4><p><a href=\"https://zhuanlan.zhihu.com/p/25511795\">引用自知乎</a><br><img src=\"https://pic2.zhimg.com/v2-701563ac1fe745fc8e1234c96e82ac99_r.jpg\" alt=\"\"></p>\r\n<h4 id=\"h4--treemap-linkhashmap\"><a name=\"三、Treemap、LinkHashMap\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、Treemap、LinkHashMap</h4><p>1.TreeMap取出来的是排序后的键值对。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。<br>2.LinkedHashMap 是HashMap的一个子类，如果需要输出的顺序和输入的相同,那么用LinkedHashMap可以实现,它还可以按读取顺序来排列。</p>\r\n<h4 id=\"h4--sql-\"><a name=\"四、sql模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>四、sql模式</h4><p>MySQL数据库中，变量分为 系统变量（以”@@”开头）和用户自定义变量。系统变量分为全局系统变量(global)和会话系统变量(session)。<br>@<a href=\"https://github.com/global\" title=\"&#64;global\" class=\"at-link\">@global</a>     仅用于访问全局系统变量的值；<br>@<a href=\"https://github.com/session\" title=\"&#64;session\" class=\"at-link\">@session</a>  仅用于访问会话系统变量的值；<br>@@              先访问会话系统变量的值，若不存在则去访问全局系统变量的值；<br>sql_mode 为系统变量，既是全局系统变量，又是会话系统变量。</p>\r\n<h4 id=\"h4--\"><a name=\"五、代码的执行顺序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>五、代码的执行顺序</h4><p>父类Ｂ静态代码块-&gt;子类Ａ静态代码块-&gt;父类Ｂ非静态代码块-&gt;父类Ｂ构造函数-&gt;子类Ａ非静态代码块-&gt;子类Ａ构造函数<br><img src=\"http://ohlrxdl4p.bkt.clouddn.com/images/QQ截图20170303165728.jpg\" alt=\"\"></p>','2017-03-03',0,25,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(475,'ifhifhajfe','hello','<h1 id=\"h1-hello\"><a name=\"hello\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>hello</h1>','2017-03-05',0,23,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(476,'2017-03-05学习笔记','java的堆，栈，静态代码区（常量区） 详解','<p><a href=\"http://blog.csdn.net/u012031380/article/details/54981472\"> java的堆，栈，静态代码区（常量区） 详解</a></p>','2017-03-05',0,22,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(477,'java归并排序','package datastruct;\r\n\r\n/**\r\n * Created by Zephery on 2017/3/3.\r\n */\r\npublic class Solution {\r\n    public static void printArray(int[] arr, int i, int j) {\r\n        System.out.print(\"[\");\r\n        for','<pre><code class=\"lang-java\">package datastruct;\r\n\r\n/**\r\n * Created by Zephery on 2017/3/3.\r\n */\r\npublic class Solution {\r\n    public static void printArray(int[] arr, int i, int j) {\r\n        System.out.print(&quot;[&quot;);\r\n        for (int k = i; k &lt; j; k++) {\r\n            System.out.print(arr[k] + &quot;,&quot;);\r\n        }\r\n        System.out.print(arr[j] + &quot;]&quot;);\r\n    }\r\n\r\n    private static void mergesort(int[] arr, int i, int j) {\r\n        int mid = 0;\r\n        if (i &lt; j) {\r\n            mid = (i + j) / 2;\r\n            mergesort(arr, i, mid);\r\n            mergesort(arr, mid + 1, j);\r\n            merge(arr, i, mid, j);\r\n        }\r\n    }\r\n\r\n    private static void merge(int[] arr, int i, int mid, int j) {\r\n        System.out.print(&quot;Left:&quot;);\r\n        printArray(arr, i, mid);\r\n        System.out.println(&quot;Right:&quot;);\r\n        printArray(arr, mid + 1, j);\r\n        System.out.println();\r\n        int temp[] = new int[arr.length];\r\n        int l = i;\r\n        int r = j;\r\n        int m = mid + 1;\r\n        int k = l;\r\n        while (l &lt;= mid &amp;&amp; m &lt;= r) {\r\n            if (arr[l] &lt;= arr[m]) {\r\n                temp[k++] = arr[l++];\r\n            } else {\r\n                temp[k++] = arr[m++];\r\n            }\r\n        }\r\n        while (l &lt;= mid) {\r\n            temp[k++] = arr[l++];\r\n        }\r\n        while (m &lt;= r) {\r\n            temp[k++] = arr[m++];\r\n        }\r\n        for (int i1 = i; i1 &lt;= j; i1++) {\r\n            arr[i1] = temp[i1];\r\n        }\r\n        System.out.print(&quot;After Merge:&quot;);\r\n        printArray(arr, i, j);\r\n        System.out.println();\r\n    }\r\n\r\n    public static void main(String args[]) {\r\n        int[] arr = {9, 4, 8, 3, 1, 2, 5};\r\n        System.out.print(&quot;Initial Array:&quot;);\r\n        printArray(arr, 0, arr.length - 1);\r\n        System.out.println();\r\n        mergesort(arr, 0, arr.length - 1);\r\n    }\r\n}\r\n</code></pre>\r\n<pre><code class=\"lang-js\">Initial Array:[9,4,8,3,1,2,5]\r\nLeft:[9]Right:\r\n[4]\r\nAfter Merge:[4,9]\r\nLeft:[8]Right:\r\n[3]\r\nAfter Merge:[3,8]\r\nLeft:[4,9]Right:\r\n[3,8]\r\nAfter Merge:[3,4,8,9]\r\nLeft:[1]Right:\r\n[2]\r\nAfter Merge:[1,2]\r\nLeft:[1,2]Right:\r\n[5]\r\nAfter Merge:[1,2,5]\r\nLeft:[3,4,8,9]Right:\r\n[1,2,5]\r\nAfter Merge:[1,2,3,4,5,8,9]\r\n</code></pre>','2017-03-06',0,24,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(478,'2017-03-10学习笔记','1.Integer和int，装箱拆箱 1、基本型和基本型封装型进行“==”运算符的比较，基本型封装型将会自动拆箱变为基本型后再进行比较，因此Integer(0)会自动拆箱为int类型再进行比较，显然返回true； 2、两个Integer类型进行“==”比较，如果其值在-128至127，那么返回true，否则返回false, 这跟Integer.valueOf()的缓冲对象有关，这里不进行赘述。 3','<h1 id=\"h1-1-integer-int-\"><a name=\"1.Integer和int，装箱拆箱\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.Integer和int，装箱拆箱</h1><p>1、基本型和基本型封装型进行“==”运算符的比较，基本型封装型将会自动拆箱变为基本型后再进行比较，因此Integer(0)会自动拆箱为int类型再进行比较，显然返回true；<br>2、两个Integer类型进行“==”比较，如果其值在-128至127，那么返回true，否则返回false, 这跟Integer.valueOf()的缓冲对象有关，这里不进行赘述。<br>3、两个基本型的封装型进行equals()比较，首先equals()会比较类型，如果类型相同，则继续比较值，如果值也相同，返回true<br>4、基本型封装类型调用equals(),但是参数是基本类型，这时候，先会进行自动装箱，基本型转换为其封装类型，再进行3中的比较。</p>\r\n<pre><code class=\"lang-java\">int a=257;\r\nInteger b=257;\r\nInteger c=257;\r\nInteger b2=57;\r\nInteger c2=57;\r\nSystem.out.println(a==b);\r\n//System.out.println(a.equals(b));  编译出错，基本型不能调用equals()\r\nSystem.out.println(b.equals(257.0));\r\nSystem.out.println(b==c);\r\nSystem.out.println(b2==c2);\r\n</code></pre>\r\n<p>因此上面的代码的结果因此为 true, false, false, true</p>\r\n<h1 id=\"h1-2-\"><a name=\"2.线程调度\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.线程调度</h1><p>分为协同式调度和抢占式调度，Java使用的是抢占式调度，也就是每个线程将由操作系统来分配执行时间，线程的切换不由线程本身来决定（协同式调度）。这就是平台独立的原因。</p>\r\n<h1 id=\"h1-3-\"><a name=\"3.重载，重写\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.重载，重写</h1><p>重写：<br>两同，两小，一大<br>两同：方法名，方法参数列表相同。<br>两小：抛出的异常类型要小于等于父类，返回值类型要小于等于父类<br>一大：访问权限大于等于父类。<br>重载：<br>在同一个类中，方法名和方法参数列表不同，其他的（访问权限、返回值）随意。</p>\r\n<h1 id=\"h1-4-jvm-\"><a name=\"4.  JVM面试题\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.<a href=\"http://blog.csdn.net/hsk256/article/details/49104955\">JVM面试题</a></h1>','2017-03-10',0,25,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(479,'2017-03-12学习笔记','1.继承的加载顺序 执行顺序大体上可以说是先父类后子类，父类static域 ==》子类static域 ==》父类数据成员域 ==》父类构造器 ==》子类数据成员域 ==》子类构造器 2.优化Hibernate所鼓励的7大措施： 1.尽量使用many-to-one，避免使用单项one-to-many 2.灵活使用单向one-to-many 3.不用一对一，使用多对一代替一对一 4.配置对象缓存，不使','<h4 id=\"h4-1-\"><a name=\"1.  继承的加载顺序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.<a href=\"http://www.cnblogs.com/SirSmith/p/5536288.html\">继承的加载顺序</a></h4><p><img src=\"http://images2015.cnblogs.com/blog/452847/201605/452847-20160527221410288-2119099273.png\" alt=\"\"></p>\r\n<p>执行顺序大体上可以说是先父类后子类，父类static域 ==》子类static域 ==》父类数据成员域 ==》父类构造器 ==》子类数据成员域 ==》子类构造器</p>\r\n<h4 id=\"h4-2-hibernate-7-\"><a name=\"2.优化Hibernate所鼓励的7大措施：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.优化Hibernate所鼓励的7大措施：</h4><p>1.尽量使用many-to-one，避免使用单项one-to-many<br>2.灵活使用单向one-to-many<br>3.不用一对一，使用多对一代替一对一<br>4.配置对象缓存，不使用集合缓存<br>5.一对多使用Bag 多对一使用Set<br>6.继承使用显示多态 HQL:from object polymorphism=”exlicit” 避免查处所有对象<br>7.消除大表，使用二级缓存</p>\r\n<h4 id=\"h4-3-java-\"><a name=\"3.java中的数据类型分类：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.java中的数据类型分类：</h4><p>基本数据类型（或叫做原生类、内置类型）8种：<br>    整数：byte，short，int，long（默认是int类型）<br>    浮点类型： float，double（默认是double类型）<br>    字符类型：char<br>    布尔类型：boolean<br>引用数据类型3种：数组，类，接口</p>\r\n<h4 id=\"h4-4-\"><a name=\"4.触发器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.触发器</h4><p>drop trigger 删除触发器<br>Drop用于删除数据表或数据库，或删除数据表字段。<br>remove：删除数据库文件<br>Truncate：删除数据表中的数据（仅数据表中的数据，不删除表）。</p>','2017-03-12',0,27,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(480,'2017-03-14学习笔记','1.Servlet的生命周期分为5个阶段：加载、创建、初始化、处理客户请求、卸载。 (1)加载：容器通过类加载器使用servlet类对应的文件加载servlet (2)创建：通过调用servlet构造函数创建一个servlet对象 (3)初始化：调用init方法初始化 (4)处理客户请求：每当有一个客户请求，容器会创建一个线程来处理客户请求 (5)卸载：调用destroy方法让servlet自己释','<h4 id=\"h4-1-servlet-5-\"><a name=\"1.Servlet的生命周期分为5个阶段：加载、创建、初始化、处理客户请求、卸载。\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.Servlet的生命周期分为5个阶段：加载、创建、初始化、处理客户请求、卸载。</h4><p>(1)加载：容器通过类加载器使用servlet类对应的文件加载servlet<br>(2)创建：通过调用servlet构造函数创建一个servlet对象<br>(3)初始化：调用init方法初始化<br>(4)处理客户请求：每当有一个客户请求，容器会创建一个线程来处理客户请求<br>(5)卸载：调用destroy方法让servlet自己释放其占用的资源</p>\r\n<h4 id=\"h4-2-jsp\"><a name=\"2.JSP\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.JSP</h4><p><img src=\"http://uploadfiles.nowcoder.com/images/20160308/595432_1457414324036_C3D4EB7F2D61708D0C0BE2921A45B74D\" alt=\"\"></p>','2017-03-14',0,25,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(481,'2017-03-17学习笔记','1.GC线程是否和守护线程 2.java堆排序','<h4 id=\"h4-1-gc-\"><a name=\"1.GC线程是否和守护线程\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.GC线程是否和守护线程</h4><h4 id=\"h4-2-java-\"><a name=\"2.java堆排序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.java堆排序</h4>','2017-03-17',0,24,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(482,'重载与重写','目前的问题：父类的功能无法满足子类的需求。 方法重写的前提： 必须要存在继承的关系。 方法的重写: 子父类出了同名的函数，这个我们就称作为方法的重写。 什么是时候要使用方法的重写：父类的功能无法满足子类的需求时。 方法重写要注意的事项： 1.方法重写时， 方法名与形参列表必须一致。 2.方法重写时，子类的权限修饰符必须要大于或者等于父类的权限修饰符。 3.方法重写时，子类的返回值类型必须要小于或者','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><p>目前的问题：父类的功能无法满足子类的需求。</p>\n<p>方法重写的前提： 必须要存在继承的关系。</p>\n<p>方法的重写: 子父类出了同名的函数，这个我们就称作为方法的重写。</p>\n<p>什么是时候要使用方法的重写：父类的功能无法满足子类的需求时。</p>\n<p>方法重写要注意的事项：<br>    1.方法重写时， 方法名与形参列表必须一致。<br>    2.方法重写时，子类的权限修饰符必须要大于或者等于父类的权限修饰符。<br>    3.方法重写时，子类的返回值类型必须要小于或者 等于父类的返回值类型。<br>    4.方法重写时， 子类抛出的异常类型要小于或者等于父类抛出的异常类型。<br>            Exception(最坏)<br>            RuntimeException(小坏)</p>\n<p>方法的重载：在一个类中 存在两个或者两个 以上的同名函数,称作为方法重载。</p>\n<p>方法重载的要求</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"lit\">1.</span><span class=\"pln\"> </span><span class=\"pun\">函数名要一致。</span></code></li><li class=\"L1\"><code><span class=\"lit\">2.</span><span class=\"pln\"> </span><span class=\"pun\">形参列表不一致（形参的个数或形参</span><span class=\"pln\"> </span><span class=\"pun\">的类型不一致）</span></code></li><li class=\"L2\"><code><span class=\"lit\">3.</span><span class=\"pln\"> </span><span class=\"pun\">与返回值类型无关。</span></code></li></ol></pre></div>','2017-03-21',0,24,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(483,'垃圾回收算法','垃圾回收算法 1、标记-清除算法 2、复制算法 3、标记-整理算法 一、标记-清除算法 标记-清除算法采用从根集合进行扫描，对存活的对象对象标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收，如上图所示。 标记-清除算法不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效，但由于标记-清除算法直接回收不存活的对象，因此会造成内存碎片！ 二、复制算法 复制算法','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h2 id=\"h2-u5783u573Eu56DEu6536u7B97u6CD5\"><a name=\"垃圾回收算法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>垃圾回收算法</h2><p>1、标记-清除算法<br>2、复制算法<br>3、标记-整理算法</p>\n<h4 id=\"h4--\"><a name=\"一、标记-清除算法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、标记-清除算法</h4><p><img src=\"http://dl2.iteye.com/upload/attachment/0075/0386/29ae17ad-f8af-38b4-9e25-28ef3550858f.jpg\" alt=\"\">标记-清除算法采用从根集合进行扫描，对存活的对象对象标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收，如上图所示。<br>标记-清除算法不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效，但由于标记-清除算法直接回收不存活的对象，因此会造成内存碎片！</p>\n<h4 id=\"h4--\"><a name=\"二、复制算法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、复制算法</h4><p><img src=\"http://dl2.iteye.com/upload/attachment/0075/0388/91a656d4-f08a-377b-8eea-5785c2932533.jpg\" alt=\"\"><br>复制算法采用从根集合扫描，并将存活对象复制到一块新的，没有使用过的空间中，这种算法当控件存活的对象比较少时，极为高效，但是带来的成本是需要一块内存交换空间用于进行对象的移动。也就是我们前面提到的s0 s1等空间。</p>\n<h4 id=\"h4--\"><a name=\"三、标记-整理算法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、标记-整理算法</h4><p><img src=\"http://dl2.iteye.com/upload/attachment/0075/0390/6ba95f80-c7bc-3d09-b927-ac09297e9920.jpg\" alt=\"\"><br> 标记-整理算法采用标记-清除算法一样的方式进行对象的标记，但在清除时不同，在回收不存活的对象占用的空间后，会将所有的存活对象往左端空闲空间移动，并更新对应的指针。标记-整理算法是在标记-清除算法的基础上，又进行了对象的移动，因此成本更高，但是却解决了内存碎片的问题。</p>\n</div>','2017-04-09',0,28,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(484,'java分代回收','一、新生代内存的回收（minor GC）主要采用复制算法，下图展示了minor GC的执行过程。 二、对于新生代和旧生代，JVM可使用很多种垃圾回收器进行垃圾回收，下图展示了不同生代不通垃圾回收器，其中两个回收器之间有连线表示这两个回收器可以同时使用。 而这些垃圾回收器又分为串行回收方式、并行回收方式合并发回收方式执行，分别运用于不同的场景。如下图所示 三、收集器 1.Serial收集器 看名字我','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h2 id=\"h2--minor-gc-minor-gc-\"><a name=\"一、新生代内存的回收（minor GC）主要采用复制算法，下图展示了minor GC的执行过程。\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、新生代内存的回收（minor GC）主要采用复制算法，下图展示了minor GC的执行过程。</h2><p><img src=\"http://dl2.iteye.com/upload/attachment/0075/0392/732c7557-aa9a-3551-b14d-f543c5b0c94b.jpg\" alt=\"\"></p>\n<h2 id=\"h2--jvm-\"><a name=\"二、对于新生代和旧生代，JVM可使用很多种垃圾回收器进行垃圾回收，下图展示了不同生代不通垃圾回收器，其中两个回收器之间有连线表示这两个回收器可以同时使用。\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、对于新生代和旧生代，JVM可使用很多种垃圾回收器进行垃圾回收，下图展示了不同生代不通垃圾回收器，其中两个回收器之间有连线表示这两个回收器可以同时使用。</h2><p><img src=\"http://dl2.iteye.com/upload/attachment/0075/0394/0172f624-9018-3642-bf26-05a2c3071639.jpg\" alt=\"\"><br>而这些垃圾回收器又分为串行回收方式、并行回收方式合并发回收方式执行，分别运用于不同的场景。如下图所示<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0396/c962c2ad-273f-3de4-b2e3-a4dd8b946215.jpg\" alt=\"\"></p>\n<h2 id=\"h2--\"><a name=\"三、收集器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、收集器</h2><h4 id=\"h4-1-serial-\"><a name=\"1.Serial收集器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.Serial收集器</h4><p>看名字我们都可以看的出来，这个属于串行收集器。其运行示意图如下<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0398/681da5ca-5eff-3984-bece-3d80dfe905be.jpg\" alt=\"\"><br>    收集器是历史最悠久的一个回收器，JDK1.3之前广泛使用这个收集器，目前也是ClientVM下 ServerVM 4核4GB以下机器的默认垃圾回收器。串行收集器并不是只能使用一个CPU进行收集，而是当JVM需要进行垃圾回收的时候，需要中断所有的用户线程，知道它回收结束为止，因此又号称“Stop The World” 的垃圾回收器。注意，JVM中文名称为java虚拟机，因此它就像一台虚拟的电脑一样在工作，而其中的每一个线程就被认为是JVM的一个处理器，因此大家看到图中的CPU0、CPU1实际为用户的线程，而不是真正机器的CPU，大家不要误解哦。<br>    串行回收方式适合低端机器，是Client模式下的默认收集器，对CPU和内存的消耗不高，适合用户交互比较少，后台任务较多的系统。<br>    Serial收集器默认新旧生代的回收器搭配为Serial+ SerialOld</p>\n<h4 id=\"h4-2-parnew-\"><a name=\"2.ParNew收集器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.ParNew收集器</h4><p>ParNew收集器其实就是多线程版本的Serial收集器，其运行示意图如下<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0400/6443b39c-ed33-3d93-a690-87e646439561.jpg\" alt=\"\"><br>同样有Stop The World的问题，他是多CPU模式下的首选回收器（该回收器在单CPU的环境下回收效率远远低于Serial收集器，所以一定要注意场景哦），也是Server模式下的默认收集器。</p>\n<h4 id=\"h4-3-parallelscavenge\"><a name=\"3.ParallelScavenge\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.ParallelScavenge</h4><p>ParallelScavenge又被称为是吞吐量优先的收集器，器运行示意图如下<br><img src=\"http://dl.iteye.com/upload/attachment/0075/0402/5007beba-0b0e-3cf4-b146-c28b6c0dd696.jpg\" alt=\"\"><br> ParallelScavenge<br>所提到的吞吐量=程序运行时间/(JVM执行回收的时间+程序运行时间),假设程序运行了100分钟，JVM的垃圾回收占用1分钟，那么吞吐量就是99%。在当今网络告诉发达的今天，良好的响应速度是提升用户体验的一个重要指标，多核并行云计算的发展要求程序尽可能的使用CPU和内存资源，尽快的计算出最终结果，因此在交互不多的云端，比较适合使用该回收器。</p>\n<h4 id=\"h4-4-parallelold\"><a name=\"4.ParallelOld\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.ParallelOld</h4><p>ParallelOld是老生代并行收集器的一种，使用标记整理算法、是老生代吞吐量优先的一个收集器。这个收集器是JDK1.6之后刚引入的一款收集器，我们看之前那个图之间的关联关系可以看到，早期没有ParallelOld之前，吞吐量优先的收集器老生代只能使用串行回收收集器，大大的拖累了吞吐量优先的性能，自从JDK1.6之后，才能真正做到较高效率的吞吐量优先。其运行示意图如下<br><img src=\"http://dl.iteye.com/upload/attachment/0075/0406/9a14da85-f943-3408-ba88-c6bb3842a792.jpg\" alt=\"\"></p>\n<h4 id=\"h4-5-serialold\"><a name=\"5.SerialOld\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.SerialOld</h4><p>SerialOld是旧生代Client模式下的默认收集器，单线程执行；在JDK1.6之前也是ParallelScvenge回收新生代模式下旧生代的默认收集器，同时也是并发收集器CMS回收失败后的备用收集器。其运行示意图如下<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0404/ce7aabd5-b0e0-3cda-9b6c-607cf6ebf689.jpg\" alt=\"\"></p>\n<h4 id=\"h4-5-cms\"><a name=\"5.CMS\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.CMS</h4><p>CMS又称响应时间优先(最短回收停顿)的回收器，使用并发模式回收垃圾，使用标记-清除算法，CMS对CPU是非常敏感的，它的回收线程数=（CPU+3）/4，因此当CPU是2核的实惠，回收线程将占用的CPU资源的50%，而当CPU核心数为4时仅占用25%。他的运行示意图如下<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0408/4239228b-879f-382f-81c6-5c32799886d6.jpg\" alt=\"\"><br>模式主要分为四个过程：<br>1.初始标记<br>2.并发标记<br>3.重新标记<br>4.并发清除<br>在初始标记的时候，需要中断所有用户线程，在并发标记阶段，用户线程和标记线程<br>并发执行，而在这个过程中，随着内存引用关系的变化，可能会发生原来标记的对象被释放，进而引发新的垃圾，因此可能会产生一系列的浮动垃圾，不能被回收。</p>\n<p>CMS 为了确保能够扫描到所有的对象，避免在Initial Marking 中还有未标识到的对象，采用的方法为找到标记了的对象，并将这些对象放入Stack 中，扫描时寻找此对象依赖的对象，如果依赖的对象的地址在其之前，则将此对象进行标记，并同时放入Stack 中，如依赖的对象地址在其之后，则仅标记该对象。<br>在进行Concurrent Marking 时minor GC 也可能会同时进行，这个时候很容易造成旧生代对象引用关系改变，CMS 为了应对这样的并发现象，提供了一个Mod Union Table 来进行记录，在这个Mod Union Table中记录每次minor GC 后修改了的Card 的信息。这也是ParallelScavenge不能和CMS一起使用的原因。<br>CMS产生浮动垃圾的情况请见如下示意图<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0410/60e7c659-790a-3405-af70-9ca4cfd9258d.jpg\" alt=\"\"><br>在运行回收过后，c就变成了浮动垃圾。<br>由于CMS会产生浮动垃圾，当回收过后，浮动垃圾如果产生过多，同时因为使用标记-清除算法会产生碎片，可能会导致回收过后的连续空间仍然不能容纳新生代移动过来或者新创建的大资源，因此会导致CMS回收失败，进而触发另外一次FULL GC，而这时候则采用SerialOld进行二次回收。<br>同时CMS因为可能产生浮动垃圾，而CMS在执行回收的同时新生代也有可能在进行回收操作，为了保证旧生代能够存放新生代转移过来的数据，CMS在旧生代内存到达全部容量的68%就触发了CMS的回收！</p>\n<h4 id=\"h4-7-garbagefirst-g1-\"><a name=\"7.GarbageFirst(G1)\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>7.GarbageFirst(G1)</h4><p>我们再来看垃圾回收器的总图，刚才我们可以看到，我在图上标记了一个？，其实这是一个新的垃圾回收器，既可以回收新生代也可以回收旧生代，SunHotSpot 1.6u14以上EarlyAccess版本加入了这个回收器，sun公司预期SunHotSpot1.7发布正式版，他是商用高性能垃圾回收器，通过重新划分内存区域，整合优化CMS，同时注重吞吐量和响应时间，但是杯具的是被Oracle收购之后这个收集器属于商用收费收集器，因此目前基本上没有人使用，我们在这里也就不多介绍，更多信息可以参考oracle新版本JDK说明。</p>\n</div>','2017-04-09',0,29,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(485,'java汇编','java 汇编 http://download.csdn.net/download/jiangfuqiang/8403497','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><p>java 汇编<br><a href=\"http://download.csdn.net/download/jiangfuqiang/8403497\">http://download.csdn.net/download/jiangfuqiang/8403497</a></p>\n</div>','2017-04-10',0,28,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(486,'jvm','-XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><p>-XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly</p>\n</div>','2017-04-10',0,34,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(487,'Java堆.栈和常量池 笔记','Java堆.栈和常量池 笔记','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><p><a href=\"http://www.iteye.com/topic/634530\">Java堆.栈和常量池 笔记</a></p>\n</div>','2017-04-23',0,38,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(488,'工厂模式','工厂模式 目录 何为工厂模式 工厂方法与抽象工厂 如何在Java EE中通过@Producers与@Inject注解实现工厂模式 如何创建自定义注解以及通过@Qualifier消除具体实现之间的歧义 工厂模式有两种模式：工厂方法和抽象方法。它们的意图是一样的：提供一个接口，在不指定具体类的情况下创建相关或依赖的一系列对象。 一.何为工厂模式 工厂的目的在于创建对象。创建的逻辑被封装在工厂中，要么提','<h1 id=\"h1-u5DE5u5382u6A21u5F0F\"><a name=\"工厂模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>工厂模式</h1><p>目录</p>\r\n<ul>\r\n<li>何为工厂模式</li><li>工厂方法与抽象工厂</li><li>如何在Java EE中通过<a href=\"https://github.com/Producers\" title=\"&#64;Producers\" class=\"at-link\">@Producers</a>与<a href=\"https://github.com/Inject\" title=\"&#64;Inject\" class=\"at-link\">@Inject</a>注解实现工厂模式</li><li>如何创建自定义注解以及通过<a href=\"https://github.com/Qualifier\" title=\"&#64;Qualifier\" class=\"at-link\">@Qualifier</a>消除具体实现之间的歧义<br>工厂模式有两种模式：工厂方法和抽象方法。它们的意图是一样的：提供一个接口，在不指定具体类的情况下创建相关或依赖的一系列对象。</li></ul>\r\n<h3 id=\"h3--\"><a name=\"一.何为工厂模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一.何为工厂模式</h3><p>工厂的目的在于创建对象。创建的逻辑被封装在工厂中，要么提供一个方法来返回新创建的对象（工厂方法模式），要么将对象的创建委托给子类（抽象工厂模式）。<br>客户端不必考虑接口或类的不同实现，它只需通过工厂（工厂）获取接口实现的一个实例的即可，这样客户端与对象的创建就实现了解耦<br>解耦是应用依赖反转原则的结果，这带来了很多好处，其中最重要的好处就是实现了高层类与底层类之间的解耦。通过解耦，具体类实现的变化不会影响到客户端，这降低了类与类之间的耦合，并提升了灵活性。</p>\r\n<h3 id=\"h3--\"><a name=\"二.工厂方法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二.工厂方法</h3><p>GoF一书是这样描述工程方法模式的：“定义一个用于创建对象的接口，不过让子类决定实例化那个类”<br>工厂极大降低了new关键字的使用次数，并且将初始化过程与不同的具体实现封装起来。将这些需求中心化可以极大减少向系统中添加或删除具体类的影响以及具体的类依赖的影响。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src=\"http://ohlrxdl4p.bkt.clouddn.com/images/QQ截图20170506134421.jpg\" alt=\"\"><br><strong>1.使用普通代码实现工厂方法</strong><br>被具体实现继承的DrinksMachine抽象类</p>\r\n<pre><code class=\"lang-java\">public abstract class DrinksMachine {\r\n    public abstract Drink dispenseDrink();\r\n    public String displayMessage(){\r\n        return &quot;Thank for your custom.&quot;;\r\n    }\r\n}\r\n</code></pre>\r\n<p>DrinksMachine抽象类的CoffeeMachine实现</p>\r\n<pre><code class=\"lang-java\">public class CoffeeMachine extends DrinksMachine {\r\n    public Drink dispenseDrink() {\r\n        return new Coffee();\r\n    }\r\n}\r\n</code></pre>\r\n<p>DrinksMachine抽象类的SoftDrinksMachine实现</p>\r\n<pre><code class=\"lang-java\">public class SoftDrinksMachine extends DrinksMachine {\r\n    public Drink dispenseDrink() {\r\n        return new SoftDrink();\r\n    }\r\n}\r\n</code></pre>\r\n<p>Drink接口</p>\r\n<pre><code class=\"lang-java\">public interface Drink {}\r\n</code></pre>\r\n<p>Drink接口的SoftDrink实现</p>\r\n<pre><code class=\"lang-java\">public class SoftDrink implements Drink {\r\n    SoftDrink() {\r\n        System.out.println(&quot;Soft drink&quot;);\r\n    }\r\n}\r\n</code></pre>\r\n<p>Drink接口的Coffee实现</p>\r\n<pre><code class=\"lang-java\">public class Coffee implements Drink {\r\n    Coffee() {\r\n        System.out.println(&quot;Coffee&quot;);\r\n    }\r\n}\r\n</code></pre>\r\n<p>CoffeeType枚举<br>```java<br>public enum CoffeeType {EXPRESSO, LATTE}</p>\r\n<p>public Drink dispenseDrink(CoffeeType type) {<br>    Drink coffee = null;<br>    switch (type) {<br>        case EXPRESSO: coffee = new Expresso();<br>        case LATTE: coffee = new Latte();<br>    }<br>    return coffee;<br>}<br>```&lt;!--前面不能有空格--&gt;</p>','2017-05-06',0,47,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(489,'代理模式','代理模式(Proxy Pattern) GoF中给出的代理模式的定义为： 代理模式给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。 代理模式的英文叫做Proxy或Surrogate，它是一种对象结构型模式。 代理模式根据其目的和实现可分为很多种类，常用的代理模式包括如下几种： （1）远程代理（Remote Proxy）————为一个位于不同的地址空间的对象提供一个本地的代理对象','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h1 id=\"h1--proxy-pattern-\"><a name=\"代理模式(Proxy Pattern)\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代理模式(Proxy Pattern)</h1><p>GoF中给出的代理模式的定义为：<br>代理模式给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。<br>代理模式的英文叫做Proxy或Surrogate，它是一种对象结构型模式。<br>代理模式根据其目的和实现可分为很多种类，常用的代理模式包括如下几种：<br>（1）远程代理（Remote Proxy）————为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以是在同一台主机中，也可以是在另一台主机中，远程代理又称为大使（Ambassador）<br>（2）虚拟代理（Virtual Proxy）————如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。<br>（3）保护代理（Protect Proxy）————控制一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。<br>（4）缓冲代理（Cache Proxy）————为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。<br>（5）只能引用代理（Smart Reference Proxy）————当一个对象被引用时，提供一些额外的操作，例如将对象被调用的次数记录下来。<br><img src=\"http://ohlrxdl4p.bkt.clouddn.com/images/QQ截图20170507103646.jpg\" alt=\"\"></p>\n<p>代码实现：<br>1.抽象主题类——BuyTicket.java</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code class=\"lang-java\"><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">interface</span><span class=\"pln\"> </span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> showticket</span><span class=\"pun\">();</span></code></li><li class=\"L2\"><code class=\"lang-java\"><span class=\"pun\">}</span></code></li></ol></pre>\n<p>2.具体主题类——Train.java</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code class=\"lang-java\"><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Train</span><span class=\"pln\"> </span><span class=\"kwd\">implements</span><span class=\"pln\"> </span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"lit\">@Override</span></code></li><li class=\"L2\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> showticket</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L3\"><code class=\"lang-java\"><span class=\"pln\">        </span><span class=\"typ\">System</span><span class=\"pun\">.</span><span class=\"pln\">out</span><span class=\"pun\">.</span><span class=\"pln\">println</span><span class=\"pun\">(</span><span class=\"str\">\"one ticket\"</span><span class=\"pun\">);</span></code></li><li class=\"L4\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L5\"><code class=\"lang-java\"><span class=\"pun\">}</span></code></li></ol></pre>\n<p>3.代理角色类——TicketCenter.java</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code class=\"lang-java\"><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">TicketCenter</span><span class=\"pln\"> </span><span class=\"kwd\">implements</span><span class=\"pln\"> </span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> ticket</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code class=\"lang-java\"></code></li><li class=\"L3\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"typ\">TicketCenter</span><span class=\"pun\">(</span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> ticket</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code class=\"lang-java\"><span class=\"pln\">        </span><span class=\"kwd\">this</span><span class=\"pun\">.</span><span class=\"pln\">ticket </span><span class=\"pun\">=</span><span class=\"pln\"> ticket</span><span class=\"pun\">;</span></code></li><li class=\"L5\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code class=\"lang-java\"></code></li><li class=\"L7\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"lit\">@Override</span></code></li><li class=\"L8\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> showticket</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L9\"><code class=\"lang-java\"><span class=\"pln\">        ticket</span><span class=\"pun\">.</span><span class=\"pln\">showticket</span><span class=\"pun\">();</span></code></li><li class=\"L0\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code class=\"lang-java\"></code></li><li class=\"L2\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> buy</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L3\"><code class=\"lang-java\"><span class=\"pln\">        </span><span class=\"typ\">System</span><span class=\"pun\">.</span><span class=\"pln\">out</span><span class=\"pun\">.</span><span class=\"pln\">println</span><span class=\"pun\">(</span><span class=\"str\">\"by proxy\"</span><span class=\"pun\">);</span></code></li><li class=\"L4\"><code class=\"lang-java\"><span class=\"pln\">        showticket</span><span class=\"pun\">();</span></code></li><li class=\"L5\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code class=\"lang-java\"><span class=\"pun\">}</span></code></li></ol></pre>\n<p>4.客户端测试类</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code class=\"lang-java\"><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">ProxyPattern</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> main</span><span class=\"pun\">(</span><span class=\"typ\">String</span><span class=\"pln\"> args</span><span class=\"pun\">[])</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L2\"><code class=\"lang-java\"><span class=\"pln\">        </span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> x </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Train</span><span class=\"pun\">();</span></code></li><li class=\"L3\"><code class=\"lang-java\"><span class=\"pln\">        </span><span class=\"typ\">TicketCenter</span><span class=\"pln\"> y </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">TicketCenter</span><span class=\"pun\">(</span><span class=\"pln\">x</span><span class=\"pun\">);</span></code></li><li class=\"L4\"><code class=\"lang-java\"><span class=\"pln\">        y</span><span class=\"pun\">.</span><span class=\"pln\">buy</span><span class=\"pun\">();</span></code></li><li class=\"L5\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code class=\"lang-java\"><span class=\"pun\">}</span></code></li></ol></pre>\n<p>运行结果：</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code class=\"lang-html\"><span class=\"pln\">by proxy</span></code></li><li class=\"L1\"><code class=\"lang-html\"><span class=\"pln\">one ticket</span></code></li></ol></pre>\n</div>','2017-05-07',0,39,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(490,'2017-02-28学习笔记','','<p><img src=\"http://ohlrxdl4p.bkt.clouddn.com/images/826546_1482322555369_C5DABB18734059E89A45A0E9170722B0.png\" alt=\"\"></p>','2017-02-28',0,35,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(491,'2017-03-01学习笔记','知识点 1.java中只有值传递，没有引用传递http://guhanjie.iteye.com/blog/1683637 2.final关键字 final修饰变量，则等同于常量. final修饰方法中的参数，称为最终参数. final修饰类，则类不能被继承. final修饰方法，则方法不能被','<h1 id=\"h1-u77E5u8BC6u70B9\"><a name=\"知识点\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>知识点</h1><h4 id=\"h4-1-java-http-guhanjie-iteye-com-blog-1683637\"><a name=\"1.java中只有值传递，没有引用传递  http://guhanjie.iteye.com/blog/1683637\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.java中只有值传递，没有引用传递<a href=\"http://guhanjie.iteye.com/blog/1683637\">http://guhanjie.iteye.com/blog/1683637</a></h4><h4 id=\"h4-2-final-\"><a name=\"2.final关键字\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.final关键字</h4><ul>\r\n<li>final修饰变量，则等同于常量.</li><li>final修饰方法中的参数，称为最终参数.</li><li>final修饰类，则类不能被继承.</li><li>final修饰方法，则方法不能被重写.</li></ul>\r\n<h4 id=\"h4-3-integer-img-src-https-uploadfiles-nowcoder-com-images-20160717-6316247_1468761643205_9f7b85ab04292cf73778d98998a20ed1-alt-\"><a name=\"3.Integer<img src=\"https://uploadfiles.nowcoder.com/images/20160717/6316247_1468761643205_9F7B85AB04292CF73778D98998A20ED1\" alt=\"图片\">\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.Integer<img src=\"https://uploadfiles.nowcoder.com/images/20160717/6316247_1468761643205_9F7B85AB04292CF73778D98998A20ED1\" alt=\"图片\"></h4><h4 id=\"h4-4-java-\"><a name=\"4.java内存模型   点击原文\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.java内存模型 <a href=\"http://blog.csdn.net/ns_code/article/details/17565503\">点击原文</a></h4><p><img src=\"https://uploadfiles.nowcoder.com/images/20161223/415611_1482452184396_6FB53C51539B47559CF0D122A832CF63\" alt=\"\"></p>\r\n<h4 id=\"h4-5-java-reference\"><a name=\"5.java中是没有指针的，有reference\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.java中是没有指针的，有reference</h4><p>第一：指针变量是在栈内存中，它也是有值的，这个值存储的就是地址单元，这个地址就是来自于赋值操作。<br>第二：指针变量有类型，这个类型（如Person）的含义是指针指向的变量在栈内存（不是很确定）中的范围（大小），我理解为是占用的堆内存空间。<br>第三：声明一个对象时，是对“指针变量”的定义。<br>第四：用new关键字在堆内存创建了对象，在赋值时，是把这个对象的首地址传给了这个“指针变量”（即引用型变量）。</p>\r\n<h4 id=\"h4-6-string-\"><a name=\"6.String生成常量\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6.String生成常量</h4><pre><code class=\"lang-java\">String s1=&quot;abc&quot;+&quot;def&quot;;//生成的是一个常量，放在堆内存中\r\nString s2=new String（s1);//s2是一个变量\r\nif(s1.equals(s2))//比较的是字符串的内容\r\n    System.out.println(&quot;.equals succeeded&quot;);//输出\r\nif(s1==s2)//比较的是内存地址，但s1是常量，所以不相等\r\n    System.out.println(&quot;==succeeded&quot;);\r\n</code></pre>\r\n<h4 id=\"h4-7-jsp-\"><a name=\"7.jsp内置对象和属性\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>7.jsp内置对象和属性</h4><p>（１）request对象<br>客户端的请求信息被封装在request对象中，通过它才能了解到客户的需求，然后做出响应。它是HttpServletRequest类的实例。<br>（２）response对象<br>response对象包含了响应客户请求的有关信息，但在JSP中很少直接用到它。它是HttpServletResponse类的实例。<br>（３）session对象<br>session对象指的是客户端与服务器的一次会话，从客户连到服务器的一个WebApplication开始，直到客户端与服务器断开连接为止。它是HttpSession类的实例.<br>（４）out对象<br>out对象是JspWriter类的实例,是向客户端输出内容常用的对象<br>（５）page对象<br>page对象就是指向当前JSP页面本身，有点象类中的this指针，它是java.lang.Object类的实例<br>（６）application对象<br>application对象实现了用户间数据的共享，可存放全局变量。它开始于服务器的启动，直到服务器的关闭，在此期间，此对象将一直存在；这样在用户的前后连接或不同用户之间的连接中，可以对此对象的同一属性进行操作；在任何地方对此对象属性的操作，都将影响到其他用户对此的访问。服务器的启动和关闭决定了application对象的生命。它是ServletContext类的实例。<br>（７）exception对象<br>exception对象是一个例外对象，当一个页面在运行过程中发生了例外，就产生这个对象。如果一个JSP页面要应用此对象，就必须把isErrorPage设为true，否则无法编译。他实际上是java.lang.Throwable的对象<br>（８）pageContext对象<br>pageContext对象提供了对JSP页面内所有的对象及名字空间的访问，也就是说他可以访问到本页所在的SESSION，也可以取本页面所在的application的某一属性值，他相当于页面中所有功能的集大成者，它的本 类名也叫pageContext。<br>（９）config对象<br>config对象是在一个Servlet初始化时，JSP引擎向它传递信息用的，此信息包括Servlet初始化时所要用到的参数（通过属性名和属性值构成）以及服务器的有关信息（通过传递一个ServletContext对象）</p>','2017-03-01',0,26,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(492,'2017-03-02学习笔记','知识点 一、static public class Spike\r\n{\r\n    public static void main(String[] args)\r\n    {\r\n        Counter a = new Counter();\r\n        System.out.println(a.increment());\r\n        System.out.println(a.anot','<h1 id=\"h1-u77E5u8BC6u70B9\"><a name=\"知识点\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>知识点</h1><h4 id=\"h4--static\"><a name=\"一、static\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、static</h4><pre><code class=\"lang-java\">public class Spike\r\n{\r\n    public static void main(String[] args)\r\n    {\r\n        Counter a = new Counter();\r\n        System.out.println(a.increment());\r\n        System.out.println(a.anotherIncrement());\r\n        Counter b = new Counter();\r\n        System.out.println(b.increment());\r\n    }\r\n}\r\nclass Counter\r\n{\r\n    private static int count = 0;\r\n    public int increment()\r\n    {\r\n        return count++;\r\n    }\r\n    public int anotherIncrement()\r\n    {\r\n        return ++count;\r\n    }\r\n}\r\n</code></pre>\r\n<p>count是静态变量，为所有对象所共享，因此不管a.increment()还是b.increment()都会使count持续增加。<br>increment()方法返回当前count值，然后count增加1<br>antoherIncrement()方法让count增加1，然后返回count值<br>第一次a.increment()返回值为0，此时count值为1<br>第二次a.anotherIncrement()先让count+1再返回，返回值为2<br>第三次b.increment()先返回count当前值2，然后count+1</p>\r\n<h4 id=\"h4--aop-\"><a name=\"二、AOP面向切面\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、AOP面向切面</h4><p>AOP的概念是Aspected Oriented Programming 面向方面编程。<br>  好处：AOP将程序分解成各个方面或者说关注点。这使得可以模块化，相当横向上分切了。它可以解决OOP和过程化方法不能够很好解决的横切（crosscut）问题，如：事务、安全、日志等横切关注。<br>  实现AOP有几种方式:<br>  1.Spring 1.2版本中通过ProxyFactoryBean来实现aop,即通过动态代理来实现的,Aspect必须继承MethodBeforeAdvice,MethodAfterAdvice等<br>  2.Spring 2.0 AOP需要改的是FBI 这个类，而且它也不需要再实现某些接口<br>  3.三使用标注（<a href=\"https://github.com/AspectJ\" title=\"&#64;AspectJ\" class=\"at-link\">@AspectJ</a>）实现AOP<br>    AOP 和 OOP的区别：</p>\r\n<pre><code>```html\r\n 1. 面向方面编程 AOP 偏重业务处理过程的某个步骤或阶段，强调降低模块之间的耦合度，使代码拥有更好的移植性。  \r\n 2. 面向对象编程 (oop) 则是对业务分析中抽取的实体进行方法和属性的封装。\r\n ```\r\n</code></pre><p>也可以说 AOP 是面向业务中的动词领域， OOP 面向名词领域。<br>AOP 的一个很重要的特点是源代码无关性，也就是说如果我们的系统中引用了 AOP 组件，即使我们把该组件去掉，系统代码也应该能够编译通过。要实现这一点，可以使用动态 proxy 模式。</p>\r\n<h4 id=\"h4--jdbc-\"><a name=\"三、jdbc桥接模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、jdbc桥接模式</h4><p>桥接模式：<br>定义 ：将抽象部分与它的实现部分分离，使它们都可以独立地变化。<br>意图 ：将抽象与实现解耦。<br>桥接模式所涉及的角色</p>\r\n<ol>\r\n<li>Abstraction ：定义抽象接口，拥有一个Implementor类型的对象引用</li><li>RefinedAbstraction ：扩展Abstraction中的接口定义</li><li>Implementor ：是具体实现的接口，Implementor和RefinedAbstraction接口并不一定完全一致，实际上这两个接口可以完全不一样Implementor提供具体操作方法，而Abstraction提供更高层次的调用</li><li>ConcreteImplementor ：实现Implementor接口，给出具体实现<br>Jdk中的桥接模式：JDBC<br>JDBC连接 数据库 的时候，在各个数据库之间进行切换，基本不需要动太多的代码，甚至丝毫不动，原因就是JDBC提供了统一接口，每个数据库提供各自的实现，用一个叫做数据库驱动的程序来桥接就行了<h4 id=\"h4--\"><a name=\"四、抽象类\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>四、抽象类</h4>抽象类和普通类有三点区别：<br>1）抽象方法必须为public和protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public。<br>2）抽象类不能用来创建对象，但是它可以有构造方法，用来帮助子类实例化。<br>3）如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为abstract类。<h4 id=\"h4--\"><a name=\"五、接口\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>五、接口</h4>接口的主要特点<br>1）接口中的成员变量默认都是public、static、final类型的，必须被显示初始化。<br>2）接口中的方法默认都是public、abstract类型的。<br>3）接口中只能包含public、static、final类型的成员变量和public、abstract类型的成员方法。<br>4）接口没有构造方法，不能被实例化。<br>5）一个接口不能实现另一个接口，但它可以继承多个其他接口。<br>6）接口必须通过类来实现它的抽象方法。<br>7）与子类继承抽象父类相似，当类实现了某个接口时，它必须实现接口中所有的抽象方法，否则这个类必须被定义为抽象类。<br>8）一个类只能继承一个直接的父类，但能实现多个接口。<h4 id=\"h4--\"><a name=\"六、抽象类和接口的区别\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>六、抽象类和接口的区别</h4>1）抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract方法；<br>2）抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；<br>3）接口中不能含有静态代码块以及静态方法，而抽象类尅有静态代码块和静态方法；<br>4）一个类只能继承一个抽象类，而一个类却可以实现多个接口。<br>5）抽象类中的方法子类必须全部实现，不然子类也是抽象类，而接口中的抽象方法子类必须全部实现，是可选择实现的。<br>6）抽象类是一种模板设计模式，而接口时一种行为规范。</li></ol>','2017-03-02',0,25,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(493,'2017-03-03学习笔记','一、String StringBuffer.toString()源码： @Override\r\npublic synchronized String toString() {\r\n    if (toStringCache == null) {\r\n        toStringCache = Arrays.copyOfRange(value, 0, count);\r\n    }\r\n    retur','<h4 id=\"h4--string\"><a name=\"一、String\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、String</h4><p>StringBuffer.toString()源码：</p>\r\n<pre><code class=\"lang-java\">@Override\r\npublic synchronized String toString() {\r\n    if (toStringCache == null) {\r\n        toStringCache = Arrays.copyOfRange(value, 0, count);\r\n    }\r\n    return new String(toStringCache, true);\r\n}\r\n</code></pre>\r\n<p>Arrays.copyOfRange用的是System.arraycopy</p>\r\n<pre><code class=\"lang-java\">public static char[] copyOfRange(char[] original, int from, int to) {\r\n        int newLength = to - from;\r\n        if (newLength &lt; 0)\r\n            throw new IllegalArgumentException(from + &quot; &gt; &quot; + to);\r\n        char[] copy = new char[newLength];\r\n        System.arraycopy(original, from, copy, 0,\r\n                         Math.min(original.length - from, newLength));\r\n        return copy;\r\n    }\r\n</code></pre>\r\n<p>1.String是值传入，不是引用传入。<br>2.String对String  类型进行改变的时候其实都等同于生成了一个新的  String  对象，然后将指针指向新的  String  对象，而不是StringBuffer；StringBuffer每次结果都会对  StringBuffer  对象本身进行操作，而不是生成新的对象，再改变对象引用。<br>3.效率比较String&lt;StringBuffer&lt;StringBuilder，但是在 String S1 = “This is only a” + “ simple” + “ test”时，String效率最高。</p>\r\n<h4 id=\"h4--jvm-\"><a name=\"二、jvm知识图谱\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、jvm知识图谱</h4><p><a href=\"https://zhuanlan.zhihu.com/p/25511795\">引用自知乎</a><br><img src=\"https://pic2.zhimg.com/v2-701563ac1fe745fc8e1234c96e82ac99_r.jpg\" alt=\"\"></p>\r\n<h4 id=\"h4--treemap-linkhashmap\"><a name=\"三、Treemap、LinkHashMap\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、Treemap、LinkHashMap</h4><p>1.TreeMap取出来的是排序后的键值对。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。<br>2.LinkedHashMap 是HashMap的一个子类，如果需要输出的顺序和输入的相同,那么用LinkedHashMap可以实现,它还可以按读取顺序来排列。</p>\r\n<h4 id=\"h4--sql-\"><a name=\"四、sql模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>四、sql模式</h4><p>MySQL数据库中，变量分为 系统变量（以”@@”开头）和用户自定义变量。系统变量分为全局系统变量(global)和会话系统变量(session)。<br>@<a href=\"https://github.com/global\" title=\"&#64;global\" class=\"at-link\">@global</a>     仅用于访问全局系统变量的值；<br>@<a href=\"https://github.com/session\" title=\"&#64;session\" class=\"at-link\">@session</a>  仅用于访问会话系统变量的值；<br>@@              先访问会话系统变量的值，若不存在则去访问全局系统变量的值；<br>sql_mode 为系统变量，既是全局系统变量，又是会话系统变量。</p>\r\n<h4 id=\"h4--\"><a name=\"五、代码的执行顺序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>五、代码的执行顺序</h4><p>父类Ｂ静态代码块-&gt;子类Ａ静态代码块-&gt;父类Ｂ非静态代码块-&gt;父类Ｂ构造函数-&gt;子类Ａ非静态代码块-&gt;子类Ａ构造函数<br><img src=\"http://ohlrxdl4p.bkt.clouddn.com/images/QQ截图20170303165728.jpg\" alt=\"\"></p>','2017-03-03',0,22,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(494,'ifhifhajfe','hello','<h1 id=\"h1-hello\"><a name=\"hello\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>hello</h1>','2017-03-05',0,23,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(495,'2017-03-05学习笔记','java的堆，栈，静态代码区（常量区） 详解','<p><a href=\"http://blog.csdn.net/u012031380/article/details/54981472\"> java的堆，栈，静态代码区（常量区） 详解</a></p>','2017-03-05',0,24,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(496,'java归并排序','package datastruct;\r\n\r\n/**\r\n * Created by Zephery on 2017/3/3.\r\n */\r\npublic class Solution {\r\n    public static void printArray(int[] arr, int i, int j) {\r\n        System.out.print(\"[\");\r\n        for','<pre><code class=\"lang-java\">package datastruct;\r\n\r\n/**\r\n * Created by Zephery on 2017/3/3.\r\n */\r\npublic class Solution {\r\n    public static void printArray(int[] arr, int i, int j) {\r\n        System.out.print(&quot;[&quot;);\r\n        for (int k = i; k &lt; j; k++) {\r\n            System.out.print(arr[k] + &quot;,&quot;);\r\n        }\r\n        System.out.print(arr[j] + &quot;]&quot;);\r\n    }\r\n\r\n    private static void mergesort(int[] arr, int i, int j) {\r\n        int mid = 0;\r\n        if (i &lt; j) {\r\n            mid = (i + j) / 2;\r\n            mergesort(arr, i, mid);\r\n            mergesort(arr, mid + 1, j);\r\n            merge(arr, i, mid, j);\r\n        }\r\n    }\r\n\r\n    private static void merge(int[] arr, int i, int mid, int j) {\r\n        System.out.print(&quot;Left:&quot;);\r\n        printArray(arr, i, mid);\r\n        System.out.println(&quot;Right:&quot;);\r\n        printArray(arr, mid + 1, j);\r\n        System.out.println();\r\n        int temp[] = new int[arr.length];\r\n        int l = i;\r\n        int r = j;\r\n        int m = mid + 1;\r\n        int k = l;\r\n        while (l &lt;= mid &amp;&amp; m &lt;= r) {\r\n            if (arr[l] &lt;= arr[m]) {\r\n                temp[k++] = arr[l++];\r\n            } else {\r\n                temp[k++] = arr[m++];\r\n            }\r\n        }\r\n        while (l &lt;= mid) {\r\n            temp[k++] = arr[l++];\r\n        }\r\n        while (m &lt;= r) {\r\n            temp[k++] = arr[m++];\r\n        }\r\n        for (int i1 = i; i1 &lt;= j; i1++) {\r\n            arr[i1] = temp[i1];\r\n        }\r\n        System.out.print(&quot;After Merge:&quot;);\r\n        printArray(arr, i, j);\r\n        System.out.println();\r\n    }\r\n\r\n    public static void main(String args[]) {\r\n        int[] arr = {9, 4, 8, 3, 1, 2, 5};\r\n        System.out.print(&quot;Initial Array:&quot;);\r\n        printArray(arr, 0, arr.length - 1);\r\n        System.out.println();\r\n        mergesort(arr, 0, arr.length - 1);\r\n    }\r\n}\r\n</code></pre>\r\n<pre><code class=\"lang-js\">Initial Array:[9,4,8,3,1,2,5]\r\nLeft:[9]Right:\r\n[4]\r\nAfter Merge:[4,9]\r\nLeft:[8]Right:\r\n[3]\r\nAfter Merge:[3,8]\r\nLeft:[4,9]Right:\r\n[3,8]\r\nAfter Merge:[3,4,8,9]\r\nLeft:[1]Right:\r\n[2]\r\nAfter Merge:[1,2]\r\nLeft:[1,2]Right:\r\n[5]\r\nAfter Merge:[1,2,5]\r\nLeft:[3,4,8,9]Right:\r\n[1,2,5]\r\nAfter Merge:[1,2,3,4,5,8,9]\r\n</code></pre>','2017-03-06',0,27,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(497,'2017-03-10学习笔记','1.Integer和int，装箱拆箱 1、基本型和基本型封装型进行“==”运算符的比较，基本型封装型将会自动拆箱变为基本型后再进行比较，因此Integer(0)会自动拆箱为int类型再进行比较，显然返回true； 2、两个Integer类型进行“==”比较，如果其值在-128至127，那么返回true，否则返回false, 这跟Integer.valueOf()的缓冲对象有关，这里不进行赘述。 3','<h1 id=\"h1-1-integer-int-\"><a name=\"1.Integer和int，装箱拆箱\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.Integer和int，装箱拆箱</h1><p>1、基本型和基本型封装型进行“==”运算符的比较，基本型封装型将会自动拆箱变为基本型后再进行比较，因此Integer(0)会自动拆箱为int类型再进行比较，显然返回true；<br>2、两个Integer类型进行“==”比较，如果其值在-128至127，那么返回true，否则返回false, 这跟Integer.valueOf()的缓冲对象有关，这里不进行赘述。<br>3、两个基本型的封装型进行equals()比较，首先equals()会比较类型，如果类型相同，则继续比较值，如果值也相同，返回true<br>4、基本型封装类型调用equals(),但是参数是基本类型，这时候，先会进行自动装箱，基本型转换为其封装类型，再进行3中的比较。</p>\r\n<pre><code class=\"lang-java\">int a=257;\r\nInteger b=257;\r\nInteger c=257;\r\nInteger b2=57;\r\nInteger c2=57;\r\nSystem.out.println(a==b);\r\n//System.out.println(a.equals(b));  编译出错，基本型不能调用equals()\r\nSystem.out.println(b.equals(257.0));\r\nSystem.out.println(b==c);\r\nSystem.out.println(b2==c2);\r\n</code></pre>\r\n<p>因此上面的代码的结果因此为 true, false, false, true</p>\r\n<h1 id=\"h1-2-\"><a name=\"2.线程调度\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.线程调度</h1><p>分为协同式调度和抢占式调度，Java使用的是抢占式调度，也就是每个线程将由操作系统来分配执行时间，线程的切换不由线程本身来决定（协同式调度）。这就是平台独立的原因。</p>\r\n<h1 id=\"h1-3-\"><a name=\"3.重载，重写\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.重载，重写</h1><p>重写：<br>两同，两小，一大<br>两同：方法名，方法参数列表相同。<br>两小：抛出的异常类型要小于等于父类，返回值类型要小于等于父类<br>一大：访问权限大于等于父类。<br>重载：<br>在同一个类中，方法名和方法参数列表不同，其他的（访问权限、返回值）随意。</p>\r\n<h1 id=\"h1-4-jvm-\"><a name=\"4.  JVM面试题\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.<a href=\"http://blog.csdn.net/hsk256/article/details/49104955\">JVM面试题</a></h1>','2017-03-10',0,26,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(498,'2017-03-12学习笔记','1.继承的加载顺序 执行顺序大体上可以说是先父类后子类，父类static域 ==》子类static域 ==》父类数据成员域 ==》父类构造器 ==》子类数据成员域 ==》子类构造器 2.优化Hibernate所鼓励的7大措施： 1.尽量使用many-to-one，避免使用单项one-to-many 2.灵活使用单向one-to-many 3.不用一对一，使用多对一代替一对一 4.配置对象缓存，不使','<h4 id=\"h4-1-\"><a name=\"1.  继承的加载顺序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.<a href=\"http://www.cnblogs.com/SirSmith/p/5536288.html\">继承的加载顺序</a></h4><p><img src=\"http://images2015.cnblogs.com/blog/452847/201605/452847-20160527221410288-2119099273.png\" alt=\"\"></p>\r\n<p>执行顺序大体上可以说是先父类后子类，父类static域 ==》子类static域 ==》父类数据成员域 ==》父类构造器 ==》子类数据成员域 ==》子类构造器</p>\r\n<h4 id=\"h4-2-hibernate-7-\"><a name=\"2.优化Hibernate所鼓励的7大措施：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.优化Hibernate所鼓励的7大措施：</h4><p>1.尽量使用many-to-one，避免使用单项one-to-many<br>2.灵活使用单向one-to-many<br>3.不用一对一，使用多对一代替一对一<br>4.配置对象缓存，不使用集合缓存<br>5.一对多使用Bag 多对一使用Set<br>6.继承使用显示多态 HQL:from object polymorphism=”exlicit” 避免查处所有对象<br>7.消除大表，使用二级缓存</p>\r\n<h4 id=\"h4-3-java-\"><a name=\"3.java中的数据类型分类：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.java中的数据类型分类：</h4><p>基本数据类型（或叫做原生类、内置类型）8种：<br>    整数：byte，short，int，long（默认是int类型）<br>    浮点类型： float，double（默认是double类型）<br>    字符类型：char<br>    布尔类型：boolean<br>引用数据类型3种：数组，类，接口</p>\r\n<h4 id=\"h4-4-\"><a name=\"4.触发器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.触发器</h4><p>drop trigger 删除触发器<br>Drop用于删除数据表或数据库，或删除数据表字段。<br>remove：删除数据库文件<br>Truncate：删除数据表中的数据（仅数据表中的数据，不删除表）。</p>','2017-03-12',0,25,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(499,'2017-03-14学习笔记','1.Servlet的生命周期分为5个阶段：加载、创建、初始化、处理客户请求、卸载。 (1)加载：容器通过类加载器使用servlet类对应的文件加载servlet (2)创建：通过调用servlet构造函数创建一个servlet对象 (3)初始化：调用init方法初始化 (4)处理客户请求：每当有一个客户请求，容器会创建一个线程来处理客户请求 (5)卸载：调用destroy方法让servlet自己释','<h4 id=\"h4-1-servlet-5-\"><a name=\"1.Servlet的生命周期分为5个阶段：加载、创建、初始化、处理客户请求、卸载。\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.Servlet的生命周期分为5个阶段：加载、创建、初始化、处理客户请求、卸载。</h4><p>(1)加载：容器通过类加载器使用servlet类对应的文件加载servlet<br>(2)创建：通过调用servlet构造函数创建一个servlet对象<br>(3)初始化：调用init方法初始化<br>(4)处理客户请求：每当有一个客户请求，容器会创建一个线程来处理客户请求<br>(5)卸载：调用destroy方法让servlet自己释放其占用的资源</p>\r\n<h4 id=\"h4-2-jsp\"><a name=\"2.JSP\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.JSP</h4><p><img src=\"http://uploadfiles.nowcoder.com/images/20160308/595432_1457414324036_C3D4EB7F2D61708D0C0BE2921A45B74D\" alt=\"\"></p>','2017-03-14',0,23,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(500,'2017-03-17学习笔记','1.GC线程是否和守护线程 2.java堆排序','<h4 id=\"h4-1-gc-\"><a name=\"1.GC线程是否和守护线程\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.GC线程是否和守护线程</h4><h4 id=\"h4-2-java-\"><a name=\"2.java堆排序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.java堆排序</h4>','2017-03-17',0,22,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(501,'重载与重写','目前的问题：父类的功能无法满足子类的需求。 方法重写的前提： 必须要存在继承的关系。 方法的重写: 子父类出了同名的函数，这个我们就称作为方法的重写。 什么是时候要使用方法的重写：父类的功能无法满足子类的需求时。 方法重写要注意的事项： 1.方法重写时， 方法名与形参列表必须一致。 2.方法重写时，子类的权限修饰符必须要大于或者等于父类的权限修饰符。 3.方法重写时，子类的返回值类型必须要小于或者','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><p>目前的问题：父类的功能无法满足子类的需求。</p>\n<p>方法重写的前提： 必须要存在继承的关系。</p>\n<p>方法的重写: 子父类出了同名的函数，这个我们就称作为方法的重写。</p>\n<p>什么是时候要使用方法的重写：父类的功能无法满足子类的需求时。</p>\n<p>方法重写要注意的事项：<br>    1.方法重写时， 方法名与形参列表必须一致。<br>    2.方法重写时，子类的权限修饰符必须要大于或者等于父类的权限修饰符。<br>    3.方法重写时，子类的返回值类型必须要小于或者 等于父类的返回值类型。<br>    4.方法重写时， 子类抛出的异常类型要小于或者等于父类抛出的异常类型。<br>            Exception(最坏)<br>            RuntimeException(小坏)</p>\n<p>方法的重载：在一个类中 存在两个或者两个 以上的同名函数,称作为方法重载。</p>\n<p>方法重载的要求</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"lit\">1.</span><span class=\"pln\"> </span><span class=\"pun\">函数名要一致。</span></code></li><li class=\"L1\"><code><span class=\"lit\">2.</span><span class=\"pln\"> </span><span class=\"pun\">形参列表不一致（形参的个数或形参</span><span class=\"pln\"> </span><span class=\"pun\">的类型不一致）</span></code></li><li class=\"L2\"><code><span class=\"lit\">3.</span><span class=\"pln\"> </span><span class=\"pun\">与返回值类型无关。</span></code></li></ol></pre></div>','2017-03-21',0,22,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(502,'垃圾回收算法','垃圾回收算法 1、标记-清除算法 2、复制算法 3、标记-整理算法 一、标记-清除算法 标记-清除算法采用从根集合进行扫描，对存活的对象对象标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收，如上图所示。 标记-清除算法不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效，但由于标记-清除算法直接回收不存活的对象，因此会造成内存碎片！ 二、复制算法 复制算法','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h2 id=\"h2-u5783u573Eu56DEu6536u7B97u6CD5\"><a name=\"垃圾回收算法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>垃圾回收算法</h2><p>1、标记-清除算法<br>2、复制算法<br>3、标记-整理算法</p>\n<h4 id=\"h4--\"><a name=\"一、标记-清除算法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、标记-清除算法</h4><p><img src=\"http://dl2.iteye.com/upload/attachment/0075/0386/29ae17ad-f8af-38b4-9e25-28ef3550858f.jpg\" alt=\"\">标记-清除算法采用从根集合进行扫描，对存活的对象对象标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收，如上图所示。<br>标记-清除算法不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效，但由于标记-清除算法直接回收不存活的对象，因此会造成内存碎片！</p>\n<h4 id=\"h4--\"><a name=\"二、复制算法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、复制算法</h4><p><img src=\"http://dl2.iteye.com/upload/attachment/0075/0388/91a656d4-f08a-377b-8eea-5785c2932533.jpg\" alt=\"\"><br>复制算法采用从根集合扫描，并将存活对象复制到一块新的，没有使用过的空间中，这种算法当控件存活的对象比较少时，极为高效，但是带来的成本是需要一块内存交换空间用于进行对象的移动。也就是我们前面提到的s0 s1等空间。</p>\n<h4 id=\"h4--\"><a name=\"三、标记-整理算法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、标记-整理算法</h4><p><img src=\"http://dl2.iteye.com/upload/attachment/0075/0390/6ba95f80-c7bc-3d09-b927-ac09297e9920.jpg\" alt=\"\"><br> 标记-整理算法采用标记-清除算法一样的方式进行对象的标记，但在清除时不同，在回收不存活的对象占用的空间后，会将所有的存活对象往左端空闲空间移动，并更新对应的指针。标记-整理算法是在标记-清除算法的基础上，又进行了对象的移动，因此成本更高，但是却解决了内存碎片的问题。</p>\n</div>','2017-04-09',0,23,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(503,'java分代回收','一、新生代内存的回收（minor GC）主要采用复制算法，下图展示了minor GC的执行过程。 二、对于新生代和旧生代，JVM可使用很多种垃圾回收器进行垃圾回收，下图展示了不同生代不通垃圾回收器，其中两个回收器之间有连线表示这两个回收器可以同时使用。 而这些垃圾回收器又分为串行回收方式、并行回收方式合并发回收方式执行，分别运用于不同的场景。如下图所示 三、收集器 1.Serial收集器 看名字我','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h2 id=\"h2--minor-gc-minor-gc-\"><a name=\"一、新生代内存的回收（minor GC）主要采用复制算法，下图展示了minor GC的执行过程。\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、新生代内存的回收（minor GC）主要采用复制算法，下图展示了minor GC的执行过程。</h2><p><img src=\"http://dl2.iteye.com/upload/attachment/0075/0392/732c7557-aa9a-3551-b14d-f543c5b0c94b.jpg\" alt=\"\"></p>\n<h2 id=\"h2--jvm-\"><a name=\"二、对于新生代和旧生代，JVM可使用很多种垃圾回收器进行垃圾回收，下图展示了不同生代不通垃圾回收器，其中两个回收器之间有连线表示这两个回收器可以同时使用。\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、对于新生代和旧生代，JVM可使用很多种垃圾回收器进行垃圾回收，下图展示了不同生代不通垃圾回收器，其中两个回收器之间有连线表示这两个回收器可以同时使用。</h2><p><img src=\"http://dl2.iteye.com/upload/attachment/0075/0394/0172f624-9018-3642-bf26-05a2c3071639.jpg\" alt=\"\"><br>而这些垃圾回收器又分为串行回收方式、并行回收方式合并发回收方式执行，分别运用于不同的场景。如下图所示<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0396/c962c2ad-273f-3de4-b2e3-a4dd8b946215.jpg\" alt=\"\"></p>\n<h2 id=\"h2--\"><a name=\"三、收集器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、收集器</h2><h4 id=\"h4-1-serial-\"><a name=\"1.Serial收集器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.Serial收集器</h4><p>看名字我们都可以看的出来，这个属于串行收集器。其运行示意图如下<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0398/681da5ca-5eff-3984-bece-3d80dfe905be.jpg\" alt=\"\"><br>    收集器是历史最悠久的一个回收器，JDK1.3之前广泛使用这个收集器，目前也是ClientVM下 ServerVM 4核4GB以下机器的默认垃圾回收器。串行收集器并不是只能使用一个CPU进行收集，而是当JVM需要进行垃圾回收的时候，需要中断所有的用户线程，知道它回收结束为止，因此又号称“Stop The World” 的垃圾回收器。注意，JVM中文名称为java虚拟机，因此它就像一台虚拟的电脑一样在工作，而其中的每一个线程就被认为是JVM的一个处理器，因此大家看到图中的CPU0、CPU1实际为用户的线程，而不是真正机器的CPU，大家不要误解哦。<br>    串行回收方式适合低端机器，是Client模式下的默认收集器，对CPU和内存的消耗不高，适合用户交互比较少，后台任务较多的系统。<br>    Serial收集器默认新旧生代的回收器搭配为Serial+ SerialOld</p>\n<h4 id=\"h4-2-parnew-\"><a name=\"2.ParNew收集器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.ParNew收集器</h4><p>ParNew收集器其实就是多线程版本的Serial收集器，其运行示意图如下<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0400/6443b39c-ed33-3d93-a690-87e646439561.jpg\" alt=\"\"><br>同样有Stop The World的问题，他是多CPU模式下的首选回收器（该回收器在单CPU的环境下回收效率远远低于Serial收集器，所以一定要注意场景哦），也是Server模式下的默认收集器。</p>\n<h4 id=\"h4-3-parallelscavenge\"><a name=\"3.ParallelScavenge\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.ParallelScavenge</h4><p>ParallelScavenge又被称为是吞吐量优先的收集器，器运行示意图如下<br><img src=\"http://dl.iteye.com/upload/attachment/0075/0402/5007beba-0b0e-3cf4-b146-c28b6c0dd696.jpg\" alt=\"\"><br> ParallelScavenge<br>所提到的吞吐量=程序运行时间/(JVM执行回收的时间+程序运行时间),假设程序运行了100分钟，JVM的垃圾回收占用1分钟，那么吞吐量就是99%。在当今网络告诉发达的今天，良好的响应速度是提升用户体验的一个重要指标，多核并行云计算的发展要求程序尽可能的使用CPU和内存资源，尽快的计算出最终结果，因此在交互不多的云端，比较适合使用该回收器。</p>\n<h4 id=\"h4-4-parallelold\"><a name=\"4.ParallelOld\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.ParallelOld</h4><p>ParallelOld是老生代并行收集器的一种，使用标记整理算法、是老生代吞吐量优先的一个收集器。这个收集器是JDK1.6之后刚引入的一款收集器，我们看之前那个图之间的关联关系可以看到，早期没有ParallelOld之前，吞吐量优先的收集器老生代只能使用串行回收收集器，大大的拖累了吞吐量优先的性能，自从JDK1.6之后，才能真正做到较高效率的吞吐量优先。其运行示意图如下<br><img src=\"http://dl.iteye.com/upload/attachment/0075/0406/9a14da85-f943-3408-ba88-c6bb3842a792.jpg\" alt=\"\"></p>\n<h4 id=\"h4-5-serialold\"><a name=\"5.SerialOld\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.SerialOld</h4><p>SerialOld是旧生代Client模式下的默认收集器，单线程执行；在JDK1.6之前也是ParallelScvenge回收新生代模式下旧生代的默认收集器，同时也是并发收集器CMS回收失败后的备用收集器。其运行示意图如下<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0404/ce7aabd5-b0e0-3cda-9b6c-607cf6ebf689.jpg\" alt=\"\"></p>\n<h4 id=\"h4-5-cms\"><a name=\"5.CMS\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.CMS</h4><p>CMS又称响应时间优先(最短回收停顿)的回收器，使用并发模式回收垃圾，使用标记-清除算法，CMS对CPU是非常敏感的，它的回收线程数=（CPU+3）/4，因此当CPU是2核的实惠，回收线程将占用的CPU资源的50%，而当CPU核心数为4时仅占用25%。他的运行示意图如下<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0408/4239228b-879f-382f-81c6-5c32799886d6.jpg\" alt=\"\"><br>模式主要分为四个过程：<br>1.初始标记<br>2.并发标记<br>3.重新标记<br>4.并发清除<br>在初始标记的时候，需要中断所有用户线程，在并发标记阶段，用户线程和标记线程<br>并发执行，而在这个过程中，随着内存引用关系的变化，可能会发生原来标记的对象被释放，进而引发新的垃圾，因此可能会产生一系列的浮动垃圾，不能被回收。</p>\n<p>CMS 为了确保能够扫描到所有的对象，避免在Initial Marking 中还有未标识到的对象，采用的方法为找到标记了的对象，并将这些对象放入Stack 中，扫描时寻找此对象依赖的对象，如果依赖的对象的地址在其之前，则将此对象进行标记，并同时放入Stack 中，如依赖的对象地址在其之后，则仅标记该对象。<br>在进行Concurrent Marking 时minor GC 也可能会同时进行，这个时候很容易造成旧生代对象引用关系改变，CMS 为了应对这样的并发现象，提供了一个Mod Union Table 来进行记录，在这个Mod Union Table中记录每次minor GC 后修改了的Card 的信息。这也是ParallelScavenge不能和CMS一起使用的原因。<br>CMS产生浮动垃圾的情况请见如下示意图<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0410/60e7c659-790a-3405-af70-9ca4cfd9258d.jpg\" alt=\"\"><br>在运行回收过后，c就变成了浮动垃圾。<br>由于CMS会产生浮动垃圾，当回收过后，浮动垃圾如果产生过多，同时因为使用标记-清除算法会产生碎片，可能会导致回收过后的连续空间仍然不能容纳新生代移动过来或者新创建的大资源，因此会导致CMS回收失败，进而触发另外一次FULL GC，而这时候则采用SerialOld进行二次回收。<br>同时CMS因为可能产生浮动垃圾，而CMS在执行回收的同时新生代也有可能在进行回收操作，为了保证旧生代能够存放新生代转移过来的数据，CMS在旧生代内存到达全部容量的68%就触发了CMS的回收！</p>\n<h4 id=\"h4-7-garbagefirst-g1-\"><a name=\"7.GarbageFirst(G1)\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>7.GarbageFirst(G1)</h4><p>我们再来看垃圾回收器的总图，刚才我们可以看到，我在图上标记了一个？，其实这是一个新的垃圾回收器，既可以回收新生代也可以回收旧生代，SunHotSpot 1.6u14以上EarlyAccess版本加入了这个回收器，sun公司预期SunHotSpot1.7发布正式版，他是商用高性能垃圾回收器，通过重新划分内存区域，整合优化CMS，同时注重吞吐量和响应时间，但是杯具的是被Oracle收购之后这个收集器属于商用收费收集器，因此目前基本上没有人使用，我们在这里也就不多介绍，更多信息可以参考oracle新版本JDK说明。</p>\n</div>','2017-04-09',0,23,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(504,'java汇编','java 汇编 http://download.csdn.net/download/jiangfuqiang/8403497','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><p>java 汇编<br><a href=\"http://download.csdn.net/download/jiangfuqiang/8403497\">http://download.csdn.net/download/jiangfuqiang/8403497</a></p>\n</div>','2017-04-10',0,24,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(505,'jvm','-XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><p>-XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly</p>\n</div>','2017-04-10',0,26,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(506,'Java堆.栈和常量池 笔记','Java堆.栈和常量池 笔记','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><p><a href=\"http://www.iteye.com/topic/634530\">Java堆.栈和常量池 笔记</a></p>\n</div>','2017-04-23',0,26,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(507,'工厂模式','工厂模式 目录 何为工厂模式 工厂方法与抽象工厂 如何在Java EE中通过@Producers与@Inject注解实现工厂模式 如何创建自定义注解以及通过@Qualifier消除具体实现之间的歧义 工厂模式有两种模式：工厂方法和抽象方法。它们的意图是一样的：提供一个接口，在不指定具体类的情况下创建相关或依赖的一系列对象。 一.何为工厂模式 工厂的目的在于创建对象。创建的逻辑被封装在工厂中，要么提','<h1 id=\"h1-u5DE5u5382u6A21u5F0F\"><a name=\"工厂模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>工厂模式</h1><p>目录</p>\r\n<ul>\r\n<li>何为工厂模式</li><li>工厂方法与抽象工厂</li><li>如何在Java EE中通过<a href=\"https://github.com/Producers\" title=\"&#64;Producers\" class=\"at-link\">@Producers</a>与<a href=\"https://github.com/Inject\" title=\"&#64;Inject\" class=\"at-link\">@Inject</a>注解实现工厂模式</li><li>如何创建自定义注解以及通过<a href=\"https://github.com/Qualifier\" title=\"&#64;Qualifier\" class=\"at-link\">@Qualifier</a>消除具体实现之间的歧义<br>工厂模式有两种模式：工厂方法和抽象方法。它们的意图是一样的：提供一个接口，在不指定具体类的情况下创建相关或依赖的一系列对象。</li></ul>\r\n<h3 id=\"h3--\"><a name=\"一.何为工厂模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一.何为工厂模式</h3><p>工厂的目的在于创建对象。创建的逻辑被封装在工厂中，要么提供一个方法来返回新创建的对象（工厂方法模式），要么将对象的创建委托给子类（抽象工厂模式）。<br>客户端不必考虑接口或类的不同实现，它只需通过工厂（工厂）获取接口实现的一个实例的即可，这样客户端与对象的创建就实现了解耦<br>解耦是应用依赖反转原则的结果，这带来了很多好处，其中最重要的好处就是实现了高层类与底层类之间的解耦。通过解耦，具体类实现的变化不会影响到客户端，这降低了类与类之间的耦合，并提升了灵活性。</p>\r\n<h3 id=\"h3--\"><a name=\"二.工厂方法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二.工厂方法</h3><p>GoF一书是这样描述工程方法模式的：“定义一个用于创建对象的接口，不过让子类决定实例化那个类”<br>工厂极大降低了new关键字的使用次数，并且将初始化过程与不同的具体实现封装起来。将这些需求中心化可以极大减少向系统中添加或删除具体类的影响以及具体的类依赖的影响。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src=\"http://ohlrxdl4p.bkt.clouddn.com/images/QQ截图20170506134421.jpg\" alt=\"\"><br><strong>1.使用普通代码实现工厂方法</strong><br>被具体实现继承的DrinksMachine抽象类</p>\r\n<pre><code class=\"lang-java\">public abstract class DrinksMachine {\r\n    public abstract Drink dispenseDrink();\r\n    public String displayMessage(){\r\n        return &quot;Thank for your custom.&quot;;\r\n    }\r\n}\r\n</code></pre>\r\n<p>DrinksMachine抽象类的CoffeeMachine实现</p>\r\n<pre><code class=\"lang-java\">public class CoffeeMachine extends DrinksMachine {\r\n    public Drink dispenseDrink() {\r\n        return new Coffee();\r\n    }\r\n}\r\n</code></pre>\r\n<p>DrinksMachine抽象类的SoftDrinksMachine实现</p>\r\n<pre><code class=\"lang-java\">public class SoftDrinksMachine extends DrinksMachine {\r\n    public Drink dispenseDrink() {\r\n        return new SoftDrink();\r\n    }\r\n}\r\n</code></pre>\r\n<p>Drink接口</p>\r\n<pre><code class=\"lang-java\">public interface Drink {}\r\n</code></pre>\r\n<p>Drink接口的SoftDrink实现</p>\r\n<pre><code class=\"lang-java\">public class SoftDrink implements Drink {\r\n    SoftDrink() {\r\n        System.out.println(&quot;Soft drink&quot;);\r\n    }\r\n}\r\n</code></pre>\r\n<p>Drink接口的Coffee实现</p>\r\n<pre><code class=\"lang-java\">public class Coffee implements Drink {\r\n    Coffee() {\r\n        System.out.println(&quot;Coffee&quot;);\r\n    }\r\n}\r\n</code></pre>\r\n<p>CoffeeType枚举<br>```java<br>public enum CoffeeType {EXPRESSO, LATTE}</p>\r\n<p>public Drink dispenseDrink(CoffeeType type) {<br>    Drink coffee = null;<br>    switch (type) {<br>        case EXPRESSO: coffee = new Expresso();<br>        case LATTE: coffee = new Latte();<br>    }<br>    return coffee;<br>}<br>```&lt;!--前面不能有空格--&gt;</p>','2017-05-06',0,32,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(508,'代理模式','代理模式(Proxy Pattern) GoF中给出的代理模式的定义为： 代理模式给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。 代理模式的英文叫做Proxy或Surrogate，它是一种对象结构型模式。 代理模式根据其目的和实现可分为很多种类，常用的代理模式包括如下几种： （1）远程代理（Remote Proxy）————为一个位于不同的地址空间的对象提供一个本地的代理对象','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h1 id=\"h1--proxy-pattern-\"><a name=\"代理模式(Proxy Pattern)\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代理模式(Proxy Pattern)</h1><p>GoF中给出的代理模式的定义为：<br>代理模式给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。<br>代理模式的英文叫做Proxy或Surrogate，它是一种对象结构型模式。<br>代理模式根据其目的和实现可分为很多种类，常用的代理模式包括如下几种：<br>（1）远程代理（Remote Proxy）————为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以是在同一台主机中，也可以是在另一台主机中，远程代理又称为大使（Ambassador）<br>（2）虚拟代理（Virtual Proxy）————如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。<br>（3）保护代理（Protect Proxy）————控制一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。<br>（4）缓冲代理（Cache Proxy）————为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。<br>（5）只能引用代理（Smart Reference Proxy）————当一个对象被引用时，提供一些额外的操作，例如将对象被调用的次数记录下来。<br><img src=\"http://ohlrxdl4p.bkt.clouddn.com/images/QQ截图20170507103646.jpg\" alt=\"\"></p>\n<p>代码实现：<br>1.抽象主题类——BuyTicket.java</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code class=\"lang-java\"><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">interface</span><span class=\"pln\"> </span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> showticket</span><span class=\"pun\">();</span></code></li><li class=\"L2\"><code class=\"lang-java\"><span class=\"pun\">}</span></code></li></ol></pre>\n<p>2.具体主题类——Train.java</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code class=\"lang-java\"><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Train</span><span class=\"pln\"> </span><span class=\"kwd\">implements</span><span class=\"pln\"> </span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"lit\">@Override</span></code></li><li class=\"L2\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> showticket</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L3\"><code class=\"lang-java\"><span class=\"pln\">        </span><span class=\"typ\">System</span><span class=\"pun\">.</span><span class=\"pln\">out</span><span class=\"pun\">.</span><span class=\"pln\">println</span><span class=\"pun\">(</span><span class=\"str\">\"one ticket\"</span><span class=\"pun\">);</span></code></li><li class=\"L4\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L5\"><code class=\"lang-java\"><span class=\"pun\">}</span></code></li></ol></pre>\n<p>3.代理角色类——TicketCenter.java</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code class=\"lang-java\"><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">TicketCenter</span><span class=\"pln\"> </span><span class=\"kwd\">implements</span><span class=\"pln\"> </span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> ticket</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code class=\"lang-java\"></code></li><li class=\"L3\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"typ\">TicketCenter</span><span class=\"pun\">(</span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> ticket</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code class=\"lang-java\"><span class=\"pln\">        </span><span class=\"kwd\">this</span><span class=\"pun\">.</span><span class=\"pln\">ticket </span><span class=\"pun\">=</span><span class=\"pln\"> ticket</span><span class=\"pun\">;</span></code></li><li class=\"L5\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code class=\"lang-java\"></code></li><li class=\"L7\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"lit\">@Override</span></code></li><li class=\"L8\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> showticket</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L9\"><code class=\"lang-java\"><span class=\"pln\">        ticket</span><span class=\"pun\">.</span><span class=\"pln\">showticket</span><span class=\"pun\">();</span></code></li><li class=\"L0\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code class=\"lang-java\"></code></li><li class=\"L2\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> buy</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L3\"><code class=\"lang-java\"><span class=\"pln\">        </span><span class=\"typ\">System</span><span class=\"pun\">.</span><span class=\"pln\">out</span><span class=\"pun\">.</span><span class=\"pln\">println</span><span class=\"pun\">(</span><span class=\"str\">\"by proxy\"</span><span class=\"pun\">);</span></code></li><li class=\"L4\"><code class=\"lang-java\"><span class=\"pln\">        showticket</span><span class=\"pun\">();</span></code></li><li class=\"L5\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code class=\"lang-java\"><span class=\"pun\">}</span></code></li></ol></pre>\n<p>4.客户端测试类</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code class=\"lang-java\"><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">ProxyPattern</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> main</span><span class=\"pun\">(</span><span class=\"typ\">String</span><span class=\"pln\"> args</span><span class=\"pun\">[])</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L2\"><code class=\"lang-java\"><span class=\"pln\">        </span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> x </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Train</span><span class=\"pun\">();</span></code></li><li class=\"L3\"><code class=\"lang-java\"><span class=\"pln\">        </span><span class=\"typ\">TicketCenter</span><span class=\"pln\"> y </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">TicketCenter</span><span class=\"pun\">(</span><span class=\"pln\">x</span><span class=\"pun\">);</span></code></li><li class=\"L4\"><code class=\"lang-java\"><span class=\"pln\">        y</span><span class=\"pun\">.</span><span class=\"pln\">buy</span><span class=\"pun\">();</span></code></li><li class=\"L5\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code class=\"lang-java\"><span class=\"pun\">}</span></code></li></ol></pre>\n<p>运行结果：</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code class=\"lang-html\"><span class=\"pln\">by proxy</span></code></li><li class=\"L1\"><code class=\"lang-html\"><span class=\"pln\">one ticket</span></code></li></ol></pre>\n</div>','2017-05-07',0,63,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(509,'2017-02-28学习笔记','','<p><img src=\"http://ohlrxdl4p.bkt.clouddn.com/images/826546_1482322555369_C5DABB18734059E89A45A0E9170722B0.png\" alt=\"\"></p>','2017-02-28',0,30,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(510,'2017-03-01学习笔记','知识点 1.java中只有值传递，没有引用传递http://guhanjie.iteye.com/blog/1683637 2.final关键字 final修饰变量，则等同于常量. final修饰方法中的参数，称为最终参数. final修饰类，则类不能被继承. final修饰方法，则方法不能被','<h1 id=\"h1-u77E5u8BC6u70B9\"><a name=\"知识点\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>知识点</h1><h4 id=\"h4-1-java-http-guhanjie-iteye-com-blog-1683637\"><a name=\"1.java中只有值传递，没有引用传递  http://guhanjie.iteye.com/blog/1683637\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.java中只有值传递，没有引用传递<a href=\"http://guhanjie.iteye.com/blog/1683637\">http://guhanjie.iteye.com/blog/1683637</a></h4><h4 id=\"h4-2-final-\"><a name=\"2.final关键字\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.final关键字</h4><ul>\r\n<li>final修饰变量，则等同于常量.</li><li>final修饰方法中的参数，称为最终参数.</li><li>final修饰类，则类不能被继承.</li><li>final修饰方法，则方法不能被重写.</li></ul>\r\n<h4 id=\"h4-3-integer-img-src-https-uploadfiles-nowcoder-com-images-20160717-6316247_1468761643205_9f7b85ab04292cf73778d98998a20ed1-alt-\"><a name=\"3.Integer<img src=\"https://uploadfiles.nowcoder.com/images/20160717/6316247_1468761643205_9F7B85AB04292CF73778D98998A20ED1\" alt=\"图片\">\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.Integer<img src=\"https://uploadfiles.nowcoder.com/images/20160717/6316247_1468761643205_9F7B85AB04292CF73778D98998A20ED1\" alt=\"图片\"></h4><h4 id=\"h4-4-java-\"><a name=\"4.java内存模型   点击原文\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.java内存模型 <a href=\"http://blog.csdn.net/ns_code/article/details/17565503\">点击原文</a></h4><p><img src=\"https://uploadfiles.nowcoder.com/images/20161223/415611_1482452184396_6FB53C51539B47559CF0D122A832CF63\" alt=\"\"></p>\r\n<h4 id=\"h4-5-java-reference\"><a name=\"5.java中是没有指针的，有reference\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.java中是没有指针的，有reference</h4><p>第一：指针变量是在栈内存中，它也是有值的，这个值存储的就是地址单元，这个地址就是来自于赋值操作。<br>第二：指针变量有类型，这个类型（如Person）的含义是指针指向的变量在栈内存（不是很确定）中的范围（大小），我理解为是占用的堆内存空间。<br>第三：声明一个对象时，是对“指针变量”的定义。<br>第四：用new关键字在堆内存创建了对象，在赋值时，是把这个对象的首地址传给了这个“指针变量”（即引用型变量）。</p>\r\n<h4 id=\"h4-6-string-\"><a name=\"6.String生成常量\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6.String生成常量</h4><pre><code class=\"lang-java\">String s1=&quot;abc&quot;+&quot;def&quot;;//生成的是一个常量，放在堆内存中\r\nString s2=new String（s1);//s2是一个变量\r\nif(s1.equals(s2))//比较的是字符串的内容\r\n    System.out.println(&quot;.equals succeeded&quot;);//输出\r\nif(s1==s2)//比较的是内存地址，但s1是常量，所以不相等\r\n    System.out.println(&quot;==succeeded&quot;);\r\n</code></pre>\r\n<h4 id=\"h4-7-jsp-\"><a name=\"7.jsp内置对象和属性\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>7.jsp内置对象和属性</h4><p>（１）request对象<br>客户端的请求信息被封装在request对象中，通过它才能了解到客户的需求，然后做出响应。它是HttpServletRequest类的实例。<br>（２）response对象<br>response对象包含了响应客户请求的有关信息，但在JSP中很少直接用到它。它是HttpServletResponse类的实例。<br>（３）session对象<br>session对象指的是客户端与服务器的一次会话，从客户连到服务器的一个WebApplication开始，直到客户端与服务器断开连接为止。它是HttpSession类的实例.<br>（４）out对象<br>out对象是JspWriter类的实例,是向客户端输出内容常用的对象<br>（５）page对象<br>page对象就是指向当前JSP页面本身，有点象类中的this指针，它是java.lang.Object类的实例<br>（６）application对象<br>application对象实现了用户间数据的共享，可存放全局变量。它开始于服务器的启动，直到服务器的关闭，在此期间，此对象将一直存在；这样在用户的前后连接或不同用户之间的连接中，可以对此对象的同一属性进行操作；在任何地方对此对象属性的操作，都将影响到其他用户对此的访问。服务器的启动和关闭决定了application对象的生命。它是ServletContext类的实例。<br>（７）exception对象<br>exception对象是一个例外对象，当一个页面在运行过程中发生了例外，就产生这个对象。如果一个JSP页面要应用此对象，就必须把isErrorPage设为true，否则无法编译。他实际上是java.lang.Throwable的对象<br>（８）pageContext对象<br>pageContext对象提供了对JSP页面内所有的对象及名字空间的访问，也就是说他可以访问到本页所在的SESSION，也可以取本页面所在的application的某一属性值，他相当于页面中所有功能的集大成者，它的本 类名也叫pageContext。<br>（９）config对象<br>config对象是在一个Servlet初始化时，JSP引擎向它传递信息用的，此信息包括Servlet初始化时所要用到的参数（通过属性名和属性值构成）以及服务器的有关信息（通过传递一个ServletContext对象）</p>','2017-03-01',0,26,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(511,'2017-03-02学习笔记','知识点 一、static public class Spike\r\n{\r\n    public static void main(String[] args)\r\n    {\r\n        Counter a = new Counter();\r\n        System.out.println(a.increment());\r\n        System.out.println(a.anot','<h1 id=\"h1-u77E5u8BC6u70B9\"><a name=\"知识点\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>知识点</h1><h4 id=\"h4--static\"><a name=\"一、static\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、static</h4><pre><code class=\"lang-java\">public class Spike\r\n{\r\n    public static void main(String[] args)\r\n    {\r\n        Counter a = new Counter();\r\n        System.out.println(a.increment());\r\n        System.out.println(a.anotherIncrement());\r\n        Counter b = new Counter();\r\n        System.out.println(b.increment());\r\n    }\r\n}\r\nclass Counter\r\n{\r\n    private static int count = 0;\r\n    public int increment()\r\n    {\r\n        return count++;\r\n    }\r\n    public int anotherIncrement()\r\n    {\r\n        return ++count;\r\n    }\r\n}\r\n</code></pre>\r\n<p>count是静态变量，为所有对象所共享，因此不管a.increment()还是b.increment()都会使count持续增加。<br>increment()方法返回当前count值，然后count增加1<br>antoherIncrement()方法让count增加1，然后返回count值<br>第一次a.increment()返回值为0，此时count值为1<br>第二次a.anotherIncrement()先让count+1再返回，返回值为2<br>第三次b.increment()先返回count当前值2，然后count+1</p>\r\n<h4 id=\"h4--aop-\"><a name=\"二、AOP面向切面\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、AOP面向切面</h4><p>AOP的概念是Aspected Oriented Programming 面向方面编程。<br>  好处：AOP将程序分解成各个方面或者说关注点。这使得可以模块化，相当横向上分切了。它可以解决OOP和过程化方法不能够很好解决的横切（crosscut）问题，如：事务、安全、日志等横切关注。<br>  实现AOP有几种方式:<br>  1.Spring 1.2版本中通过ProxyFactoryBean来实现aop,即通过动态代理来实现的,Aspect必须继承MethodBeforeAdvice,MethodAfterAdvice等<br>  2.Spring 2.0 AOP需要改的是FBI 这个类，而且它也不需要再实现某些接口<br>  3.三使用标注（<a href=\"https://github.com/AspectJ\" title=\"&#64;AspectJ\" class=\"at-link\">@AspectJ</a>）实现AOP<br>    AOP 和 OOP的区别：</p>\r\n<pre><code>```html\r\n 1. 面向方面编程 AOP 偏重业务处理过程的某个步骤或阶段，强调降低模块之间的耦合度，使代码拥有更好的移植性。  \r\n 2. 面向对象编程 (oop) 则是对业务分析中抽取的实体进行方法和属性的封装。\r\n ```\r\n</code></pre><p>也可以说 AOP 是面向业务中的动词领域， OOP 面向名词领域。<br>AOP 的一个很重要的特点是源代码无关性，也就是说如果我们的系统中引用了 AOP 组件，即使我们把该组件去掉，系统代码也应该能够编译通过。要实现这一点，可以使用动态 proxy 模式。</p>\r\n<h4 id=\"h4--jdbc-\"><a name=\"三、jdbc桥接模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、jdbc桥接模式</h4><p>桥接模式：<br>定义 ：将抽象部分与它的实现部分分离，使它们都可以独立地变化。<br>意图 ：将抽象与实现解耦。<br>桥接模式所涉及的角色</p>\r\n<ol>\r\n<li>Abstraction ：定义抽象接口，拥有一个Implementor类型的对象引用</li><li>RefinedAbstraction ：扩展Abstraction中的接口定义</li><li>Implementor ：是具体实现的接口，Implementor和RefinedAbstraction接口并不一定完全一致，实际上这两个接口可以完全不一样Implementor提供具体操作方法，而Abstraction提供更高层次的调用</li><li>ConcreteImplementor ：实现Implementor接口，给出具体实现<br>Jdk中的桥接模式：JDBC<br>JDBC连接 数据库 的时候，在各个数据库之间进行切换，基本不需要动太多的代码，甚至丝毫不动，原因就是JDBC提供了统一接口，每个数据库提供各自的实现，用一个叫做数据库驱动的程序来桥接就行了<h4 id=\"h4--\"><a name=\"四、抽象类\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>四、抽象类</h4>抽象类和普通类有三点区别：<br>1）抽象方法必须为public和protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public。<br>2）抽象类不能用来创建对象，但是它可以有构造方法，用来帮助子类实例化。<br>3）如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为abstract类。<h4 id=\"h4--\"><a name=\"五、接口\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>五、接口</h4>接口的主要特点<br>1）接口中的成员变量默认都是public、static、final类型的，必须被显示初始化。<br>2）接口中的方法默认都是public、abstract类型的。<br>3）接口中只能包含public、static、final类型的成员变量和public、abstract类型的成员方法。<br>4）接口没有构造方法，不能被实例化。<br>5）一个接口不能实现另一个接口，但它可以继承多个其他接口。<br>6）接口必须通过类来实现它的抽象方法。<br>7）与子类继承抽象父类相似，当类实现了某个接口时，它必须实现接口中所有的抽象方法，否则这个类必须被定义为抽象类。<br>8）一个类只能继承一个直接的父类，但能实现多个接口。<h4 id=\"h4--\"><a name=\"六、抽象类和接口的区别\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>六、抽象类和接口的区别</h4>1）抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract方法；<br>2）抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；<br>3）接口中不能含有静态代码块以及静态方法，而抽象类尅有静态代码块和静态方法；<br>4）一个类只能继承一个抽象类，而一个类却可以实现多个接口。<br>5）抽象类中的方法子类必须全部实现，不然子类也是抽象类，而接口中的抽象方法子类必须全部实现，是可选择实现的。<br>6）抽象类是一种模板设计模式，而接口时一种行为规范。</li></ol>','2017-03-02',0,27,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(512,'2017-03-03学习笔记','一、String StringBuffer.toString()源码： @Override\r\npublic synchronized String toString() {\r\n    if (toStringCache == null) {\r\n        toStringCache = Arrays.copyOfRange(value, 0, count);\r\n    }\r\n    retur','<h4 id=\"h4--string\"><a name=\"一、String\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、String</h4><p>StringBuffer.toString()源码：</p>\r\n<pre><code class=\"lang-java\">@Override\r\npublic synchronized String toString() {\r\n    if (toStringCache == null) {\r\n        toStringCache = Arrays.copyOfRange(value, 0, count);\r\n    }\r\n    return new String(toStringCache, true);\r\n}\r\n</code></pre>\r\n<p>Arrays.copyOfRange用的是System.arraycopy</p>\r\n<pre><code class=\"lang-java\">public static char[] copyOfRange(char[] original, int from, int to) {\r\n        int newLength = to - from;\r\n        if (newLength &lt; 0)\r\n            throw new IllegalArgumentException(from + &quot; &gt; &quot; + to);\r\n        char[] copy = new char[newLength];\r\n        System.arraycopy(original, from, copy, 0,\r\n                         Math.min(original.length - from, newLength));\r\n        return copy;\r\n    }\r\n</code></pre>\r\n<p>1.String是值传入，不是引用传入。<br>2.String对String  类型进行改变的时候其实都等同于生成了一个新的  String  对象，然后将指针指向新的  String  对象，而不是StringBuffer；StringBuffer每次结果都会对  StringBuffer  对象本身进行操作，而不是生成新的对象，再改变对象引用。<br>3.效率比较String&lt;StringBuffer&lt;StringBuilder，但是在 String S1 = “This is only a” + “ simple” + “ test”时，String效率最高。</p>\r\n<h4 id=\"h4--jvm-\"><a name=\"二、jvm知识图谱\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、jvm知识图谱</h4><p><a href=\"https://zhuanlan.zhihu.com/p/25511795\">引用自知乎</a><br><img src=\"https://pic2.zhimg.com/v2-701563ac1fe745fc8e1234c96e82ac99_r.jpg\" alt=\"\"></p>\r\n<h4 id=\"h4--treemap-linkhashmap\"><a name=\"三、Treemap、LinkHashMap\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、Treemap、LinkHashMap</h4><p>1.TreeMap取出来的是排序后的键值对。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。<br>2.LinkedHashMap 是HashMap的一个子类，如果需要输出的顺序和输入的相同,那么用LinkedHashMap可以实现,它还可以按读取顺序来排列。</p>\r\n<h4 id=\"h4--sql-\"><a name=\"四、sql模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>四、sql模式</h4><p>MySQL数据库中，变量分为 系统变量（以”@@”开头）和用户自定义变量。系统变量分为全局系统变量(global)和会话系统变量(session)。<br>@<a href=\"https://github.com/global\" title=\"&#64;global\" class=\"at-link\">@global</a>     仅用于访问全局系统变量的值；<br>@<a href=\"https://github.com/session\" title=\"&#64;session\" class=\"at-link\">@session</a>  仅用于访问会话系统变量的值；<br>@@              先访问会话系统变量的值，若不存在则去访问全局系统变量的值；<br>sql_mode 为系统变量，既是全局系统变量，又是会话系统变量。</p>\r\n<h4 id=\"h4--\"><a name=\"五、代码的执行顺序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>五、代码的执行顺序</h4><p>父类Ｂ静态代码块-&gt;子类Ａ静态代码块-&gt;父类Ｂ非静态代码块-&gt;父类Ｂ构造函数-&gt;子类Ａ非静态代码块-&gt;子类Ａ构造函数<br><img src=\"http://ohlrxdl4p.bkt.clouddn.com/images/QQ截图20170303165728.jpg\" alt=\"\"></p>','2017-03-03',0,28,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(513,'ifhifhajfe','hello','<h1 id=\"h1-hello\"><a name=\"hello\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>hello</h1>','2017-03-05',0,25,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(514,'2017-03-05学习笔记','java的堆，栈，静态代码区（常量区） 详解','<p><a href=\"http://blog.csdn.net/u012031380/article/details/54981472\"> java的堆，栈，静态代码区（常量区） 详解</a></p>','2017-03-05',0,24,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(515,'java归并排序','package datastruct;\r\n\r\n/**\r\n * Created by Zephery on 2017/3/3.\r\n */\r\npublic class Solution {\r\n    public static void printArray(int[] arr, int i, int j) {\r\n        System.out.print(\"[\");\r\n        for','<pre><code class=\"lang-java\">package datastruct;\r\n\r\n/**\r\n * Created by Zephery on 2017/3/3.\r\n */\r\npublic class Solution {\r\n    public static void printArray(int[] arr, int i, int j) {\r\n        System.out.print(&quot;[&quot;);\r\n        for (int k = i; k &lt; j; k++) {\r\n            System.out.print(arr[k] + &quot;,&quot;);\r\n        }\r\n        System.out.print(arr[j] + &quot;]&quot;);\r\n    }\r\n\r\n    private static void mergesort(int[] arr, int i, int j) {\r\n        int mid = 0;\r\n        if (i &lt; j) {\r\n            mid = (i + j) / 2;\r\n            mergesort(arr, i, mid);\r\n            mergesort(arr, mid + 1, j);\r\n            merge(arr, i, mid, j);\r\n        }\r\n    }\r\n\r\n    private static void merge(int[] arr, int i, int mid, int j) {\r\n        System.out.print(&quot;Left:&quot;);\r\n        printArray(arr, i, mid);\r\n        System.out.println(&quot;Right:&quot;);\r\n        printArray(arr, mid + 1, j);\r\n        System.out.println();\r\n        int temp[] = new int[arr.length];\r\n        int l = i;\r\n        int r = j;\r\n        int m = mid + 1;\r\n        int k = l;\r\n        while (l &lt;= mid &amp;&amp; m &lt;= r) {\r\n            if (arr[l] &lt;= arr[m]) {\r\n                temp[k++] = arr[l++];\r\n            } else {\r\n                temp[k++] = arr[m++];\r\n            }\r\n        }\r\n        while (l &lt;= mid) {\r\n            temp[k++] = arr[l++];\r\n        }\r\n        while (m &lt;= r) {\r\n            temp[k++] = arr[m++];\r\n        }\r\n        for (int i1 = i; i1 &lt;= j; i1++) {\r\n            arr[i1] = temp[i1];\r\n        }\r\n        System.out.print(&quot;After Merge:&quot;);\r\n        printArray(arr, i, j);\r\n        System.out.println();\r\n    }\r\n\r\n    public static void main(String args[]) {\r\n        int[] arr = {9, 4, 8, 3, 1, 2, 5};\r\n        System.out.print(&quot;Initial Array:&quot;);\r\n        printArray(arr, 0, arr.length - 1);\r\n        System.out.println();\r\n        mergesort(arr, 0, arr.length - 1);\r\n    }\r\n}\r\n</code></pre>\r\n<pre><code class=\"lang-js\">Initial Array:[9,4,8,3,1,2,5]\r\nLeft:[9]Right:\r\n[4]\r\nAfter Merge:[4,9]\r\nLeft:[8]Right:\r\n[3]\r\nAfter Merge:[3,8]\r\nLeft:[4,9]Right:\r\n[3,8]\r\nAfter Merge:[3,4,8,9]\r\nLeft:[1]Right:\r\n[2]\r\nAfter Merge:[1,2]\r\nLeft:[1,2]Right:\r\n[5]\r\nAfter Merge:[1,2,5]\r\nLeft:[3,4,8,9]Right:\r\n[1,2,5]\r\nAfter Merge:[1,2,3,4,5,8,9]\r\n</code></pre>','2017-03-06',0,25,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(516,'2017-03-10学习笔记','1.Integer和int，装箱拆箱 1、基本型和基本型封装型进行“==”运算符的比较，基本型封装型将会自动拆箱变为基本型后再进行比较，因此Integer(0)会自动拆箱为int类型再进行比较，显然返回true； 2、两个Integer类型进行“==”比较，如果其值在-128至127，那么返回true，否则返回false, 这跟Integer.valueOf()的缓冲对象有关，这里不进行赘述。 3','<h1 id=\"h1-1-integer-int-\"><a name=\"1.Integer和int，装箱拆箱\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.Integer和int，装箱拆箱</h1><p>1、基本型和基本型封装型进行“==”运算符的比较，基本型封装型将会自动拆箱变为基本型后再进行比较，因此Integer(0)会自动拆箱为int类型再进行比较，显然返回true；<br>2、两个Integer类型进行“==”比较，如果其值在-128至127，那么返回true，否则返回false, 这跟Integer.valueOf()的缓冲对象有关，这里不进行赘述。<br>3、两个基本型的封装型进行equals()比较，首先equals()会比较类型，如果类型相同，则继续比较值，如果值也相同，返回true<br>4、基本型封装类型调用equals(),但是参数是基本类型，这时候，先会进行自动装箱，基本型转换为其封装类型，再进行3中的比较。</p>\r\n<pre><code class=\"lang-java\">int a=257;\r\nInteger b=257;\r\nInteger c=257;\r\nInteger b2=57;\r\nInteger c2=57;\r\nSystem.out.println(a==b);\r\n//System.out.println(a.equals(b));  编译出错，基本型不能调用equals()\r\nSystem.out.println(b.equals(257.0));\r\nSystem.out.println(b==c);\r\nSystem.out.println(b2==c2);\r\n</code></pre>\r\n<p>因此上面的代码的结果因此为 true, false, false, true</p>\r\n<h1 id=\"h1-2-\"><a name=\"2.线程调度\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.线程调度</h1><p>分为协同式调度和抢占式调度，Java使用的是抢占式调度，也就是每个线程将由操作系统来分配执行时间，线程的切换不由线程本身来决定（协同式调度）。这就是平台独立的原因。</p>\r\n<h1 id=\"h1-3-\"><a name=\"3.重载，重写\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.重载，重写</h1><p>重写：<br>两同，两小，一大<br>两同：方法名，方法参数列表相同。<br>两小：抛出的异常类型要小于等于父类，返回值类型要小于等于父类<br>一大：访问权限大于等于父类。<br>重载：<br>在同一个类中，方法名和方法参数列表不同，其他的（访问权限、返回值）随意。</p>\r\n<h1 id=\"h1-4-jvm-\"><a name=\"4.  JVM面试题\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.<a href=\"http://blog.csdn.net/hsk256/article/details/49104955\">JVM面试题</a></h1>','2017-03-10',0,24,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(517,'2017-03-12学习笔记','1.继承的加载顺序 执行顺序大体上可以说是先父类后子类，父类static域 ==》子类static域 ==》父类数据成员域 ==》父类构造器 ==》子类数据成员域 ==》子类构造器 2.优化Hibernate所鼓励的7大措施： 1.尽量使用many-to-one，避免使用单项one-to-many 2.灵活使用单向one-to-many 3.不用一对一，使用多对一代替一对一 4.配置对象缓存，不使','<h4 id=\"h4-1-\"><a name=\"1.  继承的加载顺序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.<a href=\"http://www.cnblogs.com/SirSmith/p/5536288.html\">继承的加载顺序</a></h4><p><img src=\"http://images2015.cnblogs.com/blog/452847/201605/452847-20160527221410288-2119099273.png\" alt=\"\"></p>\r\n<p>执行顺序大体上可以说是先父类后子类，父类static域 ==》子类static域 ==》父类数据成员域 ==》父类构造器 ==》子类数据成员域 ==》子类构造器</p>\r\n<h4 id=\"h4-2-hibernate-7-\"><a name=\"2.优化Hibernate所鼓励的7大措施：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.优化Hibernate所鼓励的7大措施：</h4><p>1.尽量使用many-to-one，避免使用单项one-to-many<br>2.灵活使用单向one-to-many<br>3.不用一对一，使用多对一代替一对一<br>4.配置对象缓存，不使用集合缓存<br>5.一对多使用Bag 多对一使用Set<br>6.继承使用显示多态 HQL:from object polymorphism=”exlicit” 避免查处所有对象<br>7.消除大表，使用二级缓存</p>\r\n<h4 id=\"h4-3-java-\"><a name=\"3.java中的数据类型分类：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.java中的数据类型分类：</h4><p>基本数据类型（或叫做原生类、内置类型）8种：<br>    整数：byte，short，int，long（默认是int类型）<br>    浮点类型： float，double（默认是double类型）<br>    字符类型：char<br>    布尔类型：boolean<br>引用数据类型3种：数组，类，接口</p>\r\n<h4 id=\"h4-4-\"><a name=\"4.触发器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.触发器</h4><p>drop trigger 删除触发器<br>Drop用于删除数据表或数据库，或删除数据表字段。<br>remove：删除数据库文件<br>Truncate：删除数据表中的数据（仅数据表中的数据，不删除表）。</p>','2017-03-12',0,23,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(518,'2017-03-14学习笔记','1.Servlet的生命周期分为5个阶段：加载、创建、初始化、处理客户请求、卸载。 (1)加载：容器通过类加载器使用servlet类对应的文件加载servlet (2)创建：通过调用servlet构造函数创建一个servlet对象 (3)初始化：调用init方法初始化 (4)处理客户请求：每当有一个客户请求，容器会创建一个线程来处理客户请求 (5)卸载：调用destroy方法让servlet自己释','<h4 id=\"h4-1-servlet-5-\"><a name=\"1.Servlet的生命周期分为5个阶段：加载、创建、初始化、处理客户请求、卸载。\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.Servlet的生命周期分为5个阶段：加载、创建、初始化、处理客户请求、卸载。</h4><p>(1)加载：容器通过类加载器使用servlet类对应的文件加载servlet<br>(2)创建：通过调用servlet构造函数创建一个servlet对象<br>(3)初始化：调用init方法初始化<br>(4)处理客户请求：每当有一个客户请求，容器会创建一个线程来处理客户请求<br>(5)卸载：调用destroy方法让servlet自己释放其占用的资源</p>\r\n<h4 id=\"h4-2-jsp\"><a name=\"2.JSP\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.JSP</h4><p><img src=\"http://uploadfiles.nowcoder.com/images/20160308/595432_1457414324036_C3D4EB7F2D61708D0C0BE2921A45B74D\" alt=\"\"></p>','2017-03-14',0,20,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(519,'2017-03-17学习笔记','1.GC线程是否和守护线程 2.java堆排序','<h4 id=\"h4-1-gc-\"><a name=\"1.GC线程是否和守护线程\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.GC线程是否和守护线程</h4><h4 id=\"h4-2-java-\"><a name=\"2.java堆排序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.java堆排序</h4>','2017-03-17',0,20,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(520,'重载与重写','目前的问题：父类的功能无法满足子类的需求。 方法重写的前提： 必须要存在继承的关系。 方法的重写: 子父类出了同名的函数，这个我们就称作为方法的重写。 什么是时候要使用方法的重写：父类的功能无法满足子类的需求时。 方法重写要注意的事项： 1.方法重写时， 方法名与形参列表必须一致。 2.方法重写时，子类的权限修饰符必须要大于或者等于父类的权限修饰符。 3.方法重写时，子类的返回值类型必须要小于或者','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><p>目前的问题：父类的功能无法满足子类的需求。</p>\n<p>方法重写的前提： 必须要存在继承的关系。</p>\n<p>方法的重写: 子父类出了同名的函数，这个我们就称作为方法的重写。</p>\n<p>什么是时候要使用方法的重写：父类的功能无法满足子类的需求时。</p>\n<p>方法重写要注意的事项：<br>    1.方法重写时， 方法名与形参列表必须一致。<br>    2.方法重写时，子类的权限修饰符必须要大于或者等于父类的权限修饰符。<br>    3.方法重写时，子类的返回值类型必须要小于或者 等于父类的返回值类型。<br>    4.方法重写时， 子类抛出的异常类型要小于或者等于父类抛出的异常类型。<br>            Exception(最坏)<br>            RuntimeException(小坏)</p>\n<p>方法的重载：在一个类中 存在两个或者两个 以上的同名函数,称作为方法重载。</p>\n<p>方法重载的要求</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"lit\">1.</span><span class=\"pln\"> </span><span class=\"pun\">函数名要一致。</span></code></li><li class=\"L1\"><code><span class=\"lit\">2.</span><span class=\"pln\"> </span><span class=\"pun\">形参列表不一致（形参的个数或形参</span><span class=\"pln\"> </span><span class=\"pun\">的类型不一致）</span></code></li><li class=\"L2\"><code><span class=\"lit\">3.</span><span class=\"pln\"> </span><span class=\"pun\">与返回值类型无关。</span></code></li></ol></pre></div>','2017-03-21',0,22,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(521,'垃圾回收算法','垃圾回收算法 1、标记-清除算法 2、复制算法 3、标记-整理算法 一、标记-清除算法 标记-清除算法采用从根集合进行扫描，对存活的对象对象标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收，如上图所示。 标记-清除算法不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效，但由于标记-清除算法直接回收不存活的对象，因此会造成内存碎片！ 二、复制算法 复制算法','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h2 id=\"h2-u5783u573Eu56DEu6536u7B97u6CD5\"><a name=\"垃圾回收算法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>垃圾回收算法</h2><p>1、标记-清除算法<br>2、复制算法<br>3、标记-整理算法</p>\n<h4 id=\"h4--\"><a name=\"一、标记-清除算法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、标记-清除算法</h4><p><img src=\"http://dl2.iteye.com/upload/attachment/0075/0386/29ae17ad-f8af-38b4-9e25-28ef3550858f.jpg\" alt=\"\">标记-清除算法采用从根集合进行扫描，对存活的对象对象标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收，如上图所示。<br>标记-清除算法不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效，但由于标记-清除算法直接回收不存活的对象，因此会造成内存碎片！</p>\n<h4 id=\"h4--\"><a name=\"二、复制算法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、复制算法</h4><p><img src=\"http://dl2.iteye.com/upload/attachment/0075/0388/91a656d4-f08a-377b-8eea-5785c2932533.jpg\" alt=\"\"><br>复制算法采用从根集合扫描，并将存活对象复制到一块新的，没有使用过的空间中，这种算法当控件存活的对象比较少时，极为高效，但是带来的成本是需要一块内存交换空间用于进行对象的移动。也就是我们前面提到的s0 s1等空间。</p>\n<h4 id=\"h4--\"><a name=\"三、标记-整理算法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、标记-整理算法</h4><p><img src=\"http://dl2.iteye.com/upload/attachment/0075/0390/6ba95f80-c7bc-3d09-b927-ac09297e9920.jpg\" alt=\"\"><br> 标记-整理算法采用标记-清除算法一样的方式进行对象的标记，但在清除时不同，在回收不存活的对象占用的空间后，会将所有的存活对象往左端空闲空间移动，并更新对应的指针。标记-整理算法是在标记-清除算法的基础上，又进行了对象的移动，因此成本更高，但是却解决了内存碎片的问题。</p>\n</div>','2017-04-09',0,29,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(522,'java分代回收','一、新生代内存的回收（minor GC）主要采用复制算法，下图展示了minor GC的执行过程。 二、对于新生代和旧生代，JVM可使用很多种垃圾回收器进行垃圾回收，下图展示了不同生代不通垃圾回收器，其中两个回收器之间有连线表示这两个回收器可以同时使用。 而这些垃圾回收器又分为串行回收方式、并行回收方式合并发回收方式执行，分别运用于不同的场景。如下图所示 三、收集器 1.Serial收集器 看名字我','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h2 id=\"h2--minor-gc-minor-gc-\"><a name=\"一、新生代内存的回收（minor GC）主要采用复制算法，下图展示了minor GC的执行过程。\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、新生代内存的回收（minor GC）主要采用复制算法，下图展示了minor GC的执行过程。</h2><p><img src=\"http://dl2.iteye.com/upload/attachment/0075/0392/732c7557-aa9a-3551-b14d-f543c5b0c94b.jpg\" alt=\"\"></p>\n<h2 id=\"h2--jvm-\"><a name=\"二、对于新生代和旧生代，JVM可使用很多种垃圾回收器进行垃圾回收，下图展示了不同生代不通垃圾回收器，其中两个回收器之间有连线表示这两个回收器可以同时使用。\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、对于新生代和旧生代，JVM可使用很多种垃圾回收器进行垃圾回收，下图展示了不同生代不通垃圾回收器，其中两个回收器之间有连线表示这两个回收器可以同时使用。</h2><p><img src=\"http://dl2.iteye.com/upload/attachment/0075/0394/0172f624-9018-3642-bf26-05a2c3071639.jpg\" alt=\"\"><br>而这些垃圾回收器又分为串行回收方式、并行回收方式合并发回收方式执行，分别运用于不同的场景。如下图所示<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0396/c962c2ad-273f-3de4-b2e3-a4dd8b946215.jpg\" alt=\"\"></p>\n<h2 id=\"h2--\"><a name=\"三、收集器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、收集器</h2><h4 id=\"h4-1-serial-\"><a name=\"1.Serial收集器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.Serial收集器</h4><p>看名字我们都可以看的出来，这个属于串行收集器。其运行示意图如下<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0398/681da5ca-5eff-3984-bece-3d80dfe905be.jpg\" alt=\"\"><br>    收集器是历史最悠久的一个回收器，JDK1.3之前广泛使用这个收集器，目前也是ClientVM下 ServerVM 4核4GB以下机器的默认垃圾回收器。串行收集器并不是只能使用一个CPU进行收集，而是当JVM需要进行垃圾回收的时候，需要中断所有的用户线程，知道它回收结束为止，因此又号称“Stop The World” 的垃圾回收器。注意，JVM中文名称为java虚拟机，因此它就像一台虚拟的电脑一样在工作，而其中的每一个线程就被认为是JVM的一个处理器，因此大家看到图中的CPU0、CPU1实际为用户的线程，而不是真正机器的CPU，大家不要误解哦。<br>    串行回收方式适合低端机器，是Client模式下的默认收集器，对CPU和内存的消耗不高，适合用户交互比较少，后台任务较多的系统。<br>    Serial收集器默认新旧生代的回收器搭配为Serial+ SerialOld</p>\n<h4 id=\"h4-2-parnew-\"><a name=\"2.ParNew收集器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.ParNew收集器</h4><p>ParNew收集器其实就是多线程版本的Serial收集器，其运行示意图如下<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0400/6443b39c-ed33-3d93-a690-87e646439561.jpg\" alt=\"\"><br>同样有Stop The World的问题，他是多CPU模式下的首选回收器（该回收器在单CPU的环境下回收效率远远低于Serial收集器，所以一定要注意场景哦），也是Server模式下的默认收集器。</p>\n<h4 id=\"h4-3-parallelscavenge\"><a name=\"3.ParallelScavenge\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.ParallelScavenge</h4><p>ParallelScavenge又被称为是吞吐量优先的收集器，器运行示意图如下<br><img src=\"http://dl.iteye.com/upload/attachment/0075/0402/5007beba-0b0e-3cf4-b146-c28b6c0dd696.jpg\" alt=\"\"><br> ParallelScavenge<br>所提到的吞吐量=程序运行时间/(JVM执行回收的时间+程序运行时间),假设程序运行了100分钟，JVM的垃圾回收占用1分钟，那么吞吐量就是99%。在当今网络告诉发达的今天，良好的响应速度是提升用户体验的一个重要指标，多核并行云计算的发展要求程序尽可能的使用CPU和内存资源，尽快的计算出最终结果，因此在交互不多的云端，比较适合使用该回收器。</p>\n<h4 id=\"h4-4-parallelold\"><a name=\"4.ParallelOld\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.ParallelOld</h4><p>ParallelOld是老生代并行收集器的一种，使用标记整理算法、是老生代吞吐量优先的一个收集器。这个收集器是JDK1.6之后刚引入的一款收集器，我们看之前那个图之间的关联关系可以看到，早期没有ParallelOld之前，吞吐量优先的收集器老生代只能使用串行回收收集器，大大的拖累了吞吐量优先的性能，自从JDK1.6之后，才能真正做到较高效率的吞吐量优先。其运行示意图如下<br><img src=\"http://dl.iteye.com/upload/attachment/0075/0406/9a14da85-f943-3408-ba88-c6bb3842a792.jpg\" alt=\"\"></p>\n<h4 id=\"h4-5-serialold\"><a name=\"5.SerialOld\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.SerialOld</h4><p>SerialOld是旧生代Client模式下的默认收集器，单线程执行；在JDK1.6之前也是ParallelScvenge回收新生代模式下旧生代的默认收集器，同时也是并发收集器CMS回收失败后的备用收集器。其运行示意图如下<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0404/ce7aabd5-b0e0-3cda-9b6c-607cf6ebf689.jpg\" alt=\"\"></p>\n<h4 id=\"h4-5-cms\"><a name=\"5.CMS\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.CMS</h4><p>CMS又称响应时间优先(最短回收停顿)的回收器，使用并发模式回收垃圾，使用标记-清除算法，CMS对CPU是非常敏感的，它的回收线程数=（CPU+3）/4，因此当CPU是2核的实惠，回收线程将占用的CPU资源的50%，而当CPU核心数为4时仅占用25%。他的运行示意图如下<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0408/4239228b-879f-382f-81c6-5c32799886d6.jpg\" alt=\"\"><br>模式主要分为四个过程：<br>1.初始标记<br>2.并发标记<br>3.重新标记<br>4.并发清除<br>在初始标记的时候，需要中断所有用户线程，在并发标记阶段，用户线程和标记线程<br>并发执行，而在这个过程中，随着内存引用关系的变化，可能会发生原来标记的对象被释放，进而引发新的垃圾，因此可能会产生一系列的浮动垃圾，不能被回收。</p>\n<p>CMS 为了确保能够扫描到所有的对象，避免在Initial Marking 中还有未标识到的对象，采用的方法为找到标记了的对象，并将这些对象放入Stack 中，扫描时寻找此对象依赖的对象，如果依赖的对象的地址在其之前，则将此对象进行标记，并同时放入Stack 中，如依赖的对象地址在其之后，则仅标记该对象。<br>在进行Concurrent Marking 时minor GC 也可能会同时进行，这个时候很容易造成旧生代对象引用关系改变，CMS 为了应对这样的并发现象，提供了一个Mod Union Table 来进行记录，在这个Mod Union Table中记录每次minor GC 后修改了的Card 的信息。这也是ParallelScavenge不能和CMS一起使用的原因。<br>CMS产生浮动垃圾的情况请见如下示意图<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0410/60e7c659-790a-3405-af70-9ca4cfd9258d.jpg\" alt=\"\"><br>在运行回收过后，c就变成了浮动垃圾。<br>由于CMS会产生浮动垃圾，当回收过后，浮动垃圾如果产生过多，同时因为使用标记-清除算法会产生碎片，可能会导致回收过后的连续空间仍然不能容纳新生代移动过来或者新创建的大资源，因此会导致CMS回收失败，进而触发另外一次FULL GC，而这时候则采用SerialOld进行二次回收。<br>同时CMS因为可能产生浮动垃圾，而CMS在执行回收的同时新生代也有可能在进行回收操作，为了保证旧生代能够存放新生代转移过来的数据，CMS在旧生代内存到达全部容量的68%就触发了CMS的回收！</p>\n<h4 id=\"h4-7-garbagefirst-g1-\"><a name=\"7.GarbageFirst(G1)\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>7.GarbageFirst(G1)</h4><p>我们再来看垃圾回收器的总图，刚才我们可以看到，我在图上标记了一个？，其实这是一个新的垃圾回收器，既可以回收新生代也可以回收旧生代，SunHotSpot 1.6u14以上EarlyAccess版本加入了这个回收器，sun公司预期SunHotSpot1.7发布正式版，他是商用高性能垃圾回收器，通过重新划分内存区域，整合优化CMS，同时注重吞吐量和响应时间，但是杯具的是被Oracle收购之后这个收集器属于商用收费收集器，因此目前基本上没有人使用，我们在这里也就不多介绍，更多信息可以参考oracle新版本JDK说明。</p>\n</div>','2017-04-09',0,32,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(523,'java汇编','java 汇编 http://download.csdn.net/download/jiangfuqiang/8403497','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><p>java 汇编<br><a href=\"http://download.csdn.net/download/jiangfuqiang/8403497\">http://download.csdn.net/download/jiangfuqiang/8403497</a></p>\n</div>','2017-04-10',0,31,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(524,'jvm','-XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><p>-XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly</p>\n</div>','2017-04-10',0,27,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(525,'Java堆.栈和常量池 笔记','Java堆.栈和常量池 笔记','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><p><a href=\"http://www.iteye.com/topic/634530\">Java堆.栈和常量池 笔记</a></p>\n</div>','2017-04-23',0,24,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(526,'工厂模式','工厂模式 目录 何为工厂模式 工厂方法与抽象工厂 如何在Java EE中通过@Producers与@Inject注解实现工厂模式 如何创建自定义注解以及通过@Qualifier消除具体实现之间的歧义 工厂模式有两种模式：工厂方法和抽象方法。它们的意图是一样的：提供一个接口，在不指定具体类的情况下创建相关或依赖的一系列对象。 一.何为工厂模式 工厂的目的在于创建对象。创建的逻辑被封装在工厂中，要么提','<h1 id=\"h1-u5DE5u5382u6A21u5F0F\"><a name=\"工厂模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>工厂模式</h1><p>目录</p>\r\n<ul>\r\n<li>何为工厂模式</li><li>工厂方法与抽象工厂</li><li>如何在Java EE中通过<a href=\"https://github.com/Producers\" title=\"&#64;Producers\" class=\"at-link\">@Producers</a>与<a href=\"https://github.com/Inject\" title=\"&#64;Inject\" class=\"at-link\">@Inject</a>注解实现工厂模式</li><li>如何创建自定义注解以及通过<a href=\"https://github.com/Qualifier\" title=\"&#64;Qualifier\" class=\"at-link\">@Qualifier</a>消除具体实现之间的歧义<br>工厂模式有两种模式：工厂方法和抽象方法。它们的意图是一样的：提供一个接口，在不指定具体类的情况下创建相关或依赖的一系列对象。</li></ul>\r\n<h3 id=\"h3--\"><a name=\"一.何为工厂模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一.何为工厂模式</h3><p>工厂的目的在于创建对象。创建的逻辑被封装在工厂中，要么提供一个方法来返回新创建的对象（工厂方法模式），要么将对象的创建委托给子类（抽象工厂模式）。<br>客户端不必考虑接口或类的不同实现，它只需通过工厂（工厂）获取接口实现的一个实例的即可，这样客户端与对象的创建就实现了解耦<br>解耦是应用依赖反转原则的结果，这带来了很多好处，其中最重要的好处就是实现了高层类与底层类之间的解耦。通过解耦，具体类实现的变化不会影响到客户端，这降低了类与类之间的耦合，并提升了灵活性。</p>\r\n<h3 id=\"h3--\"><a name=\"二.工厂方法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二.工厂方法</h3><p>GoF一书是这样描述工程方法模式的：“定义一个用于创建对象的接口，不过让子类决定实例化那个类”<br>工厂极大降低了new关键字的使用次数，并且将初始化过程与不同的具体实现封装起来。将这些需求中心化可以极大减少向系统中添加或删除具体类的影响以及具体的类依赖的影响。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src=\"http://ohlrxdl4p.bkt.clouddn.com/images/QQ截图20170506134421.jpg\" alt=\"\"><br><strong>1.使用普通代码实现工厂方法</strong><br>被具体实现继承的DrinksMachine抽象类</p>\r\n<pre><code class=\"lang-java\">public abstract class DrinksMachine {\r\n    public abstract Drink dispenseDrink();\r\n    public String displayMessage(){\r\n        return &quot;Thank for your custom.&quot;;\r\n    }\r\n}\r\n</code></pre>\r\n<p>DrinksMachine抽象类的CoffeeMachine实现</p>\r\n<pre><code class=\"lang-java\">public class CoffeeMachine extends DrinksMachine {\r\n    public Drink dispenseDrink() {\r\n        return new Coffee();\r\n    }\r\n}\r\n</code></pre>\r\n<p>DrinksMachine抽象类的SoftDrinksMachine实现</p>\r\n<pre><code class=\"lang-java\">public class SoftDrinksMachine extends DrinksMachine {\r\n    public Drink dispenseDrink() {\r\n        return new SoftDrink();\r\n    }\r\n}\r\n</code></pre>\r\n<p>Drink接口</p>\r\n<pre><code class=\"lang-java\">public interface Drink {}\r\n</code></pre>\r\n<p>Drink接口的SoftDrink实现</p>\r\n<pre><code class=\"lang-java\">public class SoftDrink implements Drink {\r\n    SoftDrink() {\r\n        System.out.println(&quot;Soft drink&quot;);\r\n    }\r\n}\r\n</code></pre>\r\n<p>Drink接口的Coffee实现</p>\r\n<pre><code class=\"lang-java\">public class Coffee implements Drink {\r\n    Coffee() {\r\n        System.out.println(&quot;Coffee&quot;);\r\n    }\r\n}\r\n</code></pre>\r\n<p>CoffeeType枚举<br>```java<br>public enum CoffeeType {EXPRESSO, LATTE}</p>\r\n<p>public Drink dispenseDrink(CoffeeType type) {<br>    Drink coffee = null;<br>    switch (type) {<br>        case EXPRESSO: coffee = new Expresso();<br>        case LATTE: coffee = new Latte();<br>    }<br>    return coffee;<br>}<br>```&lt;!--前面不能有空格--&gt;</p>','2017-05-06',0,44,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(527,'代理模式','代理模式(Proxy Pattern) GoF中给出的代理模式的定义为： 代理模式给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。 代理模式的英文叫做Proxy或Surrogate，它是一种对象结构型模式。 代理模式根据其目的和实现可分为很多种类，常用的代理模式包括如下几种： （1）远程代理（Remote Proxy）————为一个位于不同的地址空间的对象提供一个本地的代理对象','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h1 id=\"h1--proxy-pattern-\"><a name=\"代理模式(Proxy Pattern)\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代理模式(Proxy Pattern)</h1><p>GoF中给出的代理模式的定义为：<br>代理模式给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。<br>代理模式的英文叫做Proxy或Surrogate，它是一种对象结构型模式。<br>代理模式根据其目的和实现可分为很多种类，常用的代理模式包括如下几种：<br>（1）远程代理（Remote Proxy）————为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以是在同一台主机中，也可以是在另一台主机中，远程代理又称为大使（Ambassador）<br>（2）虚拟代理（Virtual Proxy）————如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。<br>（3）保护代理（Protect Proxy）————控制一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。<br>（4）缓冲代理（Cache Proxy）————为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。<br>（5）只能引用代理（Smart Reference Proxy）————当一个对象被引用时，提供一些额外的操作，例如将对象被调用的次数记录下来。<br><img src=\"http://ohlrxdl4p.bkt.clouddn.com/images/QQ截图20170507103646.jpg\" alt=\"\"></p>\n<p>代码实现：<br>1.抽象主题类——BuyTicket.java</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code class=\"lang-java\"><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">interface</span><span class=\"pln\"> </span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> showticket</span><span class=\"pun\">();</span></code></li><li class=\"L2\"><code class=\"lang-java\"><span class=\"pun\">}</span></code></li></ol></pre>\n<p>2.具体主题类——Train.java</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code class=\"lang-java\"><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Train</span><span class=\"pln\"> </span><span class=\"kwd\">implements</span><span class=\"pln\"> </span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"lit\">@Override</span></code></li><li class=\"L2\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> showticket</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L3\"><code class=\"lang-java\"><span class=\"pln\">        </span><span class=\"typ\">System</span><span class=\"pun\">.</span><span class=\"pln\">out</span><span class=\"pun\">.</span><span class=\"pln\">println</span><span class=\"pun\">(</span><span class=\"str\">\"one ticket\"</span><span class=\"pun\">);</span></code></li><li class=\"L4\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L5\"><code class=\"lang-java\"><span class=\"pun\">}</span></code></li></ol></pre>\n<p>3.代理角色类——TicketCenter.java</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code class=\"lang-java\"><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">TicketCenter</span><span class=\"pln\"> </span><span class=\"kwd\">implements</span><span class=\"pln\"> </span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> ticket</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code class=\"lang-java\"></code></li><li class=\"L3\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"typ\">TicketCenter</span><span class=\"pun\">(</span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> ticket</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code class=\"lang-java\"><span class=\"pln\">        </span><span class=\"kwd\">this</span><span class=\"pun\">.</span><span class=\"pln\">ticket </span><span class=\"pun\">=</span><span class=\"pln\"> ticket</span><span class=\"pun\">;</span></code></li><li class=\"L5\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code class=\"lang-java\"></code></li><li class=\"L7\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"lit\">@Override</span></code></li><li class=\"L8\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> showticket</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L9\"><code class=\"lang-java\"><span class=\"pln\">        ticket</span><span class=\"pun\">.</span><span class=\"pln\">showticket</span><span class=\"pun\">();</span></code></li><li class=\"L0\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code class=\"lang-java\"></code></li><li class=\"L2\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> buy</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L3\"><code class=\"lang-java\"><span class=\"pln\">        </span><span class=\"typ\">System</span><span class=\"pun\">.</span><span class=\"pln\">out</span><span class=\"pun\">.</span><span class=\"pln\">println</span><span class=\"pun\">(</span><span class=\"str\">\"by proxy\"</span><span class=\"pun\">);</span></code></li><li class=\"L4\"><code class=\"lang-java\"><span class=\"pln\">        showticket</span><span class=\"pun\">();</span></code></li><li class=\"L5\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code class=\"lang-java\"><span class=\"pun\">}</span></code></li></ol></pre>\n<p>4.客户端测试类</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code class=\"lang-java\"><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">ProxyPattern</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> main</span><span class=\"pun\">(</span><span class=\"typ\">String</span><span class=\"pln\"> args</span><span class=\"pun\">[])</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L2\"><code class=\"lang-java\"><span class=\"pln\">        </span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> x </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Train</span><span class=\"pun\">();</span></code></li><li class=\"L3\"><code class=\"lang-java\"><span class=\"pln\">        </span><span class=\"typ\">TicketCenter</span><span class=\"pln\"> y </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">TicketCenter</span><span class=\"pun\">(</span><span class=\"pln\">x</span><span class=\"pun\">);</span></code></li><li class=\"L4\"><code class=\"lang-java\"><span class=\"pln\">        y</span><span class=\"pun\">.</span><span class=\"pln\">buy</span><span class=\"pun\">();</span></code></li><li class=\"L5\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code class=\"lang-java\"><span class=\"pun\">}</span></code></li></ol></pre>\n<p>运行结果：</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code class=\"lang-html\"><span class=\"pln\">by proxy</span></code></li><li class=\"L1\"><code class=\"lang-html\"><span class=\"pln\">one ticket</span></code></li></ol></pre>\n</div>','2017-05-07',0,52,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(528,'2017-02-28学习笔记','','<p><img src=\"http://ohlrxdl4p.bkt.clouddn.com/images/826546_1482322555369_C5DABB18734059E89A45A0E9170722B0.png\" alt=\"\"></p>','2017-02-28',0,42,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(529,'2017-03-01学习笔记','知识点 1.java中只有值传递，没有引用传递http://guhanjie.iteye.com/blog/1683637 2.final关键字 final修饰变量，则等同于常量. final修饰方法中的参数，称为最终参数. final修饰类，则类不能被继承. final修饰方法，则方法不能被','<h1 id=\"h1-u77E5u8BC6u70B9\"><a name=\"知识点\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>知识点</h1><h4 id=\"h4-1-java-http-guhanjie-iteye-com-blog-1683637\"><a name=\"1.java中只有值传递，没有引用传递  http://guhanjie.iteye.com/blog/1683637\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.java中只有值传递，没有引用传递<a href=\"http://guhanjie.iteye.com/blog/1683637\">http://guhanjie.iteye.com/blog/1683637</a></h4><h4 id=\"h4-2-final-\"><a name=\"2.final关键字\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.final关键字</h4><ul>\r\n<li>final修饰变量，则等同于常量.</li><li>final修饰方法中的参数，称为最终参数.</li><li>final修饰类，则类不能被继承.</li><li>final修饰方法，则方法不能被重写.</li></ul>\r\n<h4 id=\"h4-3-integer-img-src-https-uploadfiles-nowcoder-com-images-20160717-6316247_1468761643205_9f7b85ab04292cf73778d98998a20ed1-alt-\"><a name=\"3.Integer<img src=\"https://uploadfiles.nowcoder.com/images/20160717/6316247_1468761643205_9F7B85AB04292CF73778D98998A20ED1\" alt=\"图片\">\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.Integer<img src=\"https://uploadfiles.nowcoder.com/images/20160717/6316247_1468761643205_9F7B85AB04292CF73778D98998A20ED1\" alt=\"图片\"></h4><h4 id=\"h4-4-java-\"><a name=\"4.java内存模型   点击原文\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.java内存模型 <a href=\"http://blog.csdn.net/ns_code/article/details/17565503\">点击原文</a></h4><p><img src=\"https://uploadfiles.nowcoder.com/images/20161223/415611_1482452184396_6FB53C51539B47559CF0D122A832CF63\" alt=\"\"></p>\r\n<h4 id=\"h4-5-java-reference\"><a name=\"5.java中是没有指针的，有reference\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.java中是没有指针的，有reference</h4><p>第一：指针变量是在栈内存中，它也是有值的，这个值存储的就是地址单元，这个地址就是来自于赋值操作。<br>第二：指针变量有类型，这个类型（如Person）的含义是指针指向的变量在栈内存（不是很确定）中的范围（大小），我理解为是占用的堆内存空间。<br>第三：声明一个对象时，是对“指针变量”的定义。<br>第四：用new关键字在堆内存创建了对象，在赋值时，是把这个对象的首地址传给了这个“指针变量”（即引用型变量）。</p>\r\n<h4 id=\"h4-6-string-\"><a name=\"6.String生成常量\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6.String生成常量</h4><pre><code class=\"lang-java\">String s1=&quot;abc&quot;+&quot;def&quot;;//生成的是一个常量，放在堆内存中\r\nString s2=new String（s1);//s2是一个变量\r\nif(s1.equals(s2))//比较的是字符串的内容\r\n    System.out.println(&quot;.equals succeeded&quot;);//输出\r\nif(s1==s2)//比较的是内存地址，但s1是常量，所以不相等\r\n    System.out.println(&quot;==succeeded&quot;);\r\n</code></pre>\r\n<h4 id=\"h4-7-jsp-\"><a name=\"7.jsp内置对象和属性\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>7.jsp内置对象和属性</h4><p>（１）request对象<br>客户端的请求信息被封装在request对象中，通过它才能了解到客户的需求，然后做出响应。它是HttpServletRequest类的实例。<br>（２）response对象<br>response对象包含了响应客户请求的有关信息，但在JSP中很少直接用到它。它是HttpServletResponse类的实例。<br>（３）session对象<br>session对象指的是客户端与服务器的一次会话，从客户连到服务器的一个WebApplication开始，直到客户端与服务器断开连接为止。它是HttpSession类的实例.<br>（４）out对象<br>out对象是JspWriter类的实例,是向客户端输出内容常用的对象<br>（５）page对象<br>page对象就是指向当前JSP页面本身，有点象类中的this指针，它是java.lang.Object类的实例<br>（６）application对象<br>application对象实现了用户间数据的共享，可存放全局变量。它开始于服务器的启动，直到服务器的关闭，在此期间，此对象将一直存在；这样在用户的前后连接或不同用户之间的连接中，可以对此对象的同一属性进行操作；在任何地方对此对象属性的操作，都将影响到其他用户对此的访问。服务器的启动和关闭决定了application对象的生命。它是ServletContext类的实例。<br>（７）exception对象<br>exception对象是一个例外对象，当一个页面在运行过程中发生了例外，就产生这个对象。如果一个JSP页面要应用此对象，就必须把isErrorPage设为true，否则无法编译。他实际上是java.lang.Throwable的对象<br>（８）pageContext对象<br>pageContext对象提供了对JSP页面内所有的对象及名字空间的访问，也就是说他可以访问到本页所在的SESSION，也可以取本页面所在的application的某一属性值，他相当于页面中所有功能的集大成者，它的本 类名也叫pageContext。<br>（９）config对象<br>config对象是在一个Servlet初始化时，JSP引擎向它传递信息用的，此信息包括Servlet初始化时所要用到的参数（通过属性名和属性值构成）以及服务器的有关信息（通过传递一个ServletContext对象）</p>','2017-03-01',0,22,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(530,'2017-03-02学习笔记','知识点 一、static public class Spike\r\n{\r\n    public static void main(String[] args)\r\n    {\r\n        Counter a = new Counter();\r\n        System.out.println(a.increment());\r\n        System.out.println(a.anot','<h1 id=\"h1-u77E5u8BC6u70B9\"><a name=\"知识点\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>知识点</h1><h4 id=\"h4--static\"><a name=\"一、static\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、static</h4><pre><code class=\"lang-java\">public class Spike\r\n{\r\n    public static void main(String[] args)\r\n    {\r\n        Counter a = new Counter();\r\n        System.out.println(a.increment());\r\n        System.out.println(a.anotherIncrement());\r\n        Counter b = new Counter();\r\n        System.out.println(b.increment());\r\n    }\r\n}\r\nclass Counter\r\n{\r\n    private static int count = 0;\r\n    public int increment()\r\n    {\r\n        return count++;\r\n    }\r\n    public int anotherIncrement()\r\n    {\r\n        return ++count;\r\n    }\r\n}\r\n</code></pre>\r\n<p>count是静态变量，为所有对象所共享，因此不管a.increment()还是b.increment()都会使count持续增加。<br>increment()方法返回当前count值，然后count增加1<br>antoherIncrement()方法让count增加1，然后返回count值<br>第一次a.increment()返回值为0，此时count值为1<br>第二次a.anotherIncrement()先让count+1再返回，返回值为2<br>第三次b.increment()先返回count当前值2，然后count+1</p>\r\n<h4 id=\"h4--aop-\"><a name=\"二、AOP面向切面\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、AOP面向切面</h4><p>AOP的概念是Aspected Oriented Programming 面向方面编程。<br>  好处：AOP将程序分解成各个方面或者说关注点。这使得可以模块化，相当横向上分切了。它可以解决OOP和过程化方法不能够很好解决的横切（crosscut）问题，如：事务、安全、日志等横切关注。<br>  实现AOP有几种方式:<br>  1.Spring 1.2版本中通过ProxyFactoryBean来实现aop,即通过动态代理来实现的,Aspect必须继承MethodBeforeAdvice,MethodAfterAdvice等<br>  2.Spring 2.0 AOP需要改的是FBI 这个类，而且它也不需要再实现某些接口<br>  3.三使用标注（<a href=\"https://github.com/AspectJ\" title=\"&#64;AspectJ\" class=\"at-link\">@AspectJ</a>）实现AOP<br>    AOP 和 OOP的区别：</p>\r\n<pre><code>```html\r\n 1. 面向方面编程 AOP 偏重业务处理过程的某个步骤或阶段，强调降低模块之间的耦合度，使代码拥有更好的移植性。  \r\n 2. 面向对象编程 (oop) 则是对业务分析中抽取的实体进行方法和属性的封装。\r\n ```\r\n</code></pre><p>也可以说 AOP 是面向业务中的动词领域， OOP 面向名词领域。<br>AOP 的一个很重要的特点是源代码无关性，也就是说如果我们的系统中引用了 AOP 组件，即使我们把该组件去掉，系统代码也应该能够编译通过。要实现这一点，可以使用动态 proxy 模式。</p>\r\n<h4 id=\"h4--jdbc-\"><a name=\"三、jdbc桥接模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、jdbc桥接模式</h4><p>桥接模式：<br>定义 ：将抽象部分与它的实现部分分离，使它们都可以独立地变化。<br>意图 ：将抽象与实现解耦。<br>桥接模式所涉及的角色</p>\r\n<ol>\r\n<li>Abstraction ：定义抽象接口，拥有一个Implementor类型的对象引用</li><li>RefinedAbstraction ：扩展Abstraction中的接口定义</li><li>Implementor ：是具体实现的接口，Implementor和RefinedAbstraction接口并不一定完全一致，实际上这两个接口可以完全不一样Implementor提供具体操作方法，而Abstraction提供更高层次的调用</li><li>ConcreteImplementor ：实现Implementor接口，给出具体实现<br>Jdk中的桥接模式：JDBC<br>JDBC连接 数据库 的时候，在各个数据库之间进行切换，基本不需要动太多的代码，甚至丝毫不动，原因就是JDBC提供了统一接口，每个数据库提供各自的实现，用一个叫做数据库驱动的程序来桥接就行了<h4 id=\"h4--\"><a name=\"四、抽象类\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>四、抽象类</h4>抽象类和普通类有三点区别：<br>1）抽象方法必须为public和protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public。<br>2）抽象类不能用来创建对象，但是它可以有构造方法，用来帮助子类实例化。<br>3）如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为abstract类。<h4 id=\"h4--\"><a name=\"五、接口\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>五、接口</h4>接口的主要特点<br>1）接口中的成员变量默认都是public、static、final类型的，必须被显示初始化。<br>2）接口中的方法默认都是public、abstract类型的。<br>3）接口中只能包含public、static、final类型的成员变量和public、abstract类型的成员方法。<br>4）接口没有构造方法，不能被实例化。<br>5）一个接口不能实现另一个接口，但它可以继承多个其他接口。<br>6）接口必须通过类来实现它的抽象方法。<br>7）与子类继承抽象父类相似，当类实现了某个接口时，它必须实现接口中所有的抽象方法，否则这个类必须被定义为抽象类。<br>8）一个类只能继承一个直接的父类，但能实现多个接口。<h4 id=\"h4--\"><a name=\"六、抽象类和接口的区别\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>六、抽象类和接口的区别</h4>1）抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract方法；<br>2）抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；<br>3）接口中不能含有静态代码块以及静态方法，而抽象类尅有静态代码块和静态方法；<br>4）一个类只能继承一个抽象类，而一个类却可以实现多个接口。<br>5）抽象类中的方法子类必须全部实现，不然子类也是抽象类，而接口中的抽象方法子类必须全部实现，是可选择实现的。<br>6）抽象类是一种模板设计模式，而接口时一种行为规范。</li></ol>','2017-03-02',0,21,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(531,'2017-03-03学习笔记','一、String StringBuffer.toString()源码： @Override\r\npublic synchronized String toString() {\r\n    if (toStringCache == null) {\r\n        toStringCache = Arrays.copyOfRange(value, 0, count);\r\n    }\r\n    retur','<h4 id=\"h4--string\"><a name=\"一、String\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、String</h4><p>StringBuffer.toString()源码：</p>\r\n<pre><code class=\"lang-java\">@Override\r\npublic synchronized String toString() {\r\n    if (toStringCache == null) {\r\n        toStringCache = Arrays.copyOfRange(value, 0, count);\r\n    }\r\n    return new String(toStringCache, true);\r\n}\r\n</code></pre>\r\n<p>Arrays.copyOfRange用的是System.arraycopy</p>\r\n<pre><code class=\"lang-java\">public static char[] copyOfRange(char[] original, int from, int to) {\r\n        int newLength = to - from;\r\n        if (newLength &lt; 0)\r\n            throw new IllegalArgumentException(from + &quot; &gt; &quot; + to);\r\n        char[] copy = new char[newLength];\r\n        System.arraycopy(original, from, copy, 0,\r\n                         Math.min(original.length - from, newLength));\r\n        return copy;\r\n    }\r\n</code></pre>\r\n<p>1.String是值传入，不是引用传入。<br>2.String对String  类型进行改变的时候其实都等同于生成了一个新的  String  对象，然后将指针指向新的  String  对象，而不是StringBuffer；StringBuffer每次结果都会对  StringBuffer  对象本身进行操作，而不是生成新的对象，再改变对象引用。<br>3.效率比较String&lt;StringBuffer&lt;StringBuilder，但是在 String S1 = “This is only a” + “ simple” + “ test”时，String效率最高。</p>\r\n<h4 id=\"h4--jvm-\"><a name=\"二、jvm知识图谱\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、jvm知识图谱</h4><p><a href=\"https://zhuanlan.zhihu.com/p/25511795\">引用自知乎</a><br><img src=\"https://pic2.zhimg.com/v2-701563ac1fe745fc8e1234c96e82ac99_r.jpg\" alt=\"\"></p>\r\n<h4 id=\"h4--treemap-linkhashmap\"><a name=\"三、Treemap、LinkHashMap\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、Treemap、LinkHashMap</h4><p>1.TreeMap取出来的是排序后的键值对。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。<br>2.LinkedHashMap 是HashMap的一个子类，如果需要输出的顺序和输入的相同,那么用LinkedHashMap可以实现,它还可以按读取顺序来排列。</p>\r\n<h4 id=\"h4--sql-\"><a name=\"四、sql模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>四、sql模式</h4><p>MySQL数据库中，变量分为 系统变量（以”@@”开头）和用户自定义变量。系统变量分为全局系统变量(global)和会话系统变量(session)。<br>@<a href=\"https://github.com/global\" title=\"&#64;global\" class=\"at-link\">@global</a>     仅用于访问全局系统变量的值；<br>@<a href=\"https://github.com/session\" title=\"&#64;session\" class=\"at-link\">@session</a>  仅用于访问会话系统变量的值；<br>@@              先访问会话系统变量的值，若不存在则去访问全局系统变量的值；<br>sql_mode 为系统变量，既是全局系统变量，又是会话系统变量。</p>\r\n<h4 id=\"h4--\"><a name=\"五、代码的执行顺序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>五、代码的执行顺序</h4><p>父类Ｂ静态代码块-&gt;子类Ａ静态代码块-&gt;父类Ｂ非静态代码块-&gt;父类Ｂ构造函数-&gt;子类Ａ非静态代码块-&gt;子类Ａ构造函数<br><img src=\"http://ohlrxdl4p.bkt.clouddn.com/images/QQ截图20170303165728.jpg\" alt=\"\"></p>','2017-03-03',0,25,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(532,'ifhifhajfe','hello','<h1 id=\"h1-hello\"><a name=\"hello\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>hello</h1>','2017-03-05',0,24,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(533,'2017-03-05学习笔记','java的堆，栈，静态代码区（常量区） 详解','<p><a href=\"http://blog.csdn.net/u012031380/article/details/54981472\"> java的堆，栈，静态代码区（常量区） 详解</a></p>','2017-03-05',0,24,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(534,'java归并排序','package datastruct;\r\n\r\n/**\r\n * Created by Zephery on 2017/3/3.\r\n */\r\npublic class Solution {\r\n    public static void printArray(int[] arr, int i, int j) {\r\n        System.out.print(\"[\");\r\n        for','<pre><code class=\"lang-java\">package datastruct;\r\n\r\n/**\r\n * Created by Zephery on 2017/3/3.\r\n */\r\npublic class Solution {\r\n    public static void printArray(int[] arr, int i, int j) {\r\n        System.out.print(&quot;[&quot;);\r\n        for (int k = i; k &lt; j; k++) {\r\n            System.out.print(arr[k] + &quot;,&quot;);\r\n        }\r\n        System.out.print(arr[j] + &quot;]&quot;);\r\n    }\r\n\r\n    private static void mergesort(int[] arr, int i, int j) {\r\n        int mid = 0;\r\n        if (i &lt; j) {\r\n            mid = (i + j) / 2;\r\n            mergesort(arr, i, mid);\r\n            mergesort(arr, mid + 1, j);\r\n            merge(arr, i, mid, j);\r\n        }\r\n    }\r\n\r\n    private static void merge(int[] arr, int i, int mid, int j) {\r\n        System.out.print(&quot;Left:&quot;);\r\n        printArray(arr, i, mid);\r\n        System.out.println(&quot;Right:&quot;);\r\n        printArray(arr, mid + 1, j);\r\n        System.out.println();\r\n        int temp[] = new int[arr.length];\r\n        int l = i;\r\n        int r = j;\r\n        int m = mid + 1;\r\n        int k = l;\r\n        while (l &lt;= mid &amp;&amp; m &lt;= r) {\r\n            if (arr[l] &lt;= arr[m]) {\r\n                temp[k++] = arr[l++];\r\n            } else {\r\n                temp[k++] = arr[m++];\r\n            }\r\n        }\r\n        while (l &lt;= mid) {\r\n            temp[k++] = arr[l++];\r\n        }\r\n        while (m &lt;= r) {\r\n            temp[k++] = arr[m++];\r\n        }\r\n        for (int i1 = i; i1 &lt;= j; i1++) {\r\n            arr[i1] = temp[i1];\r\n        }\r\n        System.out.print(&quot;After Merge:&quot;);\r\n        printArray(arr, i, j);\r\n        System.out.println();\r\n    }\r\n\r\n    public static void main(String args[]) {\r\n        int[] arr = {9, 4, 8, 3, 1, 2, 5};\r\n        System.out.print(&quot;Initial Array:&quot;);\r\n        printArray(arr, 0, arr.length - 1);\r\n        System.out.println();\r\n        mergesort(arr, 0, arr.length - 1);\r\n    }\r\n}\r\n</code></pre>\r\n<pre><code class=\"lang-js\">Initial Array:[9,4,8,3,1,2,5]\r\nLeft:[9]Right:\r\n[4]\r\nAfter Merge:[4,9]\r\nLeft:[8]Right:\r\n[3]\r\nAfter Merge:[3,8]\r\nLeft:[4,9]Right:\r\n[3,8]\r\nAfter Merge:[3,4,8,9]\r\nLeft:[1]Right:\r\n[2]\r\nAfter Merge:[1,2]\r\nLeft:[1,2]Right:\r\n[5]\r\nAfter Merge:[1,2,5]\r\nLeft:[3,4,8,9]Right:\r\n[1,2,5]\r\nAfter Merge:[1,2,3,4,5,8,9]\r\n</code></pre>','2017-03-06',0,25,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(535,'2017-03-10学习笔记','1.Integer和int，装箱拆箱 1、基本型和基本型封装型进行“==”运算符的比较，基本型封装型将会自动拆箱变为基本型后再进行比较，因此Integer(0)会自动拆箱为int类型再进行比较，显然返回true； 2、两个Integer类型进行“==”比较，如果其值在-128至127，那么返回true，否则返回false, 这跟Integer.valueOf()的缓冲对象有关，这里不进行赘述。 3','<h1 id=\"h1-1-integer-int-\"><a name=\"1.Integer和int，装箱拆箱\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.Integer和int，装箱拆箱</h1><p>1、基本型和基本型封装型进行“==”运算符的比较，基本型封装型将会自动拆箱变为基本型后再进行比较，因此Integer(0)会自动拆箱为int类型再进行比较，显然返回true；<br>2、两个Integer类型进行“==”比较，如果其值在-128至127，那么返回true，否则返回false, 这跟Integer.valueOf()的缓冲对象有关，这里不进行赘述。<br>3、两个基本型的封装型进行equals()比较，首先equals()会比较类型，如果类型相同，则继续比较值，如果值也相同，返回true<br>4、基本型封装类型调用equals(),但是参数是基本类型，这时候，先会进行自动装箱，基本型转换为其封装类型，再进行3中的比较。</p>\r\n<pre><code class=\"lang-java\">int a=257;\r\nInteger b=257;\r\nInteger c=257;\r\nInteger b2=57;\r\nInteger c2=57;\r\nSystem.out.println(a==b);\r\n//System.out.println(a.equals(b));  编译出错，基本型不能调用equals()\r\nSystem.out.println(b.equals(257.0));\r\nSystem.out.println(b==c);\r\nSystem.out.println(b2==c2);\r\n</code></pre>\r\n<p>因此上面的代码的结果因此为 true, false, false, true</p>\r\n<h1 id=\"h1-2-\"><a name=\"2.线程调度\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.线程调度</h1><p>分为协同式调度和抢占式调度，Java使用的是抢占式调度，也就是每个线程将由操作系统来分配执行时间，线程的切换不由线程本身来决定（协同式调度）。这就是平台独立的原因。</p>\r\n<h1 id=\"h1-3-\"><a name=\"3.重载，重写\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.重载，重写</h1><p>重写：<br>两同，两小，一大<br>两同：方法名，方法参数列表相同。<br>两小：抛出的异常类型要小于等于父类，返回值类型要小于等于父类<br>一大：访问权限大于等于父类。<br>重载：<br>在同一个类中，方法名和方法参数列表不同，其他的（访问权限、返回值）随意。</p>\r\n<h1 id=\"h1-4-jvm-\"><a name=\"4.  JVM面试题\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.<a href=\"http://blog.csdn.net/hsk256/article/details/49104955\">JVM面试题</a></h1>','2017-03-10',0,24,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(536,'2017-03-12学习笔记','1.继承的加载顺序 执行顺序大体上可以说是先父类后子类，父类static域 ==》子类static域 ==》父类数据成员域 ==》父类构造器 ==》子类数据成员域 ==》子类构造器 2.优化Hibernate所鼓励的7大措施： 1.尽量使用many-to-one，避免使用单项one-to-many 2.灵活使用单向one-to-many 3.不用一对一，使用多对一代替一对一 4.配置对象缓存，不使','<h4 id=\"h4-1-\"><a name=\"1.  继承的加载顺序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.<a href=\"http://www.cnblogs.com/SirSmith/p/5536288.html\">继承的加载顺序</a></h4><p><img src=\"http://images2015.cnblogs.com/blog/452847/201605/452847-20160527221410288-2119099273.png\" alt=\"\"></p>\r\n<p>执行顺序大体上可以说是先父类后子类，父类static域 ==》子类static域 ==》父类数据成员域 ==》父类构造器 ==》子类数据成员域 ==》子类构造器</p>\r\n<h4 id=\"h4-2-hibernate-7-\"><a name=\"2.优化Hibernate所鼓励的7大措施：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.优化Hibernate所鼓励的7大措施：</h4><p>1.尽量使用many-to-one，避免使用单项one-to-many<br>2.灵活使用单向one-to-many<br>3.不用一对一，使用多对一代替一对一<br>4.配置对象缓存，不使用集合缓存<br>5.一对多使用Bag 多对一使用Set<br>6.继承使用显示多态 HQL:from object polymorphism=”exlicit” 避免查处所有对象<br>7.消除大表，使用二级缓存</p>\r\n<h4 id=\"h4-3-java-\"><a name=\"3.java中的数据类型分类：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.java中的数据类型分类：</h4><p>基本数据类型（或叫做原生类、内置类型）8种：<br>    整数：byte，short，int，long（默认是int类型）<br>    浮点类型： float，double（默认是double类型）<br>    字符类型：char<br>    布尔类型：boolean<br>引用数据类型3种：数组，类，接口</p>\r\n<h4 id=\"h4-4-\"><a name=\"4.触发器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.触发器</h4><p>drop trigger 删除触发器<br>Drop用于删除数据表或数据库，或删除数据表字段。<br>remove：删除数据库文件<br>Truncate：删除数据表中的数据（仅数据表中的数据，不删除表）。</p>','2017-03-12',0,23,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(537,'2017-03-14学习笔记','1.Servlet的生命周期分为5个阶段：加载、创建、初始化、处理客户请求、卸载。 (1)加载：容器通过类加载器使用servlet类对应的文件加载servlet (2)创建：通过调用servlet构造函数创建一个servlet对象 (3)初始化：调用init方法初始化 (4)处理客户请求：每当有一个客户请求，容器会创建一个线程来处理客户请求 (5)卸载：调用destroy方法让servlet自己释','<h4 id=\"h4-1-servlet-5-\"><a name=\"1.Servlet的生命周期分为5个阶段：加载、创建、初始化、处理客户请求、卸载。\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.Servlet的生命周期分为5个阶段：加载、创建、初始化、处理客户请求、卸载。</h4><p>(1)加载：容器通过类加载器使用servlet类对应的文件加载servlet<br>(2)创建：通过调用servlet构造函数创建一个servlet对象<br>(3)初始化：调用init方法初始化<br>(4)处理客户请求：每当有一个客户请求，容器会创建一个线程来处理客户请求<br>(5)卸载：调用destroy方法让servlet自己释放其占用的资源</p>\r\n<h4 id=\"h4-2-jsp\"><a name=\"2.JSP\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.JSP</h4><p><img src=\"http://uploadfiles.nowcoder.com/images/20160308/595432_1457414324036_C3D4EB7F2D61708D0C0BE2921A45B74D\" alt=\"\"></p>','2017-03-14',0,20,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(538,'2017-03-17学习笔记','1.GC线程是否和守护线程 2.java堆排序','<h4 id=\"h4-1-gc-\"><a name=\"1.GC线程是否和守护线程\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.GC线程是否和守护线程</h4><h4 id=\"h4-2-java-\"><a name=\"2.java堆排序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.java堆排序</h4>','2017-03-17',0,19,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(539,'重载与重写','目前的问题：父类的功能无法满足子类的需求。 方法重写的前提： 必须要存在继承的关系。 方法的重写: 子父类出了同名的函数，这个我们就称作为方法的重写。 什么是时候要使用方法的重写：父类的功能无法满足子类的需求时。 方法重写要注意的事项： 1.方法重写时， 方法名与形参列表必须一致。 2.方法重写时，子类的权限修饰符必须要大于或者等于父类的权限修饰符。 3.方法重写时，子类的返回值类型必须要小于或者','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><p>目前的问题：父类的功能无法满足子类的需求。</p>\n<p>方法重写的前提： 必须要存在继承的关系。</p>\n<p>方法的重写: 子父类出了同名的函数，这个我们就称作为方法的重写。</p>\n<p>什么是时候要使用方法的重写：父类的功能无法满足子类的需求时。</p>\n<p>方法重写要注意的事项：<br>    1.方法重写时， 方法名与形参列表必须一致。<br>    2.方法重写时，子类的权限修饰符必须要大于或者等于父类的权限修饰符。<br>    3.方法重写时，子类的返回值类型必须要小于或者 等于父类的返回值类型。<br>    4.方法重写时， 子类抛出的异常类型要小于或者等于父类抛出的异常类型。<br>            Exception(最坏)<br>            RuntimeException(小坏)</p>\n<p>方法的重载：在一个类中 存在两个或者两个 以上的同名函数,称作为方法重载。</p>\n<p>方法重载的要求</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"lit\">1.</span><span class=\"pln\"> </span><span class=\"pun\">函数名要一致。</span></code></li><li class=\"L1\"><code><span class=\"lit\">2.</span><span class=\"pln\"> </span><span class=\"pun\">形参列表不一致（形参的个数或形参</span><span class=\"pln\"> </span><span class=\"pun\">的类型不一致）</span></code></li><li class=\"L2\"><code><span class=\"lit\">3.</span><span class=\"pln\"> </span><span class=\"pun\">与返回值类型无关。</span></code></li></ol></pre></div>','2017-03-21',0,21,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(540,'垃圾回收算法','垃圾回收算法 1、标记-清除算法 2、复制算法 3、标记-整理算法 一、标记-清除算法 标记-清除算法采用从根集合进行扫描，对存活的对象对象标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收，如上图所示。 标记-清除算法不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效，但由于标记-清除算法直接回收不存活的对象，因此会造成内存碎片！ 二、复制算法 复制算法','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h2 id=\"h2-u5783u573Eu56DEu6536u7B97u6CD5\"><a name=\"垃圾回收算法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>垃圾回收算法</h2><p>1、标记-清除算法<br>2、复制算法<br>3、标记-整理算法</p>\n<h4 id=\"h4--\"><a name=\"一、标记-清除算法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、标记-清除算法</h4><p><img src=\"http://dl2.iteye.com/upload/attachment/0075/0386/29ae17ad-f8af-38b4-9e25-28ef3550858f.jpg\" alt=\"\">标记-清除算法采用从根集合进行扫描，对存活的对象对象标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收，如上图所示。<br>标记-清除算法不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效，但由于标记-清除算法直接回收不存活的对象，因此会造成内存碎片！</p>\n<h4 id=\"h4--\"><a name=\"二、复制算法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、复制算法</h4><p><img src=\"http://dl2.iteye.com/upload/attachment/0075/0388/91a656d4-f08a-377b-8eea-5785c2932533.jpg\" alt=\"\"><br>复制算法采用从根集合扫描，并将存活对象复制到一块新的，没有使用过的空间中，这种算法当控件存活的对象比较少时，极为高效，但是带来的成本是需要一块内存交换空间用于进行对象的移动。也就是我们前面提到的s0 s1等空间。</p>\n<h4 id=\"h4--\"><a name=\"三、标记-整理算法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、标记-整理算法</h4><p><img src=\"http://dl2.iteye.com/upload/attachment/0075/0390/6ba95f80-c7bc-3d09-b927-ac09297e9920.jpg\" alt=\"\"><br> 标记-整理算法采用标记-清除算法一样的方式进行对象的标记，但在清除时不同，在回收不存活的对象占用的空间后，会将所有的存活对象往左端空闲空间移动，并更新对应的指针。标记-整理算法是在标记-清除算法的基础上，又进行了对象的移动，因此成本更高，但是却解决了内存碎片的问题。</p>\n</div>','2017-04-09',0,27,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(541,'java分代回收','一、新生代内存的回收（minor GC）主要采用复制算法，下图展示了minor GC的执行过程。 二、对于新生代和旧生代，JVM可使用很多种垃圾回收器进行垃圾回收，下图展示了不同生代不通垃圾回收器，其中两个回收器之间有连线表示这两个回收器可以同时使用。 而这些垃圾回收器又分为串行回收方式、并行回收方式合并发回收方式执行，分别运用于不同的场景。如下图所示 三、收集器 1.Serial收集器 看名字我','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h2 id=\"h2--minor-gc-minor-gc-\"><a name=\"一、新生代内存的回收（minor GC）主要采用复制算法，下图展示了minor GC的执行过程。\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、新生代内存的回收（minor GC）主要采用复制算法，下图展示了minor GC的执行过程。</h2><p><img src=\"http://dl2.iteye.com/upload/attachment/0075/0392/732c7557-aa9a-3551-b14d-f543c5b0c94b.jpg\" alt=\"\"></p>\n<h2 id=\"h2--jvm-\"><a name=\"二、对于新生代和旧生代，JVM可使用很多种垃圾回收器进行垃圾回收，下图展示了不同生代不通垃圾回收器，其中两个回收器之间有连线表示这两个回收器可以同时使用。\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、对于新生代和旧生代，JVM可使用很多种垃圾回收器进行垃圾回收，下图展示了不同生代不通垃圾回收器，其中两个回收器之间有连线表示这两个回收器可以同时使用。</h2><p><img src=\"http://dl2.iteye.com/upload/attachment/0075/0394/0172f624-9018-3642-bf26-05a2c3071639.jpg\" alt=\"\"><br>而这些垃圾回收器又分为串行回收方式、并行回收方式合并发回收方式执行，分别运用于不同的场景。如下图所示<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0396/c962c2ad-273f-3de4-b2e3-a4dd8b946215.jpg\" alt=\"\"></p>\n<h2 id=\"h2--\"><a name=\"三、收集器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、收集器</h2><h4 id=\"h4-1-serial-\"><a name=\"1.Serial收集器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.Serial收集器</h4><p>看名字我们都可以看的出来，这个属于串行收集器。其运行示意图如下<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0398/681da5ca-5eff-3984-bece-3d80dfe905be.jpg\" alt=\"\"><br>    收集器是历史最悠久的一个回收器，JDK1.3之前广泛使用这个收集器，目前也是ClientVM下 ServerVM 4核4GB以下机器的默认垃圾回收器。串行收集器并不是只能使用一个CPU进行收集，而是当JVM需要进行垃圾回收的时候，需要中断所有的用户线程，知道它回收结束为止，因此又号称“Stop The World” 的垃圾回收器。注意，JVM中文名称为java虚拟机，因此它就像一台虚拟的电脑一样在工作，而其中的每一个线程就被认为是JVM的一个处理器，因此大家看到图中的CPU0、CPU1实际为用户的线程，而不是真正机器的CPU，大家不要误解哦。<br>    串行回收方式适合低端机器，是Client模式下的默认收集器，对CPU和内存的消耗不高，适合用户交互比较少，后台任务较多的系统。<br>    Serial收集器默认新旧生代的回收器搭配为Serial+ SerialOld</p>\n<h4 id=\"h4-2-parnew-\"><a name=\"2.ParNew收集器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.ParNew收集器</h4><p>ParNew收集器其实就是多线程版本的Serial收集器，其运行示意图如下<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0400/6443b39c-ed33-3d93-a690-87e646439561.jpg\" alt=\"\"><br>同样有Stop The World的问题，他是多CPU模式下的首选回收器（该回收器在单CPU的环境下回收效率远远低于Serial收集器，所以一定要注意场景哦），也是Server模式下的默认收集器。</p>\n<h4 id=\"h4-3-parallelscavenge\"><a name=\"3.ParallelScavenge\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.ParallelScavenge</h4><p>ParallelScavenge又被称为是吞吐量优先的收集器，器运行示意图如下<br><img src=\"http://dl.iteye.com/upload/attachment/0075/0402/5007beba-0b0e-3cf4-b146-c28b6c0dd696.jpg\" alt=\"\"><br> ParallelScavenge<br>所提到的吞吐量=程序运行时间/(JVM执行回收的时间+程序运行时间),假设程序运行了100分钟，JVM的垃圾回收占用1分钟，那么吞吐量就是99%。在当今网络告诉发达的今天，良好的响应速度是提升用户体验的一个重要指标，多核并行云计算的发展要求程序尽可能的使用CPU和内存资源，尽快的计算出最终结果，因此在交互不多的云端，比较适合使用该回收器。</p>\n<h4 id=\"h4-4-parallelold\"><a name=\"4.ParallelOld\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.ParallelOld</h4><p>ParallelOld是老生代并行收集器的一种，使用标记整理算法、是老生代吞吐量优先的一个收集器。这个收集器是JDK1.6之后刚引入的一款收集器，我们看之前那个图之间的关联关系可以看到，早期没有ParallelOld之前，吞吐量优先的收集器老生代只能使用串行回收收集器，大大的拖累了吞吐量优先的性能，自从JDK1.6之后，才能真正做到较高效率的吞吐量优先。其运行示意图如下<br><img src=\"http://dl.iteye.com/upload/attachment/0075/0406/9a14da85-f943-3408-ba88-c6bb3842a792.jpg\" alt=\"\"></p>\n<h4 id=\"h4-5-serialold\"><a name=\"5.SerialOld\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.SerialOld</h4><p>SerialOld是旧生代Client模式下的默认收集器，单线程执行；在JDK1.6之前也是ParallelScvenge回收新生代模式下旧生代的默认收集器，同时也是并发收集器CMS回收失败后的备用收集器。其运行示意图如下<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0404/ce7aabd5-b0e0-3cda-9b6c-607cf6ebf689.jpg\" alt=\"\"></p>\n<h4 id=\"h4-5-cms\"><a name=\"5.CMS\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.CMS</h4><p>CMS又称响应时间优先(最短回收停顿)的回收器，使用并发模式回收垃圾，使用标记-清除算法，CMS对CPU是非常敏感的，它的回收线程数=（CPU+3）/4，因此当CPU是2核的实惠，回收线程将占用的CPU资源的50%，而当CPU核心数为4时仅占用25%。他的运行示意图如下<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0408/4239228b-879f-382f-81c6-5c32799886d6.jpg\" alt=\"\"><br>模式主要分为四个过程：<br>1.初始标记<br>2.并发标记<br>3.重新标记<br>4.并发清除<br>在初始标记的时候，需要中断所有用户线程，在并发标记阶段，用户线程和标记线程<br>并发执行，而在这个过程中，随着内存引用关系的变化，可能会发生原来标记的对象被释放，进而引发新的垃圾，因此可能会产生一系列的浮动垃圾，不能被回收。</p>\n<p>CMS 为了确保能够扫描到所有的对象，避免在Initial Marking 中还有未标识到的对象，采用的方法为找到标记了的对象，并将这些对象放入Stack 中，扫描时寻找此对象依赖的对象，如果依赖的对象的地址在其之前，则将此对象进行标记，并同时放入Stack 中，如依赖的对象地址在其之后，则仅标记该对象。<br>在进行Concurrent Marking 时minor GC 也可能会同时进行，这个时候很容易造成旧生代对象引用关系改变，CMS 为了应对这样的并发现象，提供了一个Mod Union Table 来进行记录，在这个Mod Union Table中记录每次minor GC 后修改了的Card 的信息。这也是ParallelScavenge不能和CMS一起使用的原因。<br>CMS产生浮动垃圾的情况请见如下示意图<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0410/60e7c659-790a-3405-af70-9ca4cfd9258d.jpg\" alt=\"\"><br>在运行回收过后，c就变成了浮动垃圾。<br>由于CMS会产生浮动垃圾，当回收过后，浮动垃圾如果产生过多，同时因为使用标记-清除算法会产生碎片，可能会导致回收过后的连续空间仍然不能容纳新生代移动过来或者新创建的大资源，因此会导致CMS回收失败，进而触发另外一次FULL GC，而这时候则采用SerialOld进行二次回收。<br>同时CMS因为可能产生浮动垃圾，而CMS在执行回收的同时新生代也有可能在进行回收操作，为了保证旧生代能够存放新生代转移过来的数据，CMS在旧生代内存到达全部容量的68%就触发了CMS的回收！</p>\n<h4 id=\"h4-7-garbagefirst-g1-\"><a name=\"7.GarbageFirst(G1)\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>7.GarbageFirst(G1)</h4><p>我们再来看垃圾回收器的总图，刚才我们可以看到，我在图上标记了一个？，其实这是一个新的垃圾回收器，既可以回收新生代也可以回收旧生代，SunHotSpot 1.6u14以上EarlyAccess版本加入了这个回收器，sun公司预期SunHotSpot1.7发布正式版，他是商用高性能垃圾回收器，通过重新划分内存区域，整合优化CMS，同时注重吞吐量和响应时间，但是杯具的是被Oracle收购之后这个收集器属于商用收费收集器，因此目前基本上没有人使用，我们在这里也就不多介绍，更多信息可以参考oracle新版本JDK说明。</p>\n</div>','2017-04-09',0,30,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(542,'java汇编','java 汇编 http://download.csdn.net/download/jiangfuqiang/8403497','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><p>java 汇编<br><a href=\"http://download.csdn.net/download/jiangfuqiang/8403497\">http://download.csdn.net/download/jiangfuqiang/8403497</a></p>\n</div>','2017-04-10',0,30,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(543,'jvm','-XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><p>-XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly</p>\n</div>','2017-04-10',0,28,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(544,'Java堆.栈和常量池 笔记','Java堆.栈和常量池 笔记','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><p><a href=\"http://www.iteye.com/topic/634530\">Java堆.栈和常量池 笔记</a></p>\n</div>','2017-04-23',0,25,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(545,'工厂模式','工厂模式 目录 何为工厂模式 工厂方法与抽象工厂 如何在Java EE中通过@Producers与@Inject注解实现工厂模式 如何创建自定义注解以及通过@Qualifier消除具体实现之间的歧义 工厂模式有两种模式：工厂方法和抽象方法。它们的意图是一样的：提供一个接口，在不指定具体类的情况下创建相关或依赖的一系列对象。 一.何为工厂模式 工厂的目的在于创建对象。创建的逻辑被封装在工厂中，要么提','<h1 id=\"h1-u5DE5u5382u6A21u5F0F\"><a name=\"工厂模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>工厂模式</h1><p>目录</p>\r\n<ul>\r\n<li>何为工厂模式</li><li>工厂方法与抽象工厂</li><li>如何在Java EE中通过<a href=\"https://github.com/Producers\" title=\"&#64;Producers\" class=\"at-link\">@Producers</a>与<a href=\"https://github.com/Inject\" title=\"&#64;Inject\" class=\"at-link\">@Inject</a>注解实现工厂模式</li><li>如何创建自定义注解以及通过<a href=\"https://github.com/Qualifier\" title=\"&#64;Qualifier\" class=\"at-link\">@Qualifier</a>消除具体实现之间的歧义<br>工厂模式有两种模式：工厂方法和抽象方法。它们的意图是一样的：提供一个接口，在不指定具体类的情况下创建相关或依赖的一系列对象。</li></ul>\r\n<h3 id=\"h3--\"><a name=\"一.何为工厂模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一.何为工厂模式</h3><p>工厂的目的在于创建对象。创建的逻辑被封装在工厂中，要么提供一个方法来返回新创建的对象（工厂方法模式），要么将对象的创建委托给子类（抽象工厂模式）。<br>客户端不必考虑接口或类的不同实现，它只需通过工厂（工厂）获取接口实现的一个实例的即可，这样客户端与对象的创建就实现了解耦<br>解耦是应用依赖反转原则的结果，这带来了很多好处，其中最重要的好处就是实现了高层类与底层类之间的解耦。通过解耦，具体类实现的变化不会影响到客户端，这降低了类与类之间的耦合，并提升了灵活性。</p>\r\n<h3 id=\"h3--\"><a name=\"二.工厂方法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二.工厂方法</h3><p>GoF一书是这样描述工程方法模式的：“定义一个用于创建对象的接口，不过让子类决定实例化那个类”<br>工厂极大降低了new关键字的使用次数，并且将初始化过程与不同的具体实现封装起来。将这些需求中心化可以极大减少向系统中添加或删除具体类的影响以及具体的类依赖的影响。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src=\"http://ohlrxdl4p.bkt.clouddn.com/images/QQ截图20170506134421.jpg\" alt=\"\"><br><strong>1.使用普通代码实现工厂方法</strong><br>被具体实现继承的DrinksMachine抽象类</p>\r\n<pre><code class=\"lang-java\">public abstract class DrinksMachine {\r\n    public abstract Drink dispenseDrink();\r\n    public String displayMessage(){\r\n        return &quot;Thank for your custom.&quot;;\r\n    }\r\n}\r\n</code></pre>\r\n<p>DrinksMachine抽象类的CoffeeMachine实现</p>\r\n<pre><code class=\"lang-java\">public class CoffeeMachine extends DrinksMachine {\r\n    public Drink dispenseDrink() {\r\n        return new Coffee();\r\n    }\r\n}\r\n</code></pre>\r\n<p>DrinksMachine抽象类的SoftDrinksMachine实现</p>\r\n<pre><code class=\"lang-java\">public class SoftDrinksMachine extends DrinksMachine {\r\n    public Drink dispenseDrink() {\r\n        return new SoftDrink();\r\n    }\r\n}\r\n</code></pre>\r\n<p>Drink接口</p>\r\n<pre><code class=\"lang-java\">public interface Drink {}\r\n</code></pre>\r\n<p>Drink接口的SoftDrink实现</p>\r\n<pre><code class=\"lang-java\">public class SoftDrink implements Drink {\r\n    SoftDrink() {\r\n        System.out.println(&quot;Soft drink&quot;);\r\n    }\r\n}\r\n</code></pre>\r\n<p>Drink接口的Coffee实现</p>\r\n<pre><code class=\"lang-java\">public class Coffee implements Drink {\r\n    Coffee() {\r\n        System.out.println(&quot;Coffee&quot;);\r\n    }\r\n}\r\n</code></pre>\r\n<p>CoffeeType枚举<br>```java<br>public enum CoffeeType {EXPRESSO, LATTE}</p>\r\n<p>public Drink dispenseDrink(CoffeeType type) {<br>    Drink coffee = null;<br>    switch (type) {<br>        case EXPRESSO: coffee = new Expresso();<br>        case LATTE: coffee = new Latte();<br>    }<br>    return coffee;<br>}<br>```&lt;!--前面不能有空格--&gt;</p>','2017-05-06',0,27,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(546,'代理模式','代理模式(Proxy Pattern) GoF中给出的代理模式的定义为： 代理模式给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。 代理模式的英文叫做Proxy或Surrogate，它是一种对象结构型模式。 代理模式根据其目的和实现可分为很多种类，常用的代理模式包括如下几种： （1）远程代理（Remote Proxy）————为一个位于不同的地址空间的对象提供一个本地的代理对象','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h1 id=\"h1--proxy-pattern-\"><a name=\"代理模式(Proxy Pattern)\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代理模式(Proxy Pattern)</h1><p>GoF中给出的代理模式的定义为：<br>代理模式给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。<br>代理模式的英文叫做Proxy或Surrogate，它是一种对象结构型模式。<br>代理模式根据其目的和实现可分为很多种类，常用的代理模式包括如下几种：<br>（1）远程代理（Remote Proxy）————为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以是在同一台主机中，也可以是在另一台主机中，远程代理又称为大使（Ambassador）<br>（2）虚拟代理（Virtual Proxy）————如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。<br>（3）保护代理（Protect Proxy）————控制一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。<br>（4）缓冲代理（Cache Proxy）————为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。<br>（5）只能引用代理（Smart Reference Proxy）————当一个对象被引用时，提供一些额外的操作，例如将对象被调用的次数记录下来。<br><img src=\"http://ohlrxdl4p.bkt.clouddn.com/images/QQ截图20170507103646.jpg\" alt=\"\"></p>\n<p>代码实现：<br>1.抽象主题类——BuyTicket.java</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code class=\"lang-java\"><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">interface</span><span class=\"pln\"> </span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> showticket</span><span class=\"pun\">();</span></code></li><li class=\"L2\"><code class=\"lang-java\"><span class=\"pun\">}</span></code></li></ol></pre>\n<p>2.具体主题类——Train.java</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code class=\"lang-java\"><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Train</span><span class=\"pln\"> </span><span class=\"kwd\">implements</span><span class=\"pln\"> </span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"lit\">@Override</span></code></li><li class=\"L2\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> showticket</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L3\"><code class=\"lang-java\"><span class=\"pln\">        </span><span class=\"typ\">System</span><span class=\"pun\">.</span><span class=\"pln\">out</span><span class=\"pun\">.</span><span class=\"pln\">println</span><span class=\"pun\">(</span><span class=\"str\">\"one ticket\"</span><span class=\"pun\">);</span></code></li><li class=\"L4\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L5\"><code class=\"lang-java\"><span class=\"pun\">}</span></code></li></ol></pre>\n<p>3.代理角色类——TicketCenter.java</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code class=\"lang-java\"><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">TicketCenter</span><span class=\"pln\"> </span><span class=\"kwd\">implements</span><span class=\"pln\"> </span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> ticket</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code class=\"lang-java\"></code></li><li class=\"L3\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"typ\">TicketCenter</span><span class=\"pun\">(</span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> ticket</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code class=\"lang-java\"><span class=\"pln\">        </span><span class=\"kwd\">this</span><span class=\"pun\">.</span><span class=\"pln\">ticket </span><span class=\"pun\">=</span><span class=\"pln\"> ticket</span><span class=\"pun\">;</span></code></li><li class=\"L5\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code class=\"lang-java\"></code></li><li class=\"L7\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"lit\">@Override</span></code></li><li class=\"L8\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> showticket</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L9\"><code class=\"lang-java\"><span class=\"pln\">        ticket</span><span class=\"pun\">.</span><span class=\"pln\">showticket</span><span class=\"pun\">();</span></code></li><li class=\"L0\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code class=\"lang-java\"></code></li><li class=\"L2\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> buy</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L3\"><code class=\"lang-java\"><span class=\"pln\">        </span><span class=\"typ\">System</span><span class=\"pun\">.</span><span class=\"pln\">out</span><span class=\"pun\">.</span><span class=\"pln\">println</span><span class=\"pun\">(</span><span class=\"str\">\"by proxy\"</span><span class=\"pun\">);</span></code></li><li class=\"L4\"><code class=\"lang-java\"><span class=\"pln\">        showticket</span><span class=\"pun\">();</span></code></li><li class=\"L5\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code class=\"lang-java\"><span class=\"pun\">}</span></code></li></ol></pre>\n<p>4.客户端测试类</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code class=\"lang-java\"><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">ProxyPattern</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> main</span><span class=\"pun\">(</span><span class=\"typ\">String</span><span class=\"pln\"> args</span><span class=\"pun\">[])</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L2\"><code class=\"lang-java\"><span class=\"pln\">        </span><span class=\"typ\">BuyTicket</span><span class=\"pln\"> x </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Train</span><span class=\"pun\">();</span></code></li><li class=\"L3\"><code class=\"lang-java\"><span class=\"pln\">        </span><span class=\"typ\">TicketCenter</span><span class=\"pln\"> y </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">TicketCenter</span><span class=\"pun\">(</span><span class=\"pln\">x</span><span class=\"pun\">);</span></code></li><li class=\"L4\"><code class=\"lang-java\"><span class=\"pln\">        y</span><span class=\"pun\">.</span><span class=\"pln\">buy</span><span class=\"pun\">();</span></code></li><li class=\"L5\"><code class=\"lang-java\"><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code class=\"lang-java\"><span class=\"pun\">}</span></code></li></ol></pre>\n<p>运行结果：</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code class=\"lang-html\"><span class=\"pln\">by proxy</span></code></li><li class=\"L1\"><code class=\"lang-html\"><span class=\"pln\">one ticket</span></code></li></ol></pre>\n</div>','2017-05-07',0,28,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(547,'2017-02-28学习笔记','','<p><img src=\"http://ohlrxdl4p.bkt.clouddn.com/images/826546_1482322555369_C5DABB18734059E89A45A0E9170722B0.png\" alt=\"\"></p>','2017-02-28',0,26,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(548,'2017-03-01学习笔记','知识点 1.java中只有值传递，没有引用传递http://guhanjie.iteye.com/blog/1683637 2.final关键字 final修饰变量，则等同于常量. final修饰方法中的参数，称为最终参数. final修饰类，则类不能被继承. final修饰方法，则方法不能被','<h1 id=\"h1-u77E5u8BC6u70B9\"><a name=\"知识点\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>知识点</h1><h4 id=\"h4-1-java-http-guhanjie-iteye-com-blog-1683637\"><a name=\"1.java中只有值传递，没有引用传递  http://guhanjie.iteye.com/blog/1683637\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.java中只有值传递，没有引用传递<a href=\"http://guhanjie.iteye.com/blog/1683637\">http://guhanjie.iteye.com/blog/1683637</a></h4><h4 id=\"h4-2-final-\"><a name=\"2.final关键字\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.final关键字</h4><ul>\r\n<li>final修饰变量，则等同于常量.</li><li>final修饰方法中的参数，称为最终参数.</li><li>final修饰类，则类不能被继承.</li><li>final修饰方法，则方法不能被重写.</li></ul>\r\n<h4 id=\"h4-3-integer-img-src-https-uploadfiles-nowcoder-com-images-20160717-6316247_1468761643205_9f7b85ab04292cf73778d98998a20ed1-alt-\"><a name=\"3.Integer<img src=\"https://uploadfiles.nowcoder.com/images/20160717/6316247_1468761643205_9F7B85AB04292CF73778D98998A20ED1\" alt=\"图片\">\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.Integer<img src=\"https://uploadfiles.nowcoder.com/images/20160717/6316247_1468761643205_9F7B85AB04292CF73778D98998A20ED1\" alt=\"图片\"></h4><h4 id=\"h4-4-java-\"><a name=\"4.java内存模型   点击原文\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.java内存模型 <a href=\"http://blog.csdn.net/ns_code/article/details/17565503\">点击原文</a></h4><p><img src=\"https://uploadfiles.nowcoder.com/images/20161223/415611_1482452184396_6FB53C51539B47559CF0D122A832CF63\" alt=\"\"></p>\r\n<h4 id=\"h4-5-java-reference\"><a name=\"5.java中是没有指针的，有reference\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.java中是没有指针的，有reference</h4><p>第一：指针变量是在栈内存中，它也是有值的，这个值存储的就是地址单元，这个地址就是来自于赋值操作。<br>第二：指针变量有类型，这个类型（如Person）的含义是指针指向的变量在栈内存（不是很确定）中的范围（大小），我理解为是占用的堆内存空间。<br>第三：声明一个对象时，是对“指针变量”的定义。<br>第四：用new关键字在堆内存创建了对象，在赋值时，是把这个对象的首地址传给了这个“指针变量”（即引用型变量）。</p>\r\n<h4 id=\"h4-6-string-\"><a name=\"6.String生成常量\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6.String生成常量</h4><pre><code class=\"lang-java\">String s1=&quot;abc&quot;+&quot;def&quot;;//生成的是一个常量，放在堆内存中\r\nString s2=new String（s1);//s2是一个变量\r\nif(s1.equals(s2))//比较的是字符串的内容\r\n    System.out.println(&quot;.equals succeeded&quot;);//输出\r\nif(s1==s2)//比较的是内存地址，但s1是常量，所以不相等\r\n    System.out.println(&quot;==succeeded&quot;);\r\n</code></pre>\r\n<h4 id=\"h4-7-jsp-\"><a name=\"7.jsp内置对象和属性\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>7.jsp内置对象和属性</h4><p>（１）request对象<br>客户端的请求信息被封装在request对象中，通过它才能了解到客户的需求，然后做出响应。它是HttpServletRequest类的实例。<br>（２）response对象<br>response对象包含了响应客户请求的有关信息，但在JSP中很少直接用到它。它是HttpServletResponse类的实例。<br>（３）session对象<br>session对象指的是客户端与服务器的一次会话，从客户连到服务器的一个WebApplication开始，直到客户端与服务器断开连接为止。它是HttpSession类的实例.<br>（４）out对象<br>out对象是JspWriter类的实例,是向客户端输出内容常用的对象<br>（５）page对象<br>page对象就是指向当前JSP页面本身，有点象类中的this指针，它是java.lang.Object类的实例<br>（６）application对象<br>application对象实现了用户间数据的共享，可存放全局变量。它开始于服务器的启动，直到服务器的关闭，在此期间，此对象将一直存在；这样在用户的前后连接或不同用户之间的连接中，可以对此对象的同一属性进行操作；在任何地方对此对象属性的操作，都将影响到其他用户对此的访问。服务器的启动和关闭决定了application对象的生命。它是ServletContext类的实例。<br>（７）exception对象<br>exception对象是一个例外对象，当一个页面在运行过程中发生了例外，就产生这个对象。如果一个JSP页面要应用此对象，就必须把isErrorPage设为true，否则无法编译。他实际上是java.lang.Throwable的对象<br>（８）pageContext对象<br>pageContext对象提供了对JSP页面内所有的对象及名字空间的访问，也就是说他可以访问到本页所在的SESSION，也可以取本页面所在的application的某一属性值，他相当于页面中所有功能的集大成者，它的本 类名也叫pageContext。<br>（９）config对象<br>config对象是在一个Servlet初始化时，JSP引擎向它传递信息用的，此信息包括Servlet初始化时所要用到的参数（通过属性名和属性值构成）以及服务器的有关信息（通过传递一个ServletContext对象）</p>','2017-03-01',0,24,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(549,'2017-03-02学习笔记','知识点 一、static public class Spike\r\n{\r\n    public static void main(String[] args)\r\n    {\r\n        Counter a = new Counter();\r\n        System.out.println(a.increment());\r\n        System.out.println(a.anot','<h1 id=\"h1-u77E5u8BC6u70B9\"><a name=\"知识点\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>知识点</h1><h4 id=\"h4--static\"><a name=\"一、static\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、static</h4><pre><code class=\"lang-java\">public class Spike\r\n{\r\n    public static void main(String[] args)\r\n    {\r\n        Counter a = new Counter();\r\n        System.out.println(a.increment());\r\n        System.out.println(a.anotherIncrement());\r\n        Counter b = new Counter();\r\n        System.out.println(b.increment());\r\n    }\r\n}\r\nclass Counter\r\n{\r\n    private static int count = 0;\r\n    public int increment()\r\n    {\r\n        return count++;\r\n    }\r\n    public int anotherIncrement()\r\n    {\r\n        return ++count;\r\n    }\r\n}\r\n</code></pre>\r\n<p>count是静态变量，为所有对象所共享，因此不管a.increment()还是b.increment()都会使count持续增加。<br>increment()方法返回当前count值，然后count增加1<br>antoherIncrement()方法让count增加1，然后返回count值<br>第一次a.increment()返回值为0，此时count值为1<br>第二次a.anotherIncrement()先让count+1再返回，返回值为2<br>第三次b.increment()先返回count当前值2，然后count+1</p>\r\n<h4 id=\"h4--aop-\"><a name=\"二、AOP面向切面\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、AOP面向切面</h4><p>AOP的概念是Aspected Oriented Programming 面向方面编程。<br>  好处：AOP将程序分解成各个方面或者说关注点。这使得可以模块化，相当横向上分切了。它可以解决OOP和过程化方法不能够很好解决的横切（crosscut）问题，如：事务、安全、日志等横切关注。<br>  实现AOP有几种方式:<br>  1.Spring 1.2版本中通过ProxyFactoryBean来实现aop,即通过动态代理来实现的,Aspect必须继承MethodBeforeAdvice,MethodAfterAdvice等<br>  2.Spring 2.0 AOP需要改的是FBI 这个类，而且它也不需要再实现某些接口<br>  3.三使用标注（<a href=\"https://github.com/AspectJ\" title=\"&#64;AspectJ\" class=\"at-link\">@AspectJ</a>）实现AOP<br>    AOP 和 OOP的区别：</p>\r\n<pre><code>```html\r\n 1. 面向方面编程 AOP 偏重业务处理过程的某个步骤或阶段，强调降低模块之间的耦合度，使代码拥有更好的移植性。  \r\n 2. 面向对象编程 (oop) 则是对业务分析中抽取的实体进行方法和属性的封装。\r\n ```\r\n</code></pre><p>也可以说 AOP 是面向业务中的动词领域， OOP 面向名词领域。<br>AOP 的一个很重要的特点是源代码无关性，也就是说如果我们的系统中引用了 AOP 组件，即使我们把该组件去掉，系统代码也应该能够编译通过。要实现这一点，可以使用动态 proxy 模式。</p>\r\n<h4 id=\"h4--jdbc-\"><a name=\"三、jdbc桥接模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、jdbc桥接模式</h4><p>桥接模式：<br>定义 ：将抽象部分与它的实现部分分离，使它们都可以独立地变化。<br>意图 ：将抽象与实现解耦。<br>桥接模式所涉及的角色</p>\r\n<ol>\r\n<li>Abstraction ：定义抽象接口，拥有一个Implementor类型的对象引用</li><li>RefinedAbstraction ：扩展Abstraction中的接口定义</li><li>Implementor ：是具体实现的接口，Implementor和RefinedAbstraction接口并不一定完全一致，实际上这两个接口可以完全不一样Implementor提供具体操作方法，而Abstraction提供更高层次的调用</li><li>ConcreteImplementor ：实现Implementor接口，给出具体实现<br>Jdk中的桥接模式：JDBC<br>JDBC连接 数据库 的时候，在各个数据库之间进行切换，基本不需要动太多的代码，甚至丝毫不动，原因就是JDBC提供了统一接口，每个数据库提供各自的实现，用一个叫做数据库驱动的程序来桥接就行了<h4 id=\"h4--\"><a name=\"四、抽象类\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>四、抽象类</h4>抽象类和普通类有三点区别：<br>1）抽象方法必须为public和protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public。<br>2）抽象类不能用来创建对象，但是它可以有构造方法，用来帮助子类实例化。<br>3）如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为abstract类。<h4 id=\"h4--\"><a name=\"五、接口\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>五、接口</h4>接口的主要特点<br>1）接口中的成员变量默认都是public、static、final类型的，必须被显示初始化。<br>2）接口中的方法默认都是public、abstract类型的。<br>3）接口中只能包含public、static、final类型的成员变量和public、abstract类型的成员方法。<br>4）接口没有构造方法，不能被实例化。<br>5）一个接口不能实现另一个接口，但它可以继承多个其他接口。<br>6）接口必须通过类来实现它的抽象方法。<br>7）与子类继承抽象父类相似，当类实现了某个接口时，它必须实现接口中所有的抽象方法，否则这个类必须被定义为抽象类。<br>8）一个类只能继承一个直接的父类，但能实现多个接口。<h4 id=\"h4--\"><a name=\"六、抽象类和接口的区别\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>六、抽象类和接口的区别</h4>1）抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract方法；<br>2）抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；<br>3）接口中不能含有静态代码块以及静态方法，而抽象类尅有静态代码块和静态方法；<br>4）一个类只能继承一个抽象类，而一个类却可以实现多个接口。<br>5）抽象类中的方法子类必须全部实现，不然子类也是抽象类，而接口中的抽象方法子类必须全部实现，是可选择实现的。<br>6）抽象类是一种模板设计模式，而接口时一种行为规范。</li></ol>','2017-03-02',0,22,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(550,'2017-03-03学习笔记','一、String StringBuffer.toString()源码： @Override\r\npublic synchronized String toString() {\r\n    if (toStringCache == null) {\r\n        toStringCache = Arrays.copyOfRange(value, 0, count);\r\n    }\r\n    retur','<h4 id=\"h4--string\"><a name=\"一、String\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、String</h4><p>StringBuffer.toString()源码：</p>\r\n<pre><code class=\"lang-java\">@Override\r\npublic synchronized String toString() {\r\n    if (toStringCache == null) {\r\n        toStringCache = Arrays.copyOfRange(value, 0, count);\r\n    }\r\n    return new String(toStringCache, true);\r\n}\r\n</code></pre>\r\n<p>Arrays.copyOfRange用的是System.arraycopy</p>\r\n<pre><code class=\"lang-java\">public static char[] copyOfRange(char[] original, int from, int to) {\r\n        int newLength = to - from;\r\n        if (newLength &lt; 0)\r\n            throw new IllegalArgumentException(from + &quot; &gt; &quot; + to);\r\n        char[] copy = new char[newLength];\r\n        System.arraycopy(original, from, copy, 0,\r\n                         Math.min(original.length - from, newLength));\r\n        return copy;\r\n    }\r\n</code></pre>\r\n<p>1.String是值传入，不是引用传入。<br>2.String对String  类型进行改变的时候其实都等同于生成了一个新的  String  对象，然后将指针指向新的  String  对象，而不是StringBuffer；StringBuffer每次结果都会对  StringBuffer  对象本身进行操作，而不是生成新的对象，再改变对象引用。<br>3.效率比较String&lt;StringBuffer&lt;StringBuilder，但是在 String S1 = “This is only a” + “ simple” + “ test”时，String效率最高。</p>\r\n<h4 id=\"h4--jvm-\"><a name=\"二、jvm知识图谱\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、jvm知识图谱</h4><p><a href=\"https://zhuanlan.zhihu.com/p/25511795\">引用自知乎</a><br><img src=\"https://pic2.zhimg.com/v2-701563ac1fe745fc8e1234c96e82ac99_r.jpg\" alt=\"\"></p>\r\n<h4 id=\"h4--treemap-linkhashmap\"><a name=\"三、Treemap、LinkHashMap\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、Treemap、LinkHashMap</h4><p>1.TreeMap取出来的是排序后的键值对。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。<br>2.LinkedHashMap 是HashMap的一个子类，如果需要输出的顺序和输入的相同,那么用LinkedHashMap可以实现,它还可以按读取顺序来排列。</p>\r\n<h4 id=\"h4--sql-\"><a name=\"四、sql模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>四、sql模式</h4><p>MySQL数据库中，变量分为 系统变量（以”@@”开头）和用户自定义变量。系统变量分为全局系统变量(global)和会话系统变量(session)。<br>@<a href=\"https://github.com/global\" title=\"&#64;global\" class=\"at-link\">@global</a>     仅用于访问全局系统变量的值；<br>@<a href=\"https://github.com/session\" title=\"&#64;session\" class=\"at-link\">@session</a>  仅用于访问会话系统变量的值；<br>@@              先访问会话系统变量的值，若不存在则去访问全局系统变量的值；<br>sql_mode 为系统变量，既是全局系统变量，又是会话系统变量。</p>\r\n<h4 id=\"h4--\"><a name=\"五、代码的执行顺序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>五、代码的执行顺序</h4><p>父类Ｂ静态代码块-&gt;子类Ａ静态代码块-&gt;父类Ｂ非静态代码块-&gt;父类Ｂ构造函数-&gt;子类Ａ非静态代码块-&gt;子类Ａ构造函数<br><img src=\"http://ohlrxdl4p.bkt.clouddn.com/images/QQ截图20170303165728.jpg\" alt=\"\"></p>','2017-03-03',0,25,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(551,'ifhifhajfe','hello','<h1 id=\"h1-hello\"><a name=\"hello\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>hello</h1>','2017-03-05',0,23,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(552,'2017-03-05学习笔记','java的堆，栈，静态代码区（常量区） 详解','<p><a href=\"http://blog.csdn.net/u012031380/article/details/54981472\"> java的堆，栈，静态代码区（常量区） 详解</a></p>','2017-03-05',0,23,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(553,'java归并排序','package datastruct;\r\n\r\n/**\r\n * Created by Zephery on 2017/3/3.\r\n */\r\npublic class Solution {\r\n    public static void printArray(int[] arr, int i, int j) {\r\n        System.out.print(\"[\");\r\n        for','<pre><code class=\"lang-java\">package datastruct;\r\n\r\n/**\r\n * Created by Zephery on 2017/3/3.\r\n */\r\npublic class Solution {\r\n    public static void printArray(int[] arr, int i, int j) {\r\n        System.out.print(&quot;[&quot;);\r\n        for (int k = i; k &lt; j; k++) {\r\n            System.out.print(arr[k] + &quot;,&quot;);\r\n        }\r\n        System.out.print(arr[j] + &quot;]&quot;);\r\n    }\r\n\r\n    private static void mergesort(int[] arr, int i, int j) {\r\n        int mid = 0;\r\n        if (i &lt; j) {\r\n            mid = (i + j) / 2;\r\n            mergesort(arr, i, mid);\r\n            mergesort(arr, mid + 1, j);\r\n            merge(arr, i, mid, j);\r\n        }\r\n    }\r\n\r\n    private static void merge(int[] arr, int i, int mid, int j) {\r\n        System.out.print(&quot;Left:&quot;);\r\n        printArray(arr, i, mid);\r\n        System.out.println(&quot;Right:&quot;);\r\n        printArray(arr, mid + 1, j);\r\n        System.out.println();\r\n        int temp[] = new int[arr.length];\r\n        int l = i;\r\n        int r = j;\r\n        int m = mid + 1;\r\n        int k = l;\r\n        while (l &lt;= mid &amp;&amp; m &lt;= r) {\r\n            if (arr[l] &lt;= arr[m]) {\r\n                temp[k++] = arr[l++];\r\n            } else {\r\n                temp[k++] = arr[m++];\r\n            }\r\n        }\r\n        while (l &lt;= mid) {\r\n            temp[k++] = arr[l++];\r\n        }\r\n        while (m &lt;= r) {\r\n            temp[k++] = arr[m++];\r\n        }\r\n        for (int i1 = i; i1 &lt;= j; i1++) {\r\n            arr[i1] = temp[i1];\r\n        }\r\n        System.out.print(&quot;After Merge:&quot;);\r\n        printArray(arr, i, j);\r\n        System.out.println();\r\n    }\r\n\r\n    public static void main(String args[]) {\r\n        int[] arr = {9, 4, 8, 3, 1, 2, 5};\r\n        System.out.print(&quot;Initial Array:&quot;);\r\n        printArray(arr, 0, arr.length - 1);\r\n        System.out.println();\r\n        mergesort(arr, 0, arr.length - 1);\r\n    }\r\n}\r\n</code></pre>\r\n<pre><code class=\"lang-js\">Initial Array:[9,4,8,3,1,2,5]\r\nLeft:[9]Right:\r\n[4]\r\nAfter Merge:[4,9]\r\nLeft:[8]Right:\r\n[3]\r\nAfter Merge:[3,8]\r\nLeft:[4,9]Right:\r\n[3,8]\r\nAfter Merge:[3,4,8,9]\r\nLeft:[1]Right:\r\n[2]\r\nAfter Merge:[1,2]\r\nLeft:[1,2]Right:\r\n[5]\r\nAfter Merge:[1,2,5]\r\nLeft:[3,4,8,9]Right:\r\n[1,2,5]\r\nAfter Merge:[1,2,3,4,5,8,9]\r\n</code></pre>','2017-03-06',0,24,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(554,'2017-03-10学习笔记','1.Integer和int，装箱拆箱 1、基本型和基本型封装型进行“==”运算符的比较，基本型封装型将会自动拆箱变为基本型后再进行比较，因此Integer(0)会自动拆箱为int类型再进行比较，显然返回true； 2、两个Integer类型进行“==”比较，如果其值在-128至127，那么返回true，否则返回false, 这跟Integer.valueOf()的缓冲对象有关，这里不进行赘述。 3','<h1 id=\"h1-1-integer-int-\"><a name=\"1.Integer和int，装箱拆箱\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.Integer和int，装箱拆箱</h1><p>1、基本型和基本型封装型进行“==”运算符的比较，基本型封装型将会自动拆箱变为基本型后再进行比较，因此Integer(0)会自动拆箱为int类型再进行比较，显然返回true；<br>2、两个Integer类型进行“==”比较，如果其值在-128至127，那么返回true，否则返回false, 这跟Integer.valueOf()的缓冲对象有关，这里不进行赘述。<br>3、两个基本型的封装型进行equals()比较，首先equals()会比较类型，如果类型相同，则继续比较值，如果值也相同，返回true<br>4、基本型封装类型调用equals(),但是参数是基本类型，这时候，先会进行自动装箱，基本型转换为其封装类型，再进行3中的比较。</p>\r\n<pre><code class=\"lang-java\">int a=257;\r\nInteger b=257;\r\nInteger c=257;\r\nInteger b2=57;\r\nInteger c2=57;\r\nSystem.out.println(a==b);\r\n//System.out.println(a.equals(b));  编译出错，基本型不能调用equals()\r\nSystem.out.println(b.equals(257.0));\r\nSystem.out.println(b==c);\r\nSystem.out.println(b2==c2);\r\n</code></pre>\r\n<p>因此上面的代码的结果因此为 true, false, false, true</p>\r\n<h1 id=\"h1-2-\"><a name=\"2.线程调度\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.线程调度</h1><p>分为协同式调度和抢占式调度，Java使用的是抢占式调度，也就是每个线程将由操作系统来分配执行时间，线程的切换不由线程本身来决定（协同式调度）。这就是平台独立的原因。</p>\r\n<h1 id=\"h1-3-\"><a name=\"3.重载，重写\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.重载，重写</h1><p>重写：<br>两同，两小，一大<br>两同：方法名，方法参数列表相同。<br>两小：抛出的异常类型要小于等于父类，返回值类型要小于等于父类<br>一大：访问权限大于等于父类。<br>重载：<br>在同一个类中，方法名和方法参数列表不同，其他的（访问权限、返回值）随意。</p>\r\n<h1 id=\"h1-4-jvm-\"><a name=\"4.  JVM面试题\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.<a href=\"http://blog.csdn.net/hsk256/article/details/49104955\">JVM面试题</a></h1>','2017-03-10',0,24,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(555,'2017-03-12学习笔记','1.继承的加载顺序 执行顺序大体上可以说是先父类后子类，父类static域 ==》子类static域 ==》父类数据成员域 ==》父类构造器 ==》子类数据成员域 ==》子类构造器 2.优化Hibernate所鼓励的7大措施： 1.尽量使用many-to-one，避免使用单项one-to-many 2.灵活使用单向one-to-many 3.不用一对一，使用多对一代替一对一 4.配置对象缓存，不使','<h4 id=\"h4-1-\"><a name=\"1.  继承的加载顺序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.<a href=\"http://www.cnblogs.com/SirSmith/p/5536288.html\">继承的加载顺序</a></h4><p><img src=\"http://images2015.cnblogs.com/blog/452847/201605/452847-20160527221410288-2119099273.png\" alt=\"\"></p>\r\n<p>执行顺序大体上可以说是先父类后子类，父类static域 ==》子类static域 ==》父类数据成员域 ==》父类构造器 ==》子类数据成员域 ==》子类构造器</p>\r\n<h4 id=\"h4-2-hibernate-7-\"><a name=\"2.优化Hibernate所鼓励的7大措施：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.优化Hibernate所鼓励的7大措施：</h4><p>1.尽量使用many-to-one，避免使用单项one-to-many<br>2.灵活使用单向one-to-many<br>3.不用一对一，使用多对一代替一对一<br>4.配置对象缓存，不使用集合缓存<br>5.一对多使用Bag 多对一使用Set<br>6.继承使用显示多态 HQL:from object polymorphism=”exlicit” 避免查处所有对象<br>7.消除大表，使用二级缓存</p>\r\n<h4 id=\"h4-3-java-\"><a name=\"3.java中的数据类型分类：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.java中的数据类型分类：</h4><p>基本数据类型（或叫做原生类、内置类型）8种：<br>    整数：byte，short，int，long（默认是int类型）<br>    浮点类型： float，double（默认是double类型）<br>    字符类型：char<br>    布尔类型：boolean<br>引用数据类型3种：数组，类，接口</p>\r\n<h4 id=\"h4-4-\"><a name=\"4.触发器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.触发器</h4><p>drop trigger 删除触发器<br>Drop用于删除数据表或数据库，或删除数据表字段。<br>remove：删除数据库文件<br>Truncate：删除数据表中的数据（仅数据表中的数据，不删除表）。</p>','2017-03-12',0,22,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(556,'2017-03-14学习笔记','1.Servlet的生命周期分为5个阶段：加载、创建、初始化、处理客户请求、卸载。 (1)加载：容器通过类加载器使用servlet类对应的文件加载servlet (2)创建：通过调用servlet构造函数创建一个servlet对象 (3)初始化：调用init方法初始化 (4)处理客户请求：每当有一个客户请求，容器会创建一个线程来处理客户请求 (5)卸载：调用destroy方法让servlet自己释','<h4 id=\"h4-1-servlet-5-\"><a name=\"1.Servlet的生命周期分为5个阶段：加载、创建、初始化、处理客户请求、卸载。\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.Servlet的生命周期分为5个阶段：加载、创建、初始化、处理客户请求、卸载。</h4><p>(1)加载：容器通过类加载器使用servlet类对应的文件加载servlet<br>(2)创建：通过调用servlet构造函数创建一个servlet对象<br>(3)初始化：调用init方法初始化<br>(4)处理客户请求：每当有一个客户请求，容器会创建一个线程来处理客户请求<br>(5)卸载：调用destroy方法让servlet自己释放其占用的资源</p>\r\n<h4 id=\"h4-2-jsp\"><a name=\"2.JSP\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.JSP</h4><p><img src=\"http://uploadfiles.nowcoder.com/images/20160308/595432_1457414324036_C3D4EB7F2D61708D0C0BE2921A45B74D\" alt=\"\"></p>','2017-03-14',0,20,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(557,'2017-03-17学习笔记','1.GC线程是否和守护线程 2.java堆排序','<h4 id=\"h4-1-gc-\"><a name=\"1.GC线程是否和守护线程\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.GC线程是否和守护线程</h4><h4 id=\"h4-2-java-\"><a name=\"2.java堆排序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.java堆排序</h4>','2017-03-17',0,19,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(558,'重载与重写','目前的问题：父类的功能无法满足子类的需求。 方法重写的前提： 必须要存在继承的关系。 方法的重写: 子父类出了同名的函数，这个我们就称作为方法的重写。 什么是时候要使用方法的重写：父类的功能无法满足子类的需求时。 方法重写要注意的事项： 1.方法重写时， 方法名与形参列表必须一致。 2.方法重写时，子类的权限修饰符必须要大于或者等于父类的权限修饰符。 3.方法重写时，子类的返回值类型必须要小于或者','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><p>目前的问题：父类的功能无法满足子类的需求。</p>\n<p>方法重写的前提： 必须要存在继承的关系。</p>\n<p>方法的重写: 子父类出了同名的函数，这个我们就称作为方法的重写。</p>\n<p>什么是时候要使用方法的重写：父类的功能无法满足子类的需求时。</p>\n<p>方法重写要注意的事项：<br>    1.方法重写时， 方法名与形参列表必须一致。<br>    2.方法重写时，子类的权限修饰符必须要大于或者等于父类的权限修饰符。<br>    3.方法重写时，子类的返回值类型必须要小于或者 等于父类的返回值类型。<br>    4.方法重写时， 子类抛出的异常类型要小于或者等于父类抛出的异常类型。<br>            Exception(最坏)<br>            RuntimeException(小坏)</p>\n<p>方法的重载：在一个类中 存在两个或者两个 以上的同名函数,称作为方法重载。</p>\n<p>方法重载的要求</p>\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"lit\">1.</span><span class=\"pln\"> </span><span class=\"pun\">函数名要一致。</span></code></li><li class=\"L1\"><code><span class=\"lit\">2.</span><span class=\"pln\"> </span><span class=\"pun\">形参列表不一致（形参的个数或形参</span><span class=\"pln\"> </span><span class=\"pun\">的类型不一致）</span></code></li><li class=\"L2\"><code><span class=\"lit\">3.</span><span class=\"pln\"> </span><span class=\"pun\">与返回值类型无关。</span></code></li></ol></pre></div>','2017-03-21',0,23,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(559,'垃圾回收算法','垃圾回收算法 1、标记-清除算法 2、复制算法 3、标记-整理算法 一、标记-清除算法 标记-清除算法采用从根集合进行扫描，对存活的对象对象标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收，如上图所示。 标记-清除算法不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效，但由于标记-清除算法直接回收不存活的对象，因此会造成内存碎片！ 二、复制算法 复制算法','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h2 id=\"h2-u5783u573Eu56DEu6536u7B97u6CD5\"><a name=\"垃圾回收算法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>垃圾回收算法</h2><p>1、标记-清除算法<br>2、复制算法<br>3、标记-整理算法</p>\n<h4 id=\"h4--\"><a name=\"一、标记-清除算法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、标记-清除算法</h4><p><img src=\"http://dl2.iteye.com/upload/attachment/0075/0386/29ae17ad-f8af-38b4-9e25-28ef3550858f.jpg\" alt=\"\">标记-清除算法采用从根集合进行扫描，对存活的对象对象标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收，如上图所示。<br>标记-清除算法不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效，但由于标记-清除算法直接回收不存活的对象，因此会造成内存碎片！</p>\n<h4 id=\"h4--\"><a name=\"二、复制算法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、复制算法</h4><p><img src=\"http://dl2.iteye.com/upload/attachment/0075/0388/91a656d4-f08a-377b-8eea-5785c2932533.jpg\" alt=\"\"><br>复制算法采用从根集合扫描，并将存活对象复制到一块新的，没有使用过的空间中，这种算法当控件存活的对象比较少时，极为高效，但是带来的成本是需要一块内存交换空间用于进行对象的移动。也就是我们前面提到的s0 s1等空间。</p>\n<h4 id=\"h4--\"><a name=\"三、标记-整理算法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、标记-整理算法</h4><p><img src=\"http://dl2.iteye.com/upload/attachment/0075/0390/6ba95f80-c7bc-3d09-b927-ac09297e9920.jpg\" alt=\"\"><br> 标记-整理算法采用标记-清除算法一样的方式进行对象的标记，但在清除时不同，在回收不存活的对象占用的空间后，会将所有的存活对象往左端空闲空间移动，并更新对应的指针。标记-整理算法是在标记-清除算法的基础上，又进行了对象的移动，因此成本更高，但是却解决了内存碎片的问题。</p>\n</div>','2017-04-09',0,28,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(560,'java分代回收','一、新生代内存的回收（minor GC）主要采用复制算法，下图展示了minor GC的执行过程。 二、对于新生代和旧生代，JVM可使用很多种垃圾回收器进行垃圾回收，下图展示了不同生代不通垃圾回收器，其中两个回收器之间有连线表示这两个回收器可以同时使用。 而这些垃圾回收器又分为串行回收方式、并行回收方式合并发回收方式执行，分别运用于不同的场景。如下图所示 三、收集器 1.Serial收集器 看名字我','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h2 id=\"h2--minor-gc-minor-gc-\"><a name=\"一、新生代内存的回收（minor GC）主要采用复制算法，下图展示了minor GC的执行过程。\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、新生代内存的回收（minor GC）主要采用复制算法，下图展示了minor GC的执行过程。</h2><p><img src=\"http://dl2.iteye.com/upload/attachment/0075/0392/732c7557-aa9a-3551-b14d-f543c5b0c94b.jpg\" alt=\"\"></p>\n<h2 id=\"h2--jvm-\"><a name=\"二、对于新生代和旧生代，JVM可使用很多种垃圾回收器进行垃圾回收，下图展示了不同生代不通垃圾回收器，其中两个回收器之间有连线表示这两个回收器可以同时使用。\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、对于新生代和旧生代，JVM可使用很多种垃圾回收器进行垃圾回收，下图展示了不同生代不通垃圾回收器，其中两个回收器之间有连线表示这两个回收器可以同时使用。</h2><p><img src=\"http://dl2.iteye.com/upload/attachment/0075/0394/0172f624-9018-3642-bf26-05a2c3071639.jpg\" alt=\"\"><br>而这些垃圾回收器又分为串行回收方式、并行回收方式合并发回收方式执行，分别运用于不同的场景。如下图所示<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0396/c962c2ad-273f-3de4-b2e3-a4dd8b946215.jpg\" alt=\"\"></p>\n<h2 id=\"h2--\"><a name=\"三、收集器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、收集器</h2><h4 id=\"h4-1-serial-\"><a name=\"1.Serial收集器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.Serial收集器</h4><p>看名字我们都可以看的出来，这个属于串行收集器。其运行示意图如下<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0398/681da5ca-5eff-3984-bece-3d80dfe905be.jpg\" alt=\"\"><br>    收集器是历史最悠久的一个回收器，JDK1.3之前广泛使用这个收集器，目前也是ClientVM下 ServerVM 4核4GB以下机器的默认垃圾回收器。串行收集器并不是只能使用一个CPU进行收集，而是当JVM需要进行垃圾回收的时候，需要中断所有的用户线程，知道它回收结束为止，因此又号称“Stop The World” 的垃圾回收器。注意，JVM中文名称为java虚拟机，因此它就像一台虚拟的电脑一样在工作，而其中的每一个线程就被认为是JVM的一个处理器，因此大家看到图中的CPU0、CPU1实际为用户的线程，而不是真正机器的CPU，大家不要误解哦。<br>    串行回收方式适合低端机器，是Client模式下的默认收集器，对CPU和内存的消耗不高，适合用户交互比较少，后台任务较多的系统。<br>    Serial收集器默认新旧生代的回收器搭配为Serial+ SerialOld</p>\n<h4 id=\"h4-2-parnew-\"><a name=\"2.ParNew收集器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.ParNew收集器</h4><p>ParNew收集器其实就是多线程版本的Serial收集器，其运行示意图如下<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0400/6443b39c-ed33-3d93-a690-87e646439561.jpg\" alt=\"\"><br>同样有Stop The World的问题，他是多CPU模式下的首选回收器（该回收器在单CPU的环境下回收效率远远低于Serial收集器，所以一定要注意场景哦），也是Server模式下的默认收集器。</p>\n<h4 id=\"h4-3-parallelscavenge\"><a name=\"3.ParallelScavenge\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.ParallelScavenge</h4><p>ParallelScavenge又被称为是吞吐量优先的收集器，器运行示意图如下<br><img src=\"http://dl.iteye.com/upload/attachment/0075/0402/5007beba-0b0e-3cf4-b146-c28b6c0dd696.jpg\" alt=\"\"><br> ParallelScavenge<br>所提到的吞吐量=程序运行时间/(JVM执行回收的时间+程序运行时间),假设程序运行了100分钟，JVM的垃圾回收占用1分钟，那么吞吐量就是99%。在当今网络告诉发达的今天，良好的响应速度是提升用户体验的一个重要指标，多核并行云计算的发展要求程序尽可能的使用CPU和内存资源，尽快的计算出最终结果，因此在交互不多的云端，比较适合使用该回收器。</p>\n<h4 id=\"h4-4-parallelold\"><a name=\"4.ParallelOld\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.ParallelOld</h4><p>ParallelOld是老生代并行收集器的一种，使用标记整理算法、是老生代吞吐量优先的一个收集器。这个收集器是JDK1.6之后刚引入的一款收集器，我们看之前那个图之间的关联关系可以看到，早期没有ParallelOld之前，吞吐量优先的收集器老生代只能使用串行回收收集器，大大的拖累了吞吐量优先的性能，自从JDK1.6之后，才能真正做到较高效率的吞吐量优先。其运行示意图如下<br><img src=\"http://dl.iteye.com/upload/attachment/0075/0406/9a14da85-f943-3408-ba88-c6bb3842a792.jpg\" alt=\"\"></p>\n<h4 id=\"h4-5-serialold\"><a name=\"5.SerialOld\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.SerialOld</h4><p>SerialOld是旧生代Client模式下的默认收集器，单线程执行；在JDK1.6之前也是ParallelScvenge回收新生代模式下旧生代的默认收集器，同时也是并发收集器CMS回收失败后的备用收集器。其运行示意图如下<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0404/ce7aabd5-b0e0-3cda-9b6c-607cf6ebf689.jpg\" alt=\"\"></p>\n<h4 id=\"h4-5-cms\"><a name=\"5.CMS\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.CMS</h4><p>CMS又称响应时间优先(最短回收停顿)的回收器，使用并发模式回收垃圾，使用标记-清除算法，CMS对CPU是非常敏感的，它的回收线程数=（CPU+3）/4，因此当CPU是2核的实惠，回收线程将占用的CPU资源的50%，而当CPU核心数为4时仅占用25%。他的运行示意图如下<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0408/4239228b-879f-382f-81c6-5c32799886d6.jpg\" alt=\"\"><br>模式主要分为四个过程：<br>1.初始标记<br>2.并发标记<br>3.重新标记<br>4.并发清除<br>在初始标记的时候，需要中断所有用户线程，在并发标记阶段，用户线程和标记线程<br>并发执行，而在这个过程中，随着内存引用关系的变化，可能会发生原来标记的对象被释放，进而引发新的垃圾，因此可能会产生一系列的浮动垃圾，不能被回收。</p>\n<p>CMS 为了确保能够扫描到所有的对象，避免在Initial Marking 中还有未标识到的对象，采用的方法为找到标记了的对象，并将这些对象放入Stack 中，扫描时寻找此对象依赖的对象，如果依赖的对象的地址在其之前，则将此对象进行标记，并同时放入Stack 中，如依赖的对象地址在其之后，则仅标记该对象。<br>在进行Concurrent Marking 时minor GC 也可能会同时进行，这个时候很容易造成旧生代对象引用关系改变，CMS 为了应对这样的并发现象，提供了一个Mod Union Table 来进行记录，在这个Mod Union Table中记录每次minor GC 后修改了的Card 的信息。这也是ParallelScavenge不能和CMS一起使用的原因。<br>CMS产生浮动垃圾的情况请见如下示意图<br><img src=\"http://dl2.iteye.com/upload/attachment/0075/0410/60e7c659-790a-3405-af70-9ca4cfd9258d.jpg\" alt=\"\"><br>在运行回收过后，c就变成了浮动垃圾。<br>由于CMS会产生浮动垃圾，当回收过后，浮动垃圾如果产生过多，同时因为使用标记-清除算法会产生碎片，可能会导致回收过后的连续空间仍然不能容纳新生代移动过来或者新创建的大资源，因此会导致CMS回收失败，进而触发另外一次FULL GC，而这时候则采用SerialOld进行二次回收。<br>同时CMS因为可能产生浮动垃圾，而CMS在执行回收的同时新生代也有可能在进行回收操作，为了保证旧生代能够存放新生代转移过来的数据，CMS在旧生代内存到达全部容量的68%就触发了CMS的回收！</p>\n<h4 id=\"h4-7-garbagefirst-g1-\"><a name=\"7.GarbageFirst(G1)\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>7.GarbageFirst(G1)</h4><p>我们再来看垃圾回收器的总图，刚才我们可以看到，我在图上标记了一个？，其实这是一个新的垃圾回收器，既可以回收新生代也可以回收旧生代，SunHotSpot 1.6u14以上EarlyAccess版本加入了这个回收器，sun公司预期SunHotSpot1.7发布正式版，他是商用高性能垃圾回收器，通过重新划分内存区域，整合优化CMS，同时注重吞吐量和响应时间，但是杯具的是被Oracle收购之后这个收集器属于商用收费收集器，因此目前基本上没有人使用，我们在这里也就不多介绍，更多信息可以参考oracle新版本JDK说明。</p>\n</div>','2017-04-09',0,31,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(561,'java汇编','java 汇编 http://download.csdn.net/download/jiangfuqiang/8403497','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><p>java 汇编<br><a href=\"http://download.csdn.net/download/jiangfuqiang/8403497\">http://download.csdn.net/download/jiangfuqiang/8403497</a></p>\n</div>','2017-05-10',0,32,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(562,'jvm','-XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><p>-XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly</p>\n</div>','2017-05-10',0,34,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(563,'Java堆.栈和常量池 笔记','Java堆.栈和常量池 笔记','<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><p><a href=\"http://www.iteye.com/topic/634530\">Java堆.栈和常量池 笔记</a></p>\n</div>','2017-06-23',0,37,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(564,'工厂模式','工厂模式 目录 何为工厂模式 工厂方法与抽象工厂 如何在Java EE中通过@Producers与@Inject注解实现工厂模式 如何创建自定义注解以及通过@Qualifier消除具体实现之间的歧义 工厂模式有两种模式：工厂方法和抽象方法。它们的意图是一样的：提供一个接口，在不指定具体类的情况下创建相关或依赖的一系列对象。 一.何为工厂模式 工厂的目的在于创建对象。创建的逻辑被封装在工厂中，要么提','<h1 id=\"h1-u5DE5u5382u6A21u5F0F\"><a name=\"工厂模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>工厂模式</h1><p>目录</p>\r\n<ul>\r\n<li>何为工厂模式</li><li>工厂方法与抽象工厂</li><li>如何在Java EE中通过<a href=\"https://github.com/Producers\" title=\"&#64;Producers\" class=\"at-link\">@Producers</a>与<a href=\"https://github.com/Inject\" title=\"&#64;Inject\" class=\"at-link\">@Inject</a>注解实现工厂模式</li><li>如何创建自定义注解以及通过<a href=\"https://github.com/Qualifier\" title=\"&#64;Qualifier\" class=\"at-link\">@Qualifier</a>消除具体实现之间的歧义<br>工厂模式有两种模式：工厂方法和抽象方法。它们的意图是一样的：提供一个接口，在不指定具体类的情况下创建相关或依赖的一系列对象。</li></ul>\r\n<h3 id=\"h3--\"><a name=\"一.何为工厂模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一.何为工厂模式</h3><p>工厂的目的在于创建对象。创建的逻辑被封装在工厂中，要么提供一个方法来返回新创建的对象（工厂方法模式），要么将对象的创建委托给子类（抽象工厂模式）。<br>客户端不必考虑接口或类的不同实现，它只需通过工厂（工厂）获取接口实现的一个实例的即可，这样客户端与对象的创建就实现了解耦<br>解耦是应用依赖反转原则的结果，这带来了很多好处，其中最重要的好处就是实现了高层类与底层类之间的解耦。通过解耦，具体类实现的变化不会影响到客户端，这降低了类与类之间的耦合，并提升了灵活性。</p>\r\n<h3 id=\"h3--\"><a name=\"二.工厂方法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二.工厂方法</h3><p>GoF一书是这样描述工程方法模式的：“定义一个用于创建对象的接口，不过让子类决定实例化那个类”<br>工厂极大降低了new关键字的使用次数，并且将初始化过程与不同的具体实现封装起来。将这些需求中心化可以极大减少向系统中添加或删除具体类的影响以及具体的类依赖的影响。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src=\"http://ohlrxdl4p.bkt.clouddn.com/images/QQ截图20170506134421.jpg\" alt=\"\"><br><strong>1.使用普通代码实现工厂方法</strong><br>被具体实现继承的DrinksMachine抽象类</p>\r\n<pre><code class=\"lang-java\">public abstract class DrinksMachine {\r\n    public abstract Drink dispenseDrink();\r\n    public String displayMessage(){\r\n        return &quot;Thank for your custom.&quot;;\r\n    }\r\n}\r\n</code></pre>\r\n<p>DrinksMachine抽象类的CoffeeMachine实现</p>\r\n<pre><code class=\"lang-java\">public class CoffeeMachine extends DrinksMachine {\r\n    public Drink dispenseDrink() {\r\n        return new Coffee();\r\n    }\r\n}\r\n</code></pre>\r\n<p>DrinksMachine抽象类的SoftDrinksMachine实现</p>\r\n<pre><code class=\"lang-java\">public class SoftDrinksMachine extends DrinksMachine {\r\n    public Drink dispenseDrink() {\r\n        return new SoftDrink();\r\n    }\r\n}\r\n</code></pre>\r\n<p>Drink接口</p>\r\n<pre><code class=\"lang-java\">public interface Drink {}\r\n</code></pre>\r\n<p>Drink接口的SoftDrink实现</p>\r\n<pre><code class=\"lang-java\">public class SoftDrink implements Drink {\r\n    SoftDrink() {\r\n        System.out.println(&quot;Soft drink&quot;);\r\n    }\r\n}\r\n</code></pre>\r\n<p>Drink接口的Coffee实现</p>\r\n<pre><code class=\"lang-java\">public class Coffee implements Drink {\r\n    Coffee() {\r\n        System.out.println(&quot;Coffee&quot;);\r\n    }\r\n}\r\n</code></pre>\r\n<p>CoffeeType枚举<br>```java<br>public enum CoffeeType {EXPRESSO, LATTE}</p>\r\n<p>public Drink dispenseDrink(CoffeeType type) {<br>    Drink coffee = null;<br>    switch (type) {<br>        case EXPRESSO: coffee = new Expresso();<br>        case LATTE: coffee = new Latte();<br>    }<br>    return coffee;<br>}<br>```&lt;!--前面不能有空格--&gt;</p>','2017-06-06',0,70,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(565,'代理模式','faweafwefefawefwe','faweafwefefawefwe','2017-07-01',0,94,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg'),(572,'faweafew','新建了一个自己的[个人网站](http://www.wenzhihuai.com/)，为了对文章进行索引的建立，顾采用了lucene来对文章进行搜索，方便自己查找文章也容易。但是也碰到了不少问题，最主要的还是分页与自动补全（强行忽略版本问题','新建了一个自己的[个人网站](http://www.wenzhihuai.com/)，为了对文章进行索引的建立，顾采用了lucene来对文章进行搜索，方便自己查找文章也容易。但是也碰到了不少问题，最主要的还是分页与自动补全（强行忽略版本问题）。\r\n下面是博客的实体类：\r\n```java\r\npublic class Blog implements Serializable {\r\n    /**\r\n     * 博客id，主键\r\n     */\r\n    private Integer blogid;\r\n    /**\r\n     * 博客标题\r\n     */\r\n    private String title;\r\n\r\n    /**\r\n     * 博客摘要，从博客文本中选取前200个字符\r\n     */\r\n    private String summary;\r\n    /**\r\n     * 博客文本\r\n     */\r\n    private String content;\r\n    /**\r\n     * 创建时间\r\n     */\r\n    private String createAt;\r\n    /**\r\n     * 类别id\r\n     */\r\n    private Integer categoryid;\r\n    /**\r\n     * 浏览量\r\n     */\r\n    private Integer hits;\r\n    /**\r\n     * 图片的url，选取第一张jpg/png图片作为文章的图片\r\n     */\r\n    private String imageurl;\r\n    /**\r\n     * 类别\r\n     */\r\n    private Category category;\r\n    /**\r\n     * 标签\r\n     */\r\n    private List<Tag> tags;\r\n	···\r\n```\r\n# 一、lucene分页\r\n目前lucene分页的方式主要有两种：\r\n1. 每次都全部查询，然后通过截取获得所需要的记录。由于采用了分词与倒排索引，所有速度是足够快的，但是在数据量过大的时候，占用内存过大，容易造成内存溢出\r\n2. 使用searchAfter把数据保存在缓存里面，然后再去取。这种方式对大量的数据友好，但是当数据量比较小的时候，速度会相对慢。\r\n```java\r\n /**\r\n     * 首先是对标题进行查找，然后对文章内容进行查找\r\n     * @param pageStart\r\n     * @param q\r\n     * @param pagehits\r\n     * @return\r\n     * @throws Exception\r\n     */\r\n    public List<Blog> searchBlog(Integer pageStart, String q, Integer pagehits) throws Exception {\r\n        dir = FSDirectory.open(Paths.get(\"blog_index\"));\r\n        IndexReader reader = DirectoryReader.open(dir);\r\n        IndexSearcher search = new IndexSearcher(reader);\r\n        ScoreDoc lastBottom = null;//相当于pageSize\r\n        BooleanQuery.Builder booleanQuery = new BooleanQuery.Builder();\r\n        SmartChineseAnalyzer analyzer = new SmartChineseAnalyzer();\r\n        QueryParser parser1 = new QueryParser(\"title\", analyzer);//对文章标题进行搜索\r\n        Query query1 = parser1.parse(q);\r\n        QueryParser parser2 = new QueryParser(\"content\", analyzer);//对文章内容进行搜索\r\n        Query query2 = parser2.parse(q);\r\n        booleanQuery.add(query1, BooleanClause.Occur.SHOULD);\r\n        booleanQuery.add(query2, BooleanClause.Occur.SHOULD);\r\n        TopDocs hits = search.searchAfter(lastBottom, booleanQuery.build(), pagehits);  //lastBottom（pageSize），pagehits（pagenum）\r\n        QueryScorer scorer = new QueryScorer(query1);         //\r\n        Fragmenter fragmenter = new SimpleSpanFragmenter(scorer);\r\n        SimpleHTMLFormatter simpleHTMLFormatter = new SimpleHTMLFormatter(\"<b><font color=\'red\'>\", \"</font></b>\");\r\n        Highlighter highlighter = new Highlighter(simpleHTMLFormatter, scorer);\r\n        highlighter.setTextFragmenter(fragmenter);\r\n        List<Blog> blogIndexList = new LinkedList<>();\r\n        for (ScoreDoc scoreDoc : hits.scoreDocs) {\r\n            Document doc = search.doc(scoreDoc.doc);\r\n            Blog blog = new Blog();\r\n            blog.setBlogid(Integer.parseInt(doc.get((\"blogid\"))));\r\n            blog.setCreateAt(DateTime.parse(doc.get(\"create_at\")).toString());\r\n            blog.setImageurl(doc.get(\"imageurl\"));\r\n            blog.setCategoryid(Integer.parseInt(doc.get(\"categoryid\")));\r\n            blog.setHits(Integer.parseInt(doc.get(\"hits\")));\r\n            String title = doc.get(\"title\");\r\n            String content = doc.get(\"content\");\r\n            if (title != null) {\r\n                TokenStream tokenStream = analyzer.tokenStream(\"title\", new StringReader(title));\r\n                String hTitle = highlighter.getBestFragment(tokenStream, title);\r\n                if (StringUtil.isEmpty(hTitle)) {\r\n                    blog.setTitle(title);\r\n                } else {\r\n                    blog.setTitle(hTitle);\r\n                }\r\n            }\r\n            if (content != null) {\r\n                TokenStream tokenStream = analyzer.tokenStream(\"content\", new StringReader(content));\r\n                String hContent = highlighter.getBestFragment(tokenStream, content);\r\n                if (StringUtil.isEmpty(hContent)) {\r\n                    if (content.length() <= 400) {//对结果进行截取\r\n                        blog.setSummary(content);\r\n                    } else {\r\n                        blog.setSummary(content.substring(0, 400));\r\n                    }\r\n                } else {\r\n                    blog.setSummary(hContent);\r\n                }\r\n            }\r\n            blogIndexList.add(blog);\r\n        }\r\n        return blogIndexList;\r\n    }\r\n```\r\n如何与mybatis的pagehelper使用呢？\r\n强行自己封装吧\r\n\r\n## 二、lucene自动补全\r\n百度、谷歌等在输入文字的时候会弹出补全框，如下图：\r\n![](http://ohlrxdl4p.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170728102929.png)\r\n\r\n在搭建lucene自动补全的时候，也有考虑过使用SQL语句中使用like来进行，主要还是like对数据库压力会大，而且相关度没有lucene的高。主要使用了官方suggest库以及[autocompelte.js](https://github.com/xdan/autocomplete/)这个插件。\r\nsuggest的原理[看这](http://iamyida.iteye.com/blog/2205114),以及索引结构[看这](http://blog.csdn.net/u011389474/article/details/69458445)。\r\n#### 使用：\r\n1.导入maven包\r\n```maven\r\n        <dependency>\r\n            <groupId>org.apache.lucene</groupId>\r\n            <artifactId>lucene-suggest</artifactId>\r\n            <version>6.6.0</version>\r\n        </dependency>\r\n```\r\n2.如果想将结果反序列化，声明实体类的时候要加上：\r\n```java\r\npublic class Blog implements Serializable {\r\n```\r\n3.实现InputIterator接口\r\n```java\r\npublic class BlogIterator implements InputIterator {\r\n    private static final Logger logger = LoggerFactory.getLogger(BlogIterator.class);\r\n    private Iterator<Blog> blogIterator;\r\n    private Blog currentBlog;\r\n\r\n    public BlogIterator(Iterator<Blog> blogIterator) {\r\n        this.blogIterator = blogIterator;\r\n    }\r\n\r\n    public boolean hasContexts() {\r\n        return true;\r\n    }\r\n\r\n\r\n    public boolean hasPayloads() {\r\n        return true;\r\n    }\r\n\r\n    public Comparator<BytesRef> getComparator() {\r\n        return null;\r\n    }\r\n\r\n    public BytesRef next() {\r\n        if (blogIterator.hasNext()) {\r\n            currentBlog = blogIterator.next();\r\n            try {\r\n                //返回当前Project的name值，把blog类的name属性值作为key\r\n                return new BytesRef(Jsoup.parse(currentBlog.getTitle()).text().getBytes(\"utf8\"));\r\n            } catch (Exception e) {\r\n                e.printStackTrace();\r\n                return null;\r\n            }\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 将Blog对象序列化存入payload\r\n     * 可以只将所需要的字段存入payload，这里对整个实体类进行序列化，方便以后需求，不建议采用这种方法\r\n     */\r\n    public BytesRef payload() {\r\n        try {\r\n            ByteArrayOutputStream bos = new ByteArrayOutputStream();\r\n            ObjectOutputStream out = new ObjectOutputStream(bos);\r\n            out.writeObject(currentBlog);\r\n            out.close();\r\n            BytesRef bytesRef = new BytesRef(bos.toByteArray());\r\n            return bytesRef;\r\n        } catch (IOException e) {\r\n            logger.error(\"\", e);\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 文章标题\r\n     */\r\n    public Set<BytesRef> contexts() {\r\n        try {\r\n            Set<BytesRef> regions = new HashSet<BytesRef>();\r\n            regions.add(new BytesRef(currentBlog.getTitle().getBytes(\"UTF8\")));\r\n            return regions;\r\n        } catch (UnsupportedEncodingException e) {\r\n            throw new RuntimeException(\"Couldn\'t convert to UTF-8\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 返回权重值，这个值会影响排序\r\n     * 这里以产品的销售量作为权重值，weight值即最终返回的热词列表里每个热词的权重值\r\n     */\r\n    public long weight() {\r\n        return currentBlog.getHits();   //change to hits\r\n    }\r\n}\r\n```\r\n4.ajax 简历索引\r\n```java\r\n    /**\r\n     * ajax简历索引\r\n     */\r\n    @Override\r\n    public void ajaxbuild() {\r\n        try {\r\n            Directory dir = FSDirectory.open(Paths.get(\"autocomplete\"));\r\n            SmartChineseAnalyzer analyzer = new SmartChineseAnalyzer();\r\n            AnalyzingInfixSuggester suggester = new AnalyzingInfixSuggester(dir, analyzer);\r\n            //创建Blog测试数据\r\n            List<Blog> blogs = blogMapper.getAllBlog();\r\n            suggester.build(new BlogIterator(blogs.iterator()));\r\n        } catch (IOException e) {\r\n            System.err.println(\"Error!\");\r\n        }\r\n    }\r\n```\r\n5.查找\r\n因为有些文章的标题是一样的，先对list排序，将标题短的放前面，长的放后面，然后使用linkhashset来存储。\r\n\r\n```java\r\n    @Override\r\n    public Set<String> ajaxsearch(String keyword) {\r\n        try {\r\n            Directory dir = FSDirectory.open(Paths.get(\"autocomplete\"));\r\n            SmartChineseAnalyzer analyzer = new SmartChineseAnalyzer();\r\n            AnalyzingInfixSuggester suggester = new AnalyzingInfixSuggester(dir, analyzer);\r\n            List<String> list = lookup(suggester, keyword);\r\n            list.sort(new Comparator<String>() {\r\n                @Override\r\n                public int compare(String o1, String o2) {\r\n                    if (o1.length() > o2.length()) {\r\n                        return 1;\r\n                    } else {\r\n                        return -1;\r\n                    }\r\n                }\r\n            });\r\n            Set<String> set = new LinkedHashSet<>();\r\n            for (String string : list) {\r\n                set.add(string);\r\n            }\r\n            ssubSet(set, 7);\r\n            return set;\r\n        } catch (IOException e) {\r\n            System.err.println(\"Error!\");\r\n            return null;\r\n        }\r\n    }\r\n```\r\n6.controller层\r\n```java\r\n    @RequestMapping(\"ajaxsearch\")\r\n    public void ajaxsearch(HttpServletRequest request, HttpServletResponse response) throws IOException {\r\n        String keyword = request.getParameter(\"keyword\");\r\n        if (StringUtils.isEmpty(keyword)) {\r\n            return;\r\n        }\r\n        Set<String> set = blogService.ajaxsearch(keyword);\r\n        Gson gson = new Gson();\r\n        response.getWriter().write(gson.toJson(set));\r\n    }\r\n```\r\n\r\n7.ajax来提交请求\r\n```js\r\n<link rel=\"stylesheet\" href=\"js/autocomplete/jquery.autocomplete.css\">\r\n<script src=\"js/autocomplete/jquery.autocomplete.js\" type=\"text/javascript\"></script>\r\n<script type=\"text/javascript\">\r\n    /******************** remote start **********************/\r\n    /**这里有个bug，页面加载的时候keyword为空也会发送请求**/\r\n    $(\'#remote_input\').autocomplete({\r\n        source: [\r\n            {\r\n                url: \"ajaxsearch.html?keyword=%QUERY%\",\r\n                type: \'remote\'\r\n            }\r\n        ]\r\n    });\r\n    /********************* remote end ********************/\r\n</script>\r\n```\r\n8.效果：\r\n![](http://ohlrxdl4p.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170728105628.png)\r\n\r\n#### 欢迎访问我的[个人网站](http://www.wenzhihuai.com/)','2017-07-29',0,14,'http://ohlrxdl4p.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170728105628.png'),(573,'Spring中Bean','### 一、什么是Bean\r\n1、Java面向对象，对象有方法和属性，那么就需要对象实例来调用方法和属性（即实例化）；\r\n2、凡是有方法或属性的类都需要实例化，这样才能具象化去使用这些方法和属性；\r\n3、规律：**凡是子类及带有方法或属性的','### 一、什么是Bean\r\n1、Java面向对象，对象有方法和属性，那么就需要对象实例来调用方法和属性（即实例化）；\r\n2、凡是有方法或属性的类都需要实例化，这样才能具象化去使用这些方法和属性；\r\n3、规律：**凡是子类及带有方法或属性的类都要加上注册Bean到Spring IoC的注解**；\r\n4、把Bean理解为类的代理或代言人（实际上确实是通过反射、代理来实现的），这样它就能代表类拥有该拥有的东西了。\r\n5、我们都在微博上@过某某，对方会优先看到这条信息，并给你反馈，那么在Spring中，你标识一个@符号，那么Spring就会来看看，并且从这里拿到一个Bean或者给出一个Bean\r\n\r\n### 二、注解分为两类：\r\n1、一类是使用Bean，即是把已经在xml文件中配置好的Bean拿来用，完成属性、方法的组装；比如@Autowired , @Resource，可以通过byTYPE（@Autowired）、byNAME（@Resource）的方式获取Bean；\r\n2、一类是注册Bean,@Component , @Repository , @ Controller , @Service , @Configration这些注解都是把你要实例化的对象转化成一个Bean，放在IoC容器中，等你要用的时候，它会和上面的@Autowired , @Resource配合到一起，把对象、属性、方法完美组装。\r\n\r\n\r\n### 三、[Bean的定义](http://blog.csdn.net/chenssy/article/details/8222744)\r\n<beans…/>元素是Spring配置文件的根元素，<bean…/>元素师<beans../>元素的子元素，<beans…/>元素可以包含多个<bean…/>子元素，每个<bean…/>元素可以定义一个Bean实例，每一个Bean对应Spring容器里的一个Java实例定义Bean时通常需要指定两个属性。\r\n\r\nSpring容器集中管理Bean的实例化，Bean实例可以通过BeanFactory的getBean(Stringbeanid)方法得到。BeanFactory是一个工厂，程序只需要获取BeanFactory引用，即可获得Spring容器管理全部实例的引用。程序不需要与具体实例的实现过程耦合。大部分Java EE应用里，应用在启动时，会自动创建Spring容器，组件之间直接以依赖注入的方式耦合，甚至无须主动访问Spring容器本身。\r\n\r\n当我们在配置文件中通过<bean id=”xxxx” class=”xx.XxClass”/>方法配置一个Bean时，这样就需要该Bean实现类中必须有一个无参构造器。故Spring底层相当于调用了如下代码：\r\n```java\r\nXxx = new xx.XxClass()  \r\n```\r\n        如果在配置文件中通过构造注入来创建Bean：\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>  \r\n<beans xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"  \r\n    xmlns=\"http://www.springframework.org/schema/beans\"  \r\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans  \r\n    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\">  \r\n    <bean id=\"bean1\" class=\"com.Bean1\">  \r\n        <constructor-arg value=\"chenssy\"/>  \r\n        <constructor-arg value=\"35-354\"/>  \r\n    </bean>  \r\n      \r\n</beans>  \r\n```\r\n则Spring相当于调用如下代码：\r\n```java\r\nBean bean = new com.Test(\"chenssy\",\"35-354\"); \r\n```\r\n\r\n# 四、[容器中Bean的作用域](http://blog.csdn.net/chenssy/article/details/8222744)\r\n当通过Spring容器创建一个Bean实例时，不仅可以完成Bean实例的实例化，还可以为Bean指定特定的作用域。\r\nSpring支持5种作用域：\r\n1.Singleton：单例模式。在整个SpringIoC容器中，使用singleton定义的Bean将只有一个实例。\r\n2.Prototype：原型模式。每次通过容器的getBean方法获取prototype定义的Bean时，都将产生一个新的Bean实例。\r\n3.request：对于每次HTTP请求，使用request定义的Bean都将产生一个新的实例，即每次HTTP请求都会产生不同的Bean实例。当然只有在WEB应用中使用Spring时，该作用域才真正有效。\r\n4.session：对于每次HTTPSession，使用session定义的Bean都将产生一个新的实例时，即每次HTTP Session都将产生不同的Bean实例。同HTTP一样，只有在WEB应用才会有效。\r\n5.global session：每个全局的HTTPSession对应一个Bean实例。仅在portlet Context的时候才有效。\r\n\r\n比较常用的singleton和prototype。如果一个Bean实例被设置为singleton，那么每次请求该Bean时都会获得相同的实例。容器负责跟踪Bean实例的状态，负责维护Bean实例的生命周期行为。如果一个Bean实例被设置为prototype，那么每次请求该di的Bean，Spring都会创建一个新的Bean实例返回给程序，在这种情况下，Spring容器仅仅使用new关键字创建Bean实例，一旦创建成功，容器将不会再跟踪实例，也不会维护Bean实例的状态。如果我们不指定Bean的作用域，则Spring会默认使用singleton作用域。Java在创建Java实例时，需要进行内存申请。销毁实例时，需要完成垃圾回收。这些工作都会导致系统开销的增加。因此，prototype作用域Bean的创建、销毁代价会比较大。而singleton作用域的Bean实例一旦创建成功，可以重复使用。因此，除非必要，否则尽量避免将Bean的作用域设置为prototype。','2017-07-31',1,15,'http://ohlrxdl4p.bkt.clouddn.com/timthumb_019.jpg');
/*!40000 ALTER TABLE `blog` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `category`
--

DROP TABLE IF EXISTS `category`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `category` (
  `c_id` int(11) NOT NULL AUTO_INCREMENT,
  `c_name` varchar(45) DEFAULT NULL,
  `c_descrip` varchar(100) DEFAULT NULL,
  `c_num` int(11) DEFAULT NULL,
  PRIMARY KEY (`c_id`)
) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `category`
--

LOCK TABLES `category` WRITE;
/*!40000 ALTER TABLE `category` DISABLE KEYS */;
INSERT INTO `category` VALUES (0,'生活笔记','生活笔记',53),(1,'java','jfoawepfji',34),(2,'python','iwejfowje',35),(3,'c','joijfowefi',75),(4,'算法','categorydescription',70),(5,'心情','心情',24),(6,'数据库','数据库',8);
/*!40000 ALTER TABLE `category` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `image`
--

DROP TABLE IF EXISTS `image`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `image` (
  `imageid` int(11) NOT NULL AUTO_INCREMENT,
  `imagename` varchar(45) DEFAULT NULL,
  `imagepath` varchar(1000) DEFAULT NULL,
  `banner` int(11) DEFAULT NULL,
  `content` varchar(1000) DEFAULT NULL,
  `datetime` varchar(45) DEFAULT NULL,
  `love` int(11) DEFAULT NULL,
  `iht` int(11) DEFAULT NULL,
  PRIMARY KEY (`imageid`)
) ENGINE=InnoDB AUTO_INCREMENT=161 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `image`
--

LOCK TABLES `image` WRITE;
/*!40000 ALTER TABLE `image` DISABLE KEYS */;
INSERT INTO `image` VALUES (16,'bar.jpg','http://ohlrxdl4p.bkt.clouddn.com/images/bnr.jpg',1,'jofwejfoawhe','2017-02-18 13:31:04',0,75),(17,'hifuhie','http://ohlrxdl4p.bkt.clouddn.com/images/img1.jpg',0,'bzzsbzsbsdbz','2017-02-18 13:50:10',0,135),(18,'nlvnsdkvzs','http://ohlrxdl4p.bkt.clouddn.com/images/img2.jpg',0,'nslvihzoisdv','2017-02-18 13:50:27',0,135),(19,'vlksndvlzksdv','http://ohlrxdl4p.bkt.clouddn.com/images/bnr2.jpg',1,'jjivosijoz','2017-02-18 13:50:51',0,75),(20,'nrizbjr','http://ohlrxdl4p.bkt.clouddn.com/images/img3.jpg',0,'nsbhviuhdiudhbiud','2017-02-18 13:54:07',0,135),(21,'nrizbjr','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'nsbhviuhdiudhbiud','2017-02-18 13:56:20',0,135),(22,'nrizbjr','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'nsbhviuhdiudhbiud','2017-02-18 13:56:20',0,135),(23,'nrizbjr','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'nsbhviuhdiudhbiud','2017-02-18 13:56:20',0,135),(24,'nrizbjr','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'nsbhviuhdiudhbiud','2017-02-18 13:56:20',0,135),(25,'nrizbjr','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'nsbhviuhdiudhbiud','2017-02-18 13:56:20',0,135),(26,'nrizbjr','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'nsbhviuhdiudhbiud','2017-02-18 13:56:20',0,135),(27,'nrizbjr','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'nsbhviuhdiudhbiud','2017-02-18 13:56:20',0,135),(28,'werxdcfgvhjjkb','http://ohlrxdl4p.bkt.clouddn.com/images/74a4adc16418987a9aa92c1aa6f10bba_r.jpg',0,'zhehehzeh','2017-02-19 18:35:16',0,112),(29,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(30,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(31,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(32,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(33,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(34,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(35,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(36,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(37,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(38,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(39,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(40,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(41,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(42,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(43,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(44,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(45,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(46,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(47,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(48,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(49,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(50,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(51,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(52,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(53,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(54,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(55,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(56,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(57,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(58,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(59,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(60,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(61,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(62,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(63,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(64,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(65,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(66,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(67,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(68,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(69,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(70,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(71,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(72,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(73,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(74,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(75,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(76,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(77,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(78,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(79,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(80,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(81,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(82,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(83,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(84,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(85,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(86,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(87,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(88,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(89,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(90,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(91,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(92,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(93,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(94,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(95,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(96,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(97,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(98,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(99,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(100,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(101,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(102,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(103,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(104,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(105,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(106,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(107,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(108,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(109,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(110,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(111,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(112,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(113,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(114,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(115,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(116,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(117,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(118,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(119,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(120,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(121,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(122,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(123,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(124,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(125,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(126,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(127,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(128,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(129,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(130,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(131,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(132,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(133,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(134,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(135,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(136,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(137,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(138,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(139,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(140,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(141,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(142,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(143,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(144,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(145,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(146,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(147,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(148,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(149,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(150,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(151,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(152,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(153,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(154,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(155,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(156,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(157,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(158,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(159,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135),(160,'ebweefwe','http://ohlrxdl4p.bkt.clouddn.com/images/img4.jpg',0,'ewe','2017-02-19 18:50:44',0,135);
/*!40000 ALTER TABLE `image` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `relation`
--

DROP TABLE IF EXISTS `relation`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `relation` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `blogid` int(11) DEFAULT NULL,
  `t_id` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=71 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `relation`
--

LOCK TABLES `relation` WRITE;
/*!40000 ALTER TABLE `relation` DISABLE KEYS */;
INSERT INTO `relation` VALUES (1,3,1),(2,5,1),(3,6,1),(4,7,1),(5,8,1),(6,9,1),(7,10,1),(8,11,1),(9,12,1),(10,14,1),(11,15,1),(12,16,1),(13,21,1),(14,25,1),(15,26,1),(16,27,1),(17,28,1),(18,29,1),(19,30,1),(20,31,1),(21,32,1),(22,33,1),(23,34,1),(24,36,1),(25,37,1),(26,50,1),(27,53,1),(28,59,1),(29,60,1),(30,62,1),(31,63,1),(32,64,1),(33,65,1),(34,66,1),(35,77,1),(36,79,1),(37,79,2),(50,597,9),(51,597,10),(52,597,11),(58,565,24),(59,565,25),(60,NULL,NULL),(61,NULL,2),(62,NULL,26),(63,NULL,2),(64,NULL,NULL),(65,NULL,NULL),(66,NULL,27),(67,567,32),(68,569,33),(69,572,37),(70,574,9);
/*!40000 ALTER TABLE `relation` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tag`
--

DROP TABLE IF EXISTS `tag`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `tag` (
  `t_id` int(11) NOT NULL AUTO_INCREMENT,
  `t_name` varchar(45) DEFAULT NULL,
  PRIMARY KEY (`t_id`)
) ENGINE=InnoDB AUTO_INCREMENT=39 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tag`
--

LOCK TABLES `tag` WRITE;
/*!40000 ALTER TABLE `tag` DISABLE KEYS */;
INSERT INTO `tag` VALUES (1,'python'),(2,'java'),(3,'html'),(4,'机器学习'),(5,'算法'),(6,'数据库'),(7,'jquery'),(8,'php'),(9,'fwe'),(10,'weafwefwe'),(11,'sfae'),(12,'fawea'),(13,'fawefawegawe'),(14,'afwef'),(15,'rberberbre'),(16,'afweawe'),(17,'baerber'),(21,'awefawea'),(22,'aebrbaeerb'),(23,'aeafefwefawef'),(24,'faweafwea'),(25,'baerberbrber'),(26,'lucene'),(27,'faw'),(28,'af'),(32,'FAWFW'),(33,'fef'),(34,'frer'),(35,'faweaf'),(36,'few'),(37,'132fwe'),(38,'Bean');
/*!40000 ALTER TABLE `tag` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2017-08-04 10:43:40
